"use strict";
(self["webpackChunkaurum_org"] = self["webpackChunkaurum_org"] || []).push([["vendors-node_modules_aurum-canvas_prebuilt_cjs_aurum-canvas_js"],{

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/aurum-canvas.js":
/*!****************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/aurum-canvas.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./components/canvas */ "./node_modules/aurum-canvas/prebuilt/cjs/components/canvas.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_rectangle */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_rectangle.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_text */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_text.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_line */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_line.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_elipse */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_elipse.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_group */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_group.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_path */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_path.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/state */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/state.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_image */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_image.js"), exports);
__exportStar(__webpack_require__(/*! ./components/drawables/aurum_regular_polygon */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_regular_polygon.js"), exports);
//# sourceMappingURL=aurum-canvas.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/canvas.js":
/*!*********************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/canvas.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumCanvas = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ./component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
const state_1 = __webpack_require__(/*! ./drawables/state */ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/state.js");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./node_modules/aurum-canvas/prebuilt/cjs/components/utilities.js");
const rendering_1 = __webpack_require__(/*! ./rendering */ "./node_modules/aurum-canvas/prebuilt/cjs/components/rendering.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/aurum-canvas/prebuilt/cjs/components/features.js");
const renderCache = new WeakMap();
function AurumCanvas(props, children, api) {
    var _a, _b;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    const components = api.prerender(children, lc);
    let pendingRerender;
    const cancellationToken = new aurumjs_1.CancellationToken();
    let onMouseMove = new aurumjs_1.EventEmitter();
    let onMouseUp = new aurumjs_1.EventEmitter();
    let onMouseDown = new aurumjs_1.EventEmitter();
    return (aurumjs_1.Aurum.factory("canvas", { onAttach: (canvas) => {
            var _a, _b, _c;
            if (props.features) {
                if (!props.scale) {
                    props.scale = new aurumjs_1.DataSource({ x: 1, y: 1 });
                }
                if (!props.translate) {
                    props.translate = new aurumjs_1.DataSource({ x: 0, y: 0 });
                }
                if (props.features.mouseWheelZoom) {
                    (0, features_1.initializeZoomFeature)(props, canvas);
                }
                if ((_a = props.features.panning) === null || _a === void 0 ? void 0 : _a.mouse) {
                    (0, features_1.initializeMousePanningFeature)(props, canvas);
                }
                if ((_b = props.features.panning) === null || _b === void 0 ? void 0 : _b.keyboard) {
                    (0, features_1.initializeKeyboardPanningFeature)(props, canvas);
                }
            }
            if (props.width instanceof aurumjs_1.DataSource) {
                props.width.listen(() => {
                    invalidate(canvas);
                }, api.cancellationToken);
            }
            if (props.backgroundColor instanceof aurumjs_1.DataSource) {
                props.backgroundColor.listen(() => {
                    invalidate(canvas);
                }, api.cancellationToken);
            }
            if (props.height instanceof aurumjs_1.DataSource) {
                props.height.listen(() => {
                    invalidate(canvas);
                }, api.cancellationToken);
            }
            bindCanvas(canvas, components, cancellationToken);
            render(canvas, components);
            if (props.translate) {
                props.translate.transform((0, aurumjs_1.dsUnique)(), api.cancellationToken).listen((v) => {
                    invalidate(canvas);
                });
            }
            if (props.scale) {
                props.scale.transform((0, aurumjs_1.dsUnique)(), api.cancellationToken).listen((v) => {
                    invalidate(canvas);
                });
            }
            (_c = props.onAttach) === null || _c === void 0 ? void 0 : _c.call(props, canvas);
        }, onDetach: () => {
            var _a;
            cancellationToken.cancel();
            (_a = props.onDetach) === null || _a === void 0 ? void 0 : _a.call(props);
        }, style: props.style, class: props.class, width: typeof props.width !== 'object' ? (_a = props.width) === null || _a === void 0 ? void 0 : _a.toString() : props.width.transform((0, aurumjs_1.dsMap)((v) => v.toString())), height: typeof props.height !== 'object' ? (_b = props.height) === null || _b === void 0 ? void 0 : _b.toString() : props.height.transform((0, aurumjs_1.dsMap)((v) => v.toString())) }));
    function bindCanvas(canvas, components, cancellationToken) {
        cancellationToken.registerDomEvent(canvas, 'mouseleave', (e) => {
            onMouseMove.fire(e);
        });
        cancellationToken.registerDomEvent(canvas, 'mousemove', (e) => {
            onMouseMove.fire(e);
        });
        cancellationToken.registerDomEvent(canvas, 'mousedown', (e) => {
            onMouseDown.fire(e);
        });
        cancellationToken.registerDomEvent(canvas, 'mouseup', (e) => {
            onMouseUp.fire(e);
        });
        bind(canvas, components, undefined, cancellationToken);
    }
    function isOnTopOf(e, target, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!target.renderedState) {
            return false;
        }
        let x = e.offsetX - (((_a = props.translate) === null || _a === void 0 ? void 0 : _a.value.x) ? ((_b = props.translate) === null || _b === void 0 ? void 0 : _b.value.x) * ((_e = (_d = (_c = props.scale) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.x) !== null && _e !== void 0 ? _e : 1) : 0);
        let y = e.offsetY - (((_f = props.translate) === null || _f === void 0 ? void 0 : _f.value.y) ? ((_g = props.translate) === null || _g === void 0 ? void 0 : _g.value.y) * ((_k = (_j = (_h = props.scale) === null || _h === void 0 ? void 0 : _h.value) === null || _j === void 0 ? void 0 : _j.x) !== null && _k !== void 0 ? _k : 1) : 0);
        if (props.scale) {
            x /= props.scale.value.x;
            y /= props.scale.value.y;
        }
        if (target.type === component_model_1.ComponentType.TEXT) {
            const label = target;
            const size = (_l = (0, utilities_1.deref)(label.fontSize)) !== null && _l !== void 0 ? _l : 16;
            if (!label.textBaseline) {
                y += size;
            }
            else {
                switch (label.textBaseline) {
                    case 'bottom':
                        y += size;
                        break;
                    case 'middle':
                        y += size / 2;
                        break;
                    case 'alphabetic':
                        y += size;
                        break;
                }
            }
        }
        switch (target.type) {
            case component_model_1.ComponentType.IMAGE:
            case component_model_1.ComponentType.RECTANGLE:
            case component_model_1.ComponentType.TEXT:
                return (x >= target.renderedState.x &&
                    y >= target.renderedState.y &&
                    x <= target.renderedState.x + target.renderedState.width * ((_o = (_m = props.scale) === null || _m === void 0 ? void 0 : _m.value.x) !== null && _o !== void 0 ? _o : 1) &&
                    y <= target.renderedState.y + target.renderedState.height * ((_q = (_p = props.scale) === null || _p === void 0 ? void 0 : _p.value.y) !== null && _q !== void 0 ? _q : 1));
            case component_model_1.ComponentType.ELIPSE:
            case component_model_1.ComponentType.REGULAR_POLYGON:
                if (!target.renderedState.path) {
                    return false;
                }
                else {
                    return context.isPointInPath(target.renderedState.path, x, y);
                }
            default:
                if (!target.renderedState.path) {
                    return false;
                }
                else {
                    return context.isPointInPath(target.renderedState.path, x - target.renderedState.x, y - target.renderedState.y);
                }
        }
    }
    function bind(canvas, children, parent, cancellationToken) {
        for (const child of children) {
            if (child instanceof aurumjs_1.ArrayDataSource) {
                child.listen(() => invalidate(canvas), cancellationToken);
                const tokenMap = new Map();
                child.listenAndRepeat((change) => {
                    switch (change.operation) {
                        case 'add':
                            for (const item of change.items) {
                                tokenMap.set(item, new aurumjs_1.CancellationToken());
                                bindDynamicEntity(item, child, tokenMap.get(item));
                            }
                            break;
                        case 'remove':
                            for (const item of change.items) {
                                tokenMap.get(item).cancel();
                                tokenMap.delete(item);
                            }
                            break;
                        case 'replace':
                            tokenMap.get(change.target).cancel();
                            tokenMap.delete(change.target);
                            tokenMap.set(change.items[0], new aurumjs_1.CancellationToken());
                            bindDynamicEntity(change.items[0], child, tokenMap.get(change.items[0]));
                            break;
                        case 'swap':
                            break;
                        case 'merge':
                            throw new Error('Operation not supported');
                    }
                });
                continue;
            }
            if (child instanceof aurumjs_1.DataSource || child instanceof aurumjs_1.DuplexDataSource) {
                child.listen(() => invalidate(canvas), cancellationToken);
                let bindToken;
                let value;
                child.listenAndRepeat((newValue) => {
                    if (value !== newValue) {
                        value = newValue;
                        if (bindToken) {
                            bindToken.cancel();
                        }
                        bindToken = new aurumjs_1.CancellationToken();
                        bindDynamicEntity(value, child, bindToken);
                    }
                });
                continue;
            }
            if (child[state_1.stateSymbol]) {
                if (!parent) {
                    throw new Error('Cannot use <State> nodes at root level');
                }
                parent.animations.push(child);
                continue;
            }
            if ('onMouseEnter' in child || 'onMouseLeave' in child) {
                let isInside = false;
                onMouseMove.subscribe((e) => {
                    if (isOnTopOf(e, child, canvas.getContext('2d'))) {
                        if (!isInside && child.onMouseEnter) {
                            child.onMouseEnter(e, child);
                        }
                        isInside = true;
                    }
                    else {
                        if (isInside && child.onMouseLeave) {
                            child.onMouseLeave(e, child);
                        }
                        isInside = false;
                    }
                }, cancellationToken);
            }
            for (const key in child) {
                if (key === 'onMouseUp') {
                    onMouseUp.subscribe((e) => {
                        if (isOnTopOf(e, child, canvas.getContext('2d'))) {
                            child.onMouseUp(e, child);
                        }
                    }, cancellationToken);
                    continue;
                }
                if (key === 'onMouseDown') {
                    onMouseUp.subscribe((e) => {
                        if (isOnTopOf(e, child, canvas.getContext('2d'))) {
                            child.onMouseUp(e, child);
                        }
                    }, cancellationToken);
                    continue;
                }
                if (key === 'onMouseClick') {
                    onMouseUp.subscribe((e) => {
                        if (isOnTopOf(e, child, canvas.getContext('2d'))) {
                            child.onMouseClick(e, child);
                        }
                    }, cancellationToken);
                    continue;
                }
                if (child[key] instanceof aurumjs_1.DataSource) {
                    let value = child[key].value;
                    let lastState;
                    if (key === 'state') {
                        const value = (0, utilities_1.deref)(child[key]);
                        lastState = value;
                        child.animationStates = child.animations.filter((e) => e.id === value);
                        child.animationTime = Date.now();
                    }
                    child[key].listen((newValue) => {
                        if (value !== newValue) {
                            value = newValue;
                            if (key === 'state') {
                                if (lastState !== newValue) {
                                    lastState = newValue;
                                    child.animationStates = child.animations.filter((e) => e.id === newValue);
                                    child.animationTime = Date.now();
                                    invalidate(canvas);
                                }
                            }
                            else {
                                invalidate(canvas);
                            }
                        }
                    }, cancellationToken);
                }
            }
            bind(canvas, child.children, child, cancellationToken);
        }
        function bindDynamicEntity(value, parent, bindToken) {
            const arrayedValue = Array.isArray(value) ? value : [value];
            const lc = (0, aurumjs_1.createLifeCycle)();
            const renderResult = [];
            for (const piece of arrayedValue) {
                if (!piece) {
                    continue;
                }
                if (!renderCache.has(piece)) {
                    renderCache.set(piece, api.prerender(piece, lc));
                }
                renderResult.push(renderCache.get(piece));
            }
            bind(canvas, renderResult, parent, bindToken);
            lc.onAttach();
            bindToken.addCancelable(() => lc.onDetach());
            invalidate(canvas);
        }
    }
    function invalidate(canvas) {
        if (!pendingRerender) {
            pendingRerender = requestAnimationFrame(() => {
                pendingRerender = undefined;
                if (canvas.isConnected) {
                    render(canvas, components);
                }
            });
        }
    }
    function render(canvas, components) {
        const context = canvas.getContext('2d');
        if (props.backgroundColor === undefined) {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }
        else {
            context.fillStyle = (0, utilities_1.deref)(props.backgroundColor);
            context.fillRect(0, 0, canvas.width, canvas.height);
        }
        applyContextTransformation(context);
        for (const child of components) {
            renderChild(context, child, 0, 0);
        }
        unapplyContextTransformation(context);
    }
    function unapplyContextTransformation(context) {
        if (props.scale || props.translate) {
            context.restore();
        }
    }
    function applyContextTransformation(context) {
        var _a, _b;
        if (props.scale || props.translate) {
            context.save();
            if ((_a = props.scale) === null || _a === void 0 ? void 0 : _a.value) {
                context.scale(props.scale.value.x, props.scale.value.y);
            }
            if ((_b = props.translate) === null || _b === void 0 ? void 0 : _b.value) {
                context.translate(props.translate.value.x, props.translate.value.y);
            }
        }
    }
    function renderChild(context, child, offsetX, offsetY) {
        if (child === undefined || child === null) {
            return;
        }
        if (Array.isArray(child)) {
            for (const item of child) {
                renderChild(context, item, offsetX, offsetY);
            }
            return;
        }
        if (child[state_1.stateSymbol]) {
            return;
        }
        if (child[aurumjs_1.aurumElementModelIdentitiy]) {
            if (!renderCache.has(child)) {
                throw new Error('illegal state: unrendered aurum element made it into the canvas render phase');
            }
            child = renderCache.get(child);
        }
        if (child instanceof aurumjs_1.ArrayDataSource) {
            for (const node of child.getData()) {
                renderChild(context, node, offsetX, offsetY);
            }
            return;
        }
        if (child instanceof aurumjs_1.DataSource || child instanceof aurumjs_1.DuplexDataSource) {
            renderChild(context, child.value, offsetX, offsetY);
            return;
        }
        context.save();
        let idle;
        switch (child.type) {
            case component_model_1.ComponentType.PATH:
                idle = (0, rendering_1.renderPath)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.REGULAR_POLYGON:
                idle = (0, rendering_1.renderRegularPolygon)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.RECTANGLE:
                idle = (0, rendering_1.renderRectangle)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.TEXT:
                idle = (0, rendering_1.renderText)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.LINE:
                idle = (0, rendering_1.renderLine)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.QUADRATIC_CURVE:
                idle = (0, rendering_1.renderQuadraticCurve)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.BEZIER_CURVE:
                idle = (0, rendering_1.renderBezierCurve)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.ELIPSE:
                idle = (0, rendering_1.renderElipse)(context, child, offsetX, offsetY);
                break;
            case component_model_1.ComponentType.GROUP:
                idle = true;
                break;
        }
        if (!idle) {
            invalidate(context.canvas);
        }
        for (const subChild of child.children) {
            renderChild(context, subChild, (0, utilities_1.deref)(child.x) + offsetX, (0, utilities_1.deref)(child.y) + offsetY);
        }
        context.restore();
    }
}
exports.AurumCanvas = AurumCanvas;
//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js":
/*!******************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentType = void 0;
var ComponentType;
(function (ComponentType) {
    ComponentType[ComponentType["RECTANGLE"] = 0] = "RECTANGLE";
    ComponentType[ComponentType["ELIPSE"] = 1] = "ELIPSE";
    ComponentType[ComponentType["LINE"] = 2] = "LINE";
    ComponentType[ComponentType["TEXT"] = 3] = "TEXT";
    ComponentType[ComponentType["IMAGE"] = 4] = "IMAGE";
    ComponentType[ComponentType["GROUP"] = 5] = "GROUP";
    ComponentType[ComponentType["STATE"] = 6] = "STATE";
    ComponentType[ComponentType["PATH"] = 7] = "PATH";
    ComponentType[ComponentType["QUADRATIC_CURVE"] = 8] = "QUADRATIC_CURVE";
    ComponentType[ComponentType["BEZIER_CURVE"] = 9] = "BEZIER_CURVE";
    ComponentType[ComponentType["REGULAR_POLYGON"] = 10] = "REGULAR_POLYGON";
})(ComponentType = exports.ComponentType || (exports.ComponentType = {}));
//# sourceMappingURL=component_model.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_elipse.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_elipse.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumElipse = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumElipse(props, children, api) {
    var _a;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.ELIPSE
    };
}
exports.AurumElipse = AurumElipse;
//# sourceMappingURL=aurum_elipse.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_group.js":
/*!************************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_group.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumGroup = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumGroup(props, children, api) {
    var _a, _b;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    (_a = props.x) !== null && _a !== void 0 ? _a : (props.x = 0);
    (_b = props.y) !== null && _b !== void 0 ? _b : (props.y = 0);
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.GROUP
    };
}
exports.AurumGroup = AurumGroup;
//# sourceMappingURL=aurum_group.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_image.js":
/*!************************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_image.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumImage = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumImage(props, children, api) {
    var _a;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.IMAGE
    };
}
exports.AurumImage = AurumImage;
//# sourceMappingURL=aurum_image.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_line.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_line.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumLine = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumLine(props, children, api) {
    var _a, _b;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        lineWidth: (_b = props.lineWidth) !== null && _b !== void 0 ? _b : 1,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.LINE
    };
}
exports.AurumLine = AurumLine;
//# sourceMappingURL=aurum_line.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_path.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_path.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumPath = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumPath(props, children, api) {
    var _a;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.PATH
    };
}
exports.AurumPath = AurumPath;
//# sourceMappingURL=aurum_path.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_rectangle.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_rectangle.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumRectangle = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumRectangle(props, children, api) {
    var _a;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.RECTANGLE
    };
}
exports.AurumRectangle = AurumRectangle;
//# sourceMappingURL=aurum_rectangle.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_regular_polygon.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_regular_polygon.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumRegularPolygon = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumRegularPolygon(props, children, api) {
    var _a;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const components = api.prerender(children, lc).filter((c) => !!c);
    return {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        renderedState: undefined,
        children: components,
        animations: [],
        type: component_model_1.ComponentType.REGULAR_POLYGON
    };
}
exports.AurumRegularPolygon = AurumRegularPolygon;
//# sourceMappingURL=aurum_regular_polygon.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_text.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/aurum_text.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AurumText = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
function AurumText(props, children, api) {
    var _a;
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    if (props.onAttach) {
        api.onAttach(() => props.onAttach());
    }
    if (props.onDetach) {
        api.onDetach(() => props.onDetach());
    }
    const content = api.prerender(children, lc).filter((c) => !!c);
    const text = new aurumjs_1.DataSource('');
    if (props.font instanceof aurumjs_1.DataSource) {
        props.font.listen(() => {
            if (result.renderedState) {
                result.renderedState.lines = [];
            }
        }, api.cancellationToken);
    }
    if (props.fontWeight instanceof aurumjs_1.DataSource) {
        props.fontWeight.listen(() => {
            if (result.renderedState) {
                result.renderedState.lines = [];
            }
        }, api.cancellationToken);
    }
    if (props.fontSize instanceof aurumjs_1.DataSource) {
        props.fontSize.listen(() => {
            if (result.renderedState) {
                result.renderedState.lines = [];
            }
        }, api.cancellationToken);
    }
    if (props.width instanceof aurumjs_1.DataSource) {
        props.width.listen(() => {
            if (result.renderedState) {
                result.renderedState.lines = [];
            }
        }, api.cancellationToken);
    }
    if (props.wrapWidth instanceof aurumjs_1.DataSource) {
        props.wrapWidth.listen(() => {
            if (result.renderedState) {
                result.renderedState.lines = [];
            }
        }, api.cancellationToken);
    }
    for (const i of content) {
        if (i instanceof aurumjs_1.DataSource) {
            i.transform((0, aurumjs_1.dsUnique)(), api.cancellationToken).listen((v) => {
                if (result.renderedState) {
                    result.renderedState.lines = [];
                }
                updateText(text, content);
            });
        }
    }
    updateText(text, content);
    const result = {
        ...props,
        opacity: (_a = props.opacity) !== null && _a !== void 0 ? _a : 1,
        renderedState: undefined,
        text,
        children: [],
        animations: [],
        type: component_model_1.ComponentType.TEXT
    };
    return result;
}
exports.AurumText = AurumText;
function updateText(text, content) {
    text.update(content.reduce((p, c) => {
        if (typeof c === 'string') {
            return `${p}${c}`;
        }
        else {
            if (c.value) {
                return `${p}${c.value}`;
            }
            else {
                return p;
            }
        }
    }, ''));
}
//# sourceMappingURL=aurum_text.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/state.js":
/*!******************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/drawables/state.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.State = exports.stateSymbol = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
const component_model_1 = __webpack_require__(/*! ../component_model */ "./node_modules/aurum-canvas/prebuilt/cjs/components/component_model.js");
exports.stateSymbol = Symbol('state');
function State(props, children, api) {
    const lc = (0, aurumjs_1.createLifeCycle)();
    api.synchronizeLifeCycle(lc);
    const components = api.prerender(children, lc);
    return {
        [exports.stateSymbol]: true,
        x: undefined,
        y: undefined,
        ...props,
        renderedState: undefined,
        animations: [],
        children: components,
        type: component_model_1.ComponentType.STATE
    };
}
exports.State = State;
//# sourceMappingURL=state.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/features.js":
/*!***********************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/features.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeZoomFeature = exports.initializeMousePanningFeature = exports.initializeKeyboardPanningFeature = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
function initializeKeyboardPanningFeature(props, canvas) {
    let moveToken;
    const keyDown = new Set();
    const moveVector = {
        x: 0,
        y: 0
    };
    window.addEventListener('keyup', (e) => {
        if (e.keyCode === props.features.panning.keyboard.leftKeyCode || e.keyCode === props.features.panning.keyboard.rightKeyCode) {
            moveVector.x = 0;
            keyDown.delete(e.keyCode);
        }
        if (e.keyCode === props.features.panning.keyboard.upKeyCode || e.keyCode === props.features.panning.keyboard.downKeyCode) {
            moveVector.y = 0;
            keyDown.delete(e.keyCode);
        }
        if (moveToken && keyDown.size === 0) {
            moveToken.cancel();
            moveToken = undefined;
        }
    });
    window.addEventListener('keydown', (e) => {
        if (e.keyCode === props.features.panning.keyboard.leftKeyCode) {
            moveVector.x = props.features.panning.keyboard.pixelsPerFrame;
            keyDown.add(e.keyCode);
        }
        if (e.keyCode === props.features.panning.keyboard.downKeyCode) {
            moveVector.y = -props.features.panning.keyboard.pixelsPerFrame;
            keyDown.add(e.keyCode);
        }
        if (e.keyCode === props.features.panning.keyboard.rightKeyCode) {
            moveVector.x = -props.features.panning.keyboard.pixelsPerFrame;
            keyDown.add(e.keyCode);
        }
        if (e.keyCode === props.features.panning.keyboard.upKeyCode) {
            moveVector.y = props.features.panning.keyboard.pixelsPerFrame;
            keyDown.add(e.keyCode);
        }
        if (!moveToken && keyDown.size > 0) {
            moveToken = new aurumjs_1.CancellationToken();
            moveToken.animationLoop(() => {
                props.translate.update({
                    x: props.translate.value.x + moveVector.x,
                    y: props.translate.value.y + moveVector.y
                });
            });
        }
    });
}
exports.initializeKeyboardPanningFeature = initializeKeyboardPanningFeature;
function initializeMousePanningFeature(props, canvas) {
    let downX;
    let downY;
    let beforeX;
    let beforeY;
    let down = false;
    canvas.addEventListener('mousedown', (e) => {
        downX = e.clientX;
        downY = e.clientY;
        beforeX = props.translate.value.x;
        beforeY = props.translate.value.y;
        down = true;
    });
    document.addEventListener('mousemove', (e) => {
        if (down) {
            props.translate.update({
                x: beforeX - (downX - e.clientX) / props.scale.value.x,
                y: beforeY - (downY - e.clientY) / props.scale.value.y
            });
        }
    });
    document.addEventListener('mouseup', (e) => {
        down = false;
    });
}
exports.initializeMousePanningFeature = initializeMousePanningFeature;
function initializeZoomFeature(props, canvas) {
    canvas.addEventListener('wheel', (e) => {
        if (e.deltaY > 0) {
            if (props.scale.value.x < props.features.mouseWheelZoom.minZoom) {
                return;
            }
            props.translate.update({
                x: props.translate.value.x + (e.offsetX * (props.features.mouseWheelZoom.zoomIncrements - 1)) / props.scale.value.x,
                y: props.translate.value.y + (e.offsetY * (props.features.mouseWheelZoom.zoomIncrements - 1)) / props.scale.value.y
            });
            props.scale.update({
                x: props.scale.value.x / props.features.mouseWheelZoom.zoomIncrements,
                y: props.scale.value.y / props.features.mouseWheelZoom.zoomIncrements
            });
        }
        else {
            if (props.scale.value.x > props.features.mouseWheelZoom.maxZoom) {
                return;
            }
            props.scale.update({
                x: props.scale.value.x * props.features.mouseWheelZoom.zoomIncrements,
                y: props.scale.value.y * props.features.mouseWheelZoom.zoomIncrements
            });
            props.translate.update({
                x: props.translate.value.x - (e.offsetX * (props.features.mouseWheelZoom.zoomIncrements - 1)) / props.scale.value.x,
                y: props.translate.value.y - (e.offsetY * (props.features.mouseWheelZoom.zoomIncrements - 1)) / props.scale.value.y
            });
        }
    });
}
exports.initializeZoomFeature = initializeZoomFeature;
//# sourceMappingURL=features.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/rendering.js":
/*!************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/rendering.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveValues = exports.renderRectangle = exports.renderText = exports.renderRegularPolygon = exports.renderPath = exports.renderBezierCurve = exports.renderQuadraticCurve = exports.renderLine = exports.renderElipse = void 0;
const utilities_1 = __webpack_require__(/*! ./utilities */ "./node_modules/aurum-canvas/prebuilt/cjs/components/utilities.js");
const regularPolygonKeys = ['x', 'y', 'opacity', 'strokeColor', 'fillColor', 'path', 'sides', 'radius', 'originX', 'originY'];
const pathKeys = ['x', 'y', 'opacity', 'strokeColor', 'fillColor', 'path', 'lineWidth', 'originX', 'originY'];
const elipseKeys = ['x', 'y', 'opacity', 'strokeColor', 'fillColor', 'rotation', 'rx', 'ry', 'startAngle', 'endAngle', 'originX', 'originY'];
const lineKeys = ['x', 'y', 'opacity', 'strokeColor', 'fillColor', 'tx', 'ty', 'lineWidth', 'originX', 'originY'];
const quadraticCurveKeys = ['x', 'y', 'opacity', 'strokeColor', 'fillColor', 'tx', 'ty', 'cx', 'cy', 'lineWidth', 'originX', 'originY'];
const bezierCurveKeys = ['x', 'y', 'opacity', 'strokeColor', 'fillColor', 'tx', 'ty', 'cx', 'cy', 'c2x', 'c2y', 'lineWidth', 'originX', 'originY'];
const textKeys = [
    'x',
    'y',
    'realWidth',
    'width',
    'font',
    'fontSize',
    'opacity',
    'strokeColor',
    'fillColor',
    'text',
    'fontWeight',
    'wrapWidth',
    'lineHeight',
    'textBaseline',
    'originX',
    'originY'
];
const rectangleKeys = ['x', 'y', 'width', 'height', 'opacity', 'strokeColor', 'fillColor', 'originX', 'originY'];
function renderElipse(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, elipseKeys, offsetX, offsetY);
    const { x, y, idle, fillColor, strokeColor, opacity, rx, ry, rotation, startAngle, endAngle } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    context.globalAlpha = opacity;
    const path2d = new Path2D();
    if ((fillColor || strokeColor) && rx > 0.01 && ry > 0.01 && (startAngle !== null && startAngle !== void 0 ? startAngle : 0 !== endAngle)) {
        path2d.ellipse(x, y, rx, ry, rotation !== null && rotation !== void 0 ? rotation : 0, startAngle !== null && startAngle !== void 0 ? startAngle : 0, endAngle !== null && endAngle !== void 0 ? endAngle : Math.PI * 2);
        child.renderedState.path = path2d;
    }
    else {
        child.renderedState.path = undefined;
    }
    drawCanvasPath(child, context, path2d, fillColor, strokeColor);
    return idle;
}
exports.renderElipse = renderElipse;
function renderLine(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, lineKeys, offsetX, offsetY);
    const { x, y, idle, fillColor, strokeColor, opacity, tx, ty, lineWidth } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    const path2d = new Path2D();
    context.globalAlpha = opacity;
    if (fillColor || strokeColor) {
        path2d.moveTo(x, y);
        path2d.lineTo(tx, ty);
        context.lineWidth = lineWidth;
        child.renderedState.path = path2d;
    }
    else {
        child.renderedState.path = undefined;
    }
    drawCanvasPath(child, context, path2d, fillColor, strokeColor);
    return idle;
}
exports.renderLine = renderLine;
function renderQuadraticCurve(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, quadraticCurveKeys, offsetX, offsetY);
    const { x, y, cx, cy, idle, fillColor, strokeColor, opacity, tx, ty, lineWidth } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    context.globalAlpha = opacity;
    const path2d = new Path2D();
    if (fillColor || strokeColor) {
        path2d.moveTo(x, y);
        path2d.quadraticCurveTo(cx, cy, tx, ty);
        context.lineWidth = lineWidth;
        child.renderedState.path = path2d;
    }
    else {
        child.renderedState.path = undefined;
    }
    drawCanvasPath(child, context, path2d, fillColor, strokeColor);
    return idle;
}
exports.renderQuadraticCurve = renderQuadraticCurve;
function renderBezierCurve(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, bezierCurveKeys, offsetX, offsetY);
    const { x, y, cx, cy, c2x, c2y, idle, fillColor, strokeColor, opacity, tx, ty, lineWidth } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    context.globalAlpha = opacity;
    const path2d = new Path2D();
    if (fillColor || strokeColor) {
        path2d.moveTo(x, y);
        path2d.bezierCurveTo(cx, cy, c2x, c2y, tx, ty);
        context.lineWidth = lineWidth;
        child.renderedState.path = path2d;
    }
    else {
        child.renderedState.path = undefined;
    }
    drawCanvasPath(child, context, path2d, fillColor, strokeColor);
    return idle;
}
exports.renderBezierCurve = renderBezierCurve;
function drawCanvasPath(child, context, path2d, fillColor, strokeColor) {
    if (child.fillColor) {
        context.fillStyle = fillColor;
        context.fill(path2d);
    }
    if (child.strokeColor) {
        context.strokeStyle = strokeColor;
        context.stroke(path2d);
    }
    if (child.clip) {
        context.clip(path2d);
    }
}
function renderPath(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, pathKeys, offsetX, offsetY);
    const { x, y, idle, fillColor, strokeColor, opacity, path, lineWidth } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    let path2d;
    context.globalAlpha = opacity;
    if (fillColor || strokeColor) {
        context.lineWidth = lineWidth;
        path2d = new Path2D(path);
        child.renderedState.path = path2d;
    }
    else {
        child.renderedState.path = undefined;
    }
    if (child.fillColor) {
        context.translate(x, y);
        context.fillStyle = fillColor;
        context.fill(path2d);
        context.translate(-x, -y);
    }
    if (child.strokeColor) {
        context.translate(x, y);
        context.strokeStyle = strokeColor;
        context.stroke(path2d);
        context.translate(-x, -y);
    }
    if (child.clip) {
        context.translate(x, y);
        context.clip(path2d);
        context.translate(-x, -y);
    }
    return idle;
}
exports.renderPath = renderPath;
function renderRegularPolygon(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, regularPolygonKeys, offsetX, offsetY);
    const { x, y, idle, fillColor, strokeColor, opacity, sides, radius } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    context.globalAlpha = opacity;
    if (renderedState.sides < 3) {
        return idle;
    }
    const path2d = new Path2D();
    if (fillColor || strokeColor) {
        let angle = 0;
        for (let i = 0; i < sides; i++) {
            angle += Math.PI / (sides / 2);
            const targetX = radius * Math.cos(angle);
            const targetY = radius * Math.sin(angle);
            if (i === 0) {
                path2d.moveTo(targetX + radius + x, targetY + radius + y);
            }
            else {
                path2d.lineTo(targetX + radius + x, targetY + radius + y);
            }
        }
        child.renderedState.path = path2d;
    }
    else {
        child.renderedState.path = undefined;
    }
    drawCanvasPath(child, context, path2d, fillColor, strokeColor);
    return idle;
}
exports.renderRegularPolygon = renderRegularPolygon;
function renderText(context, child, offsetX, offsetY) {
    var _a, _b, _c, _d, _e;
    const renderedState = resolveValues(child, textKeys, offsetX, offsetY, false);
    let { x, y, idle, fontSize = 16, textBaseline, font, fillColor, strokeColor, opacity, text, fontWeight, width, wrapWidth, lineHeight, originX } = renderedState;
    if (((_a = child.renderedState) === null || _a === void 0 ? void 0 : _a.width) && !renderedState.width) {
        renderedState.width = child.renderedState.width;
    }
    if (((_b = child.renderedState) === null || _b === void 0 ? void 0 : _b.realWidth) && !renderedState.realWidth) {
        renderedState.realWidth = child.renderedState.realWidth;
    }
    renderedState.lines = (_c = child.renderedState) === null || _c === void 0 ? void 0 : _c.lines;
    child.renderedState = renderedState;
    child.renderedState.lines = (_d = child.renderedState.lines) !== null && _d !== void 0 ? _d : [];
    let lines = child.renderedState.lines;
    if (textBaseline) {
        context.textBaseline = textBaseline;
    }
    context.font = `${fontWeight ? fontWeight + ' ' : ''}${fontSize}px ${font !== null && font !== void 0 ? font : 'Arial'}`;
    renderedState.height = fontSize;
    if (lines.length === 0) {
        if (wrapWidth) {
            child.renderedState.realWidth = 0;
            const pieces = text.split(' ');
            let line = pieces.shift();
            while (pieces.length) {
                const measuredWidth = context.measureText(line + ' ' + pieces[0]);
                if (measuredWidth.width > child.renderedState.realWidth) {
                    child.renderedState.realWidth = measuredWidth.width;
                }
                if (measuredWidth <= wrapWidth) {
                    line += ' ' + pieces.shift();
                }
                else {
                    lines.push(line);
                    line = pieces.shift();
                }
            }
            lines.push(line);
        }
        else {
            if (!width) {
                child.renderedState.realWidth = child.renderedState.width = context.measureText(text).width;
            }
            else {
                child.renderedState.realWidth = context.measureText(text).width;
            }
            lines.push(text);
        }
    }
    (_e = child.onPreDraw) === null || _e === void 0 ? void 0 : _e.call(child, child.renderedState);
    context.globalAlpha = opacity;
    if (originX) {
        x -= Math.min(child.renderedState.realWidth, child.renderedState.width) * originX;
    }
    for (let i = 0; i < lines.length; i++) {
        if (fillColor) {
            context.fillStyle = fillColor;
            context.fillText(lines[i], x, y + (lineHeight !== null && lineHeight !== void 0 ? lineHeight : 16) * i, width);
        }
        if (strokeColor) {
            context.strokeStyle = strokeColor;
            context.strokeText(lines[i], x, y + (lineHeight !== null && lineHeight !== void 0 ? lineHeight : 16) * i, width);
        }
    }
    return idle;
}
exports.renderText = renderText;
function renderRectangle(context, child, offsetX, offsetY) {
    var _a;
    const renderedState = resolveValues(child, rectangleKeys, offsetX, offsetY);
    const { x, y, width, height, idle, fillColor, strokeColor, opacity } = renderedState;
    child.renderedState = renderedState;
    (_a = child.onPreDraw) === null || _a === void 0 ? void 0 : _a.call(child, child.renderedState);
    if (opacity <= 0 && !child.clip) {
        return idle;
    }
    context.globalAlpha = opacity;
    if (fillColor) {
        context.fillStyle = fillColor;
        context.fillRect(x, y, width, height);
    }
    if (strokeColor) {
        context.strokeStyle = strokeColor;
        context.strokeRect(x, y, width, height);
    }
    if (child.clip) {
        context.beginPath();
        context.rect(x, y, width, height);
        context.clip();
    }
    return idle;
}
exports.renderRectangle = renderRectangle;
function resolveValues(node, props, offsetX, offsetY, applyOrigin = true) {
    var _a;
    const result = {
        idle: true,
        x: 0,
        y: 0
    };
    let idle = true;
    for (const key of props) {
        const baseValue = (0, utilities_1.deref)(node[key]);
        const state = (_a = node.animationStates) === null || _a === void 0 ? void 0 : _a.find((n) => n[key] != undefined);
        if (state) {
            let progress;
            if (!state.transitionTime) {
                progress = 1;
            }
            else {
                progress = Math.min(1, (Date.now() - node.animationTime) / (0, utilities_1.deref)(state.transitionTime));
            }
            const targetValue = state[key];
            result[key] = baseValue + (targetValue - baseValue) * progress;
            if (progress < 1) {
                idle = false;
            }
        }
        else {
            result[key] = baseValue;
        }
    }
    result.x += offsetX;
    result.y += offsetY;
    if (applyOrigin) {
        //@ts-ignore
        if (result.originX && result.width) {
            //@ts-ignore
            result.x -= result.width * result.originX;
        }
        //@ts-ignore
        if (result.originY && result.height) {
            //@ts-ignore
            result.y -= result.height * result.originY;
        }
    }
    if ('tx' in result) {
        //@ts-ignore
        result.tx += offsetX;
    }
    if ('ty' in result) {
        //@ts-ignore
        result.ty += offsetY;
    }
    if ('cx' in result) {
        //@ts-ignore
        result.cx += offsetX;
    }
    if ('cy' in result) {
        //@ts-ignore
        result.cy += offsetY;
    }
    if ('c2x' in result) {
        //@ts-ignore
        result.c2x += offsetX;
    }
    if ('c2y' in result) {
        //@ts-ignore
        result.c2y += offsetY;
    }
    result.idle = idle;
    return result;
}
exports.resolveValues = resolveValues;
//# sourceMappingURL=rendering.js.map

/***/ }),

/***/ "./node_modules/aurum-canvas/prebuilt/cjs/components/utilities.js":
/*!************************************************************************!*\
  !*** ./node_modules/aurum-canvas/prebuilt/cjs/components/utilities.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deref = void 0;
const aurumjs_1 = __webpack_require__(/*! aurumjs */ "./node_modules/aurumjs/prebuilt/cjs/aurumjs.js");
function deref(source) {
    if (source instanceof aurumjs_1.DataSource) {
        return source.value;
    }
    else {
        return source;
    }
}
exports.deref = deref;
//# sourceMappingURL=utilities.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2pzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2F1cnVtLWNhbnZhc19wcmVidWlsdF9janNfYXVydW0tY2FudmFzX2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsMEZBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxnSUFBd0M7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHNIQUFtQztBQUN4RCxhQUFhLG1CQUFPLENBQUMsc0hBQW1DO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQywwSEFBcUM7QUFDMUQsYUFBYSxtQkFBTyxDQUFDLHdIQUFvQztBQUN6RCxhQUFhLG1CQUFPLENBQUMsc0hBQW1DO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyw0R0FBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLHdIQUFvQztBQUN6RCxhQUFhLG1CQUFPLENBQUMsNElBQThDO0FBQ25FOzs7Ozs7Ozs7O0FDMUJhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixrQkFBa0IsbUJBQU8sQ0FBQywrREFBUztBQUNuQywwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQW1CO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvWkFBb1o7QUFDN1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7Ozs7Ozs7OztBQ3JXYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2Isa0JBQWtCLG1CQUFPLENBQUMsK0RBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1cnVtLm9yZy8uL25vZGVfbW9kdWxlcy9hdXJ1bS1jYW52YXMvcHJlYnVpbHQvY2pzL2F1cnVtLWNhbnZhcy5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2NhbnZhcy5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2NvbXBvbmVudF9tb2RlbC5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2RyYXdhYmxlcy9hdXJ1bV9lbGlwc2UuanMiLCJ3ZWJwYWNrOi8vYXVydW0ub3JnLy4vbm9kZV9tb2R1bGVzL2F1cnVtLWNhbnZhcy9wcmVidWlsdC9janMvY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vYXVydW0ub3JnLy4vbm9kZV9tb2R1bGVzL2F1cnVtLWNhbnZhcy9wcmVidWlsdC9janMvY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1faW1hZ2UuanMiLCJ3ZWJwYWNrOi8vYXVydW0ub3JnLy4vbm9kZV9tb2R1bGVzL2F1cnVtLWNhbnZhcy9wcmVidWlsdC9janMvY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fbGluZS5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2RyYXdhYmxlcy9hdXJ1bV9wYXRoLmpzIiwid2VicGFjazovL2F1cnVtLm9yZy8uL25vZGVfbW9kdWxlcy9hdXJ1bS1jYW52YXMvcHJlYnVpbHQvY2pzL2NvbXBvbmVudHMvZHJhd2FibGVzL2F1cnVtX3JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2RyYXdhYmxlcy9hdXJ1bV9yZWd1bGFyX3BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vYXVydW0ub3JnLy4vbm9kZV9tb2R1bGVzL2F1cnVtLWNhbnZhcy9wcmVidWlsdC9janMvY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fdGV4dC5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2RyYXdhYmxlcy9zdGF0ZS5qcyIsIndlYnBhY2s6Ly9hdXJ1bS5vcmcvLi9ub2RlX21vZHVsZXMvYXVydW0tY2FudmFzL3ByZWJ1aWx0L2Nqcy9jb21wb25lbnRzL2ZlYXR1cmVzLmpzIiwid2VicGFjazovL2F1cnVtLm9yZy8uL25vZGVfbW9kdWxlcy9hdXJ1bS1jYW52YXMvcHJlYnVpbHQvY2pzL2NvbXBvbmVudHMvcmVuZGVyaW5nLmpzIiwid2VicGFjazovL2F1cnVtLm9yZy8uL25vZGVfbW9kdWxlcy9hdXJ1bS1jYW52YXMvcHJlYnVpbHQvY2pzL2NvbXBvbmVudHMvdXRpbGl0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9jYW52YXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZHJhd2FibGVzL2F1cnVtX3JlY3RhbmdsZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fdGV4dFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fbGluZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fZWxpcHNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21wb25lbnRzL2RyYXdhYmxlcy9hdXJ1bV9ncm91cFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9kcmF3YWJsZXMvYXVydW1fcGF0aFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9kcmF3YWJsZXMvc3RhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZHJhd2FibGVzL2F1cnVtX2ltYWdlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21wb25lbnRzL2RyYXdhYmxlcy9hdXJ1bV9yZWd1bGFyX3BvbHlnb25cIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVydW0tY2FudmFzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXJ1bUNhbnZhcyA9IHZvaWQgMDtcbmNvbnN0IGF1cnVtanNfMSA9IHJlcXVpcmUoXCJhdXJ1bWpzXCIpO1xuY29uc3QgY29tcG9uZW50X21vZGVsXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRfbW9kZWxcIik7XG5jb25zdCBzdGF0ZV8xID0gcmVxdWlyZShcIi4vZHJhd2FibGVzL3N0YXRlXCIpO1xuY29uc3QgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG5jb25zdCByZW5kZXJpbmdfMSA9IHJlcXVpcmUoXCIuL3JlbmRlcmluZ1wiKTtcbmNvbnN0IGZlYXR1cmVzXzEgPSByZXF1aXJlKFwiLi9mZWF0dXJlc1wiKTtcbmNvbnN0IHJlbmRlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIEF1cnVtQ2FudmFzKHByb3BzLCBjaGlsZHJlbiwgYXBpKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBsYyA9ICgwLCBhdXJ1bWpzXzEuY3JlYXRlTGlmZUN5Y2xlKSgpO1xuICAgIGFwaS5zeW5jaHJvbml6ZUxpZmVDeWNsZShsYyk7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFwaS5wcmVyZW5kZXIoY2hpbGRyZW4sIGxjKTtcbiAgICBsZXQgcGVuZGluZ1JlcmVuZGVyO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IGF1cnVtanNfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgIGxldCBvbk1vdXNlTW92ZSA9IG5ldyBhdXJ1bWpzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgbGV0IG9uTW91c2VVcCA9IG5ldyBhdXJ1bWpzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgbGV0IG9uTW91c2VEb3duID0gbmV3IGF1cnVtanNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICByZXR1cm4gKGF1cnVtanNfMS5BdXJ1bS5mYWN0b3J5KFwiY2FudmFzXCIsIHsgb25BdHRhY2g6IChjYW52YXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgaWYgKHByb3BzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5zY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zY2FsZSA9IG5ldyBhdXJ1bWpzXzEuRGF0YVNvdXJjZSh7IHg6IDEsIHk6IDEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcHJvcHMudHJhbnNsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRyYW5zbGF0ZSA9IG5ldyBhdXJ1bWpzXzEuRGF0YVNvdXJjZSh7IHg6IDAsIHk6IDAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5mZWF0dXJlcy5tb3VzZVdoZWVsWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgZmVhdHVyZXNfMS5pbml0aWFsaXplWm9vbUZlYXR1cmUpKHByb3BzLCBjYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gcHJvcHMuZmVhdHVyZXMucGFubmluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBmZWF0dXJlc18xLmluaXRpYWxpemVNb3VzZVBhbm5pbmdGZWF0dXJlKShwcm9wcywgY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IHByb3BzLmZlYXR1cmVzLnBhbm5pbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5rZXlib2FyZCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgZmVhdHVyZXNfMS5pbml0aWFsaXplS2V5Ym9hcmRQYW5uaW5nRmVhdHVyZSkocHJvcHMsIGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLndpZHRoIGluc3RhbmNlb2YgYXVydW1qc18xLkRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy53aWR0aC5saXN0ZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfSwgYXBpLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5iYWNrZ3JvdW5kQ29sb3IgaW5zdGFuY2VvZiBhdXJ1bWpzXzEuRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHByb3BzLmJhY2tncm91bmRDb2xvci5saXN0ZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfSwgYXBpLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5oZWlnaHQgaW5zdGFuY2VvZiBhdXJ1bWpzXzEuRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHByb3BzLmhlaWdodC5saXN0ZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfSwgYXBpLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRDYW52YXMoY2FudmFzLCBjb21wb25lbnRzLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICByZW5kZXIoY2FudmFzLCBjb21wb25lbnRzKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy50cmFuc2xhdGUpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy50cmFuc2xhdGUudHJhbnNmb3JtKCgwLCBhdXJ1bWpzXzEuZHNVbmlxdWUpKCksIGFwaS5jYW5jZWxsYXRpb25Ub2tlbikubGlzdGVuKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGUoY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5zY2FsZSkge1xuICAgICAgICAgICAgICAgIHByb3BzLnNjYWxlLnRyYW5zZm9ybSgoMCwgYXVydW1qc18xLmRzVW5pcXVlKSgpLCBhcGkuY2FuY2VsbGF0aW9uVG9rZW4pLmxpc3RlbigodikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2MgPSBwcm9wcy5vbkF0dGFjaCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwocHJvcHMsIGNhbnZhcyk7XG4gICAgICAgIH0sIG9uRGV0YWNoOiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWwoKTtcbiAgICAgICAgICAgIChfYSA9IHByb3BzLm9uRGV0YWNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9wcyk7XG4gICAgICAgIH0sIHN0eWxlOiBwcm9wcy5zdHlsZSwgY2xhc3M6IHByb3BzLmNsYXNzLCB3aWR0aDogdHlwZW9mIHByb3BzLndpZHRoICE9PSAnb2JqZWN0JyA/IChfYSA9IHByb3BzLndpZHRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSA6IHByb3BzLndpZHRoLnRyYW5zZm9ybSgoMCwgYXVydW1qc18xLmRzTWFwKSgodikgPT4gdi50b1N0cmluZygpKSksIGhlaWdodDogdHlwZW9mIHByb3BzLmhlaWdodCAhPT0gJ29iamVjdCcgPyAoX2IgPSBwcm9wcy5oZWlnaHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpIDogcHJvcHMuaGVpZ2h0LnRyYW5zZm9ybSgoMCwgYXVydW1qc18xLmRzTWFwKSgodikgPT4gdi50b1N0cmluZygpKSkgfSkpO1xuICAgIGZ1bmN0aW9uIGJpbmRDYW52YXMoY2FudmFzLCBjb21wb25lbnRzLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbi5yZWdpc3RlckRvbUV2ZW50KGNhbnZhcywgJ21vdXNlbGVhdmUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUuZmlyZShlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbmNlbGxhdGlvblRva2VuLnJlZ2lzdGVyRG9tRXZlbnQoY2FudmFzLCAnbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlLmZpcmUoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbi5yZWdpc3RlckRvbUV2ZW50KGNhbnZhcywgJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bi5maXJlKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4ucmVnaXN0ZXJEb21FdmVudChjYW52YXMsICdtb3VzZXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VVcC5maXJlKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmluZChjYW52YXMsIGNvbXBvbmVudHMsIHVuZGVmaW5lZCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc09uVG9wT2YoZSwgdGFyZ2V0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xO1xuICAgICAgICBpZiAoIXRhcmdldC5yZW5kZXJlZFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHggPSBlLm9mZnNldFggLSAoKChfYSA9IHByb3BzLnRyYW5zbGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlLngpID8gKChfYiA9IHByb3BzLnRyYW5zbGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZhbHVlLngpICogKChfZSA9IChfZCA9IChfYyA9IHByb3BzLnNjYWxlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmFsdWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC54KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAxKSA6IDApO1xuICAgICAgICBsZXQgeSA9IGUub2Zmc2V0WSAtICgoKF9mID0gcHJvcHMudHJhbnNsYXRlKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudmFsdWUueSkgPyAoKF9nID0gcHJvcHMudHJhbnNsYXRlKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudmFsdWUueSkgKiAoKF9rID0gKF9qID0gKF9oID0gcHJvcHMuc2NhbGUpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC52YWx1ZSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLngpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IDEpIDogMCk7XG4gICAgICAgIGlmIChwcm9wcy5zY2FsZSkge1xuICAgICAgICAgICAgeCAvPSBwcm9wcy5zY2FsZS52YWx1ZS54O1xuICAgICAgICAgICAgeSAvPSBwcm9wcy5zY2FsZS52YWx1ZS55O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQudHlwZSA9PT0gY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5URVhUKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSAoX2wgPSAoMCwgdXRpbGl0aWVzXzEuZGVyZWYpKGxhYmVsLmZvbnRTaXplKSkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogMTY7XG4gICAgICAgICAgICBpZiAoIWxhYmVsLnRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgICAgIHkgKz0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobGFiZWwudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0YXJnZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLklNQUdFOlxuICAgICAgICAgICAgY2FzZSBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLlJFQ1RBTkdMRTpcbiAgICAgICAgICAgIGNhc2UgY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5URVhUOlxuICAgICAgICAgICAgICAgIHJldHVybiAoeCA+PSB0YXJnZXQucmVuZGVyZWRTdGF0ZS54ICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPj0gdGFyZ2V0LnJlbmRlcmVkU3RhdGUueSAmJlxuICAgICAgICAgICAgICAgICAgICB4IDw9IHRhcmdldC5yZW5kZXJlZFN0YXRlLnggKyB0YXJnZXQucmVuZGVyZWRTdGF0ZS53aWR0aCAqICgoX28gPSAoX20gPSBwcm9wcy5zY2FsZSkgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLnZhbHVlLngpICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IDEpICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPD0gdGFyZ2V0LnJlbmRlcmVkU3RhdGUueSArIHRhcmdldC5yZW5kZXJlZFN0YXRlLmhlaWdodCAqICgoX3EgPSAoX3AgPSBwcm9wcy5zY2FsZSkgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wLnZhbHVlLnkpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IDEpKTtcbiAgICAgICAgICAgIGNhc2UgY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5FTElQU0U6XG4gICAgICAgICAgICBjYXNlIGNvbXBvbmVudF9tb2RlbF8xLkNvbXBvbmVudFR5cGUuUkVHVUxBUl9QT0xZR09OOlxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LnJlbmRlcmVkU3RhdGUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5pc1BvaW50SW5QYXRoKHRhcmdldC5yZW5kZXJlZFN0YXRlLnBhdGgsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQucmVuZGVyZWRTdGF0ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmlzUG9pbnRJblBhdGgodGFyZ2V0LnJlbmRlcmVkU3RhdGUucGF0aCwgeCAtIHRhcmdldC5yZW5kZXJlZFN0YXRlLngsIHkgLSB0YXJnZXQucmVuZGVyZWRTdGF0ZS55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYmluZChjYW52YXMsIGNoaWxkcmVuLCBwYXJlbnQsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGF1cnVtanNfMS5BcnJheURhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5saXN0ZW4oKCkgPT4gaW52YWxpZGF0ZShjYW52YXMpLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgY2hpbGQubGlzdGVuQW5kUmVwZWF0KChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2Uub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjaGFuZ2UuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5NYXAuc2V0KGl0ZW0sIG5ldyBhdXJ1bWpzXzEuQ2FuY2VsbGF0aW9uVG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmREeW5hbWljRW50aXR5KGl0ZW0sIGNoaWxkLCB0b2tlbk1hcC5nZXQoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNoYW5nZS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk1hcC5nZXQoaXRlbSkuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTWFwLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk1hcC5nZXQoY2hhbmdlLnRhcmdldCkuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5NYXAuZGVsZXRlKGNoYW5nZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTWFwLnNldChjaGFuZ2UuaXRlbXNbMF0sIG5ldyBhdXJ1bWpzXzEuQ2FuY2VsbGF0aW9uVG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZER5bmFtaWNFbnRpdHkoY2hhbmdlLml0ZW1zWzBdLCBjaGlsZCwgdG9rZW5NYXAuZ2V0KGNoYW5nZS5pdGVtc1swXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dhcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXJnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBhdXJ1bWpzXzEuRGF0YVNvdXJjZSB8fCBjaGlsZCBpbnN0YW5jZW9mIGF1cnVtanNfMS5EdXBsZXhEYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQubGlzdGVuKCgpID0+IGludmFsaWRhdGUoY2FudmFzKSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgICAgIGxldCBiaW5kVG9rZW47XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmxpc3RlbkFuZFJlcGVhdCgobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5kVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kVG9rZW4gPSBuZXcgYXVydW1qc18xLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kRHluYW1pY0VudGl0eSh2YWx1ZSwgY2hpbGQsIGJpbmRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZFtzdGF0ZV8xLnN0YXRlU3ltYm9sXSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSA8U3RhdGU+IG5vZGVzIGF0IHJvb3QgbGV2ZWwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50LmFuaW1hdGlvbnMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ29uTW91c2VFbnRlcicgaW4gY2hpbGQgfHwgJ29uTW91c2VMZWF2ZScgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZS5zdWJzY3JpYmUoKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT25Ub3BPZihlLCBjaGlsZCwgY2FudmFzLmdldENvbnRleHQoJzJkJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5zaWRlICYmIGNoaWxkLm9uTW91c2VFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm9uTW91c2VFbnRlcihlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0luc2lkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnNpZGUgJiYgY2hpbGQub25Nb3VzZUxlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQub25Nb3VzZUxlYXZlKGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdvbk1vdXNlVXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VVcC5zdWJzY3JpYmUoKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09uVG9wT2YoZSwgY2hpbGQsIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm9uTW91c2VVcChlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdvbk1vdXNlRG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZVVwLnN1YnNjcmliZSgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT25Ub3BPZihlLCBjaGlsZCwgY2FudmFzLmdldENvbnRleHQoJzJkJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQub25Nb3VzZVVwKGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29uTW91c2VDbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZVVwLnN1YnNjcmliZSgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT25Ub3BPZihlLCBjaGlsZCwgY2FudmFzLmdldENvbnRleHQoJzJkJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQub25Nb3VzZUNsaWNrKGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkW2tleV0gaW5zdGFuY2VvZiBhdXJ1bWpzXzEuRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjaGlsZFtrZXldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCB1dGlsaXRpZXNfMS5kZXJlZikoY2hpbGRba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmFuaW1hdGlvblN0YXRlcyA9IGNoaWxkLmFuaW1hdGlvbnMuZmlsdGVyKChlKSA9PiBlLmlkID09PSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5hbmltYXRpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZFtrZXldLmxpc3RlbigobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzdGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTdGF0ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuYW5pbWF0aW9uU3RhdGVzID0gY2hpbGQuYW5pbWF0aW9ucy5maWx0ZXIoKGUpID0+IGUuaWQgPT09IG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmFuaW1hdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZShjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZChjYW52YXMsIGNoaWxkLmNoaWxkcmVuLCBjaGlsZCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmREeW5hbWljRW50aXR5KHZhbHVlLCBwYXJlbnQsIGJpbmRUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgYXJyYXllZFZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgICBjb25zdCBsYyA9ICgwLCBhdXJ1bWpzXzEuY3JlYXRlTGlmZUN5Y2xlKSgpO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyUmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIGFycmF5ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVuZGVyQ2FjaGUuaGFzKHBpZWNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJDYWNoZS5zZXQocGllY2UsIGFwaS5wcmVyZW5kZXIocGllY2UsIGxjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbmRlclJlc3VsdC5wdXNoKHJlbmRlckNhY2hlLmdldChwaWVjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZChjYW52YXMsIHJlbmRlclJlc3VsdCwgcGFyZW50LCBiaW5kVG9rZW4pO1xuICAgICAgICAgICAgbGMub25BdHRhY2goKTtcbiAgICAgICAgICAgIGJpbmRUb2tlbi5hZGRDYW5jZWxhYmxlKCgpID0+IGxjLm9uRGV0YWNoKCkpO1xuICAgICAgICAgICAgaW52YWxpZGF0ZShjYW52YXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmFsaWRhdGUoY2FudmFzKSB7XG4gICAgICAgIGlmICghcGVuZGluZ1JlcmVuZGVyKSB7XG4gICAgICAgICAgICBwZW5kaW5nUmVyZW5kZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZXJlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihjYW52YXMsIGNvbXBvbmVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcihjYW52YXMsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAocHJvcHMuYmFja2dyb3VuZENvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICgwLCB1dGlsaXRpZXNfMS5kZXJlZikocHJvcHMuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseUNvbnRleHRUcmFuc2Zvcm1hdGlvbihjb250ZXh0KTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICByZW5kZXJDaGlsZChjb250ZXh0LCBjaGlsZCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5hcHBseUNvbnRleHRUcmFuc2Zvcm1hdGlvbihjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5hcHBseUNvbnRleHRUcmFuc2Zvcm1hdGlvbihjb250ZXh0KSB7XG4gICAgICAgIGlmIChwcm9wcy5zY2FsZSB8fCBwcm9wcy50cmFuc2xhdGUpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5Q29udGV4dFRyYW5zZm9ybWF0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHByb3BzLnNjYWxlIHx8IHByb3BzLnRyYW5zbGF0ZSkge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoKF9hID0gcHJvcHMuc2NhbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NhbGUocHJvcHMuc2NhbGUudmFsdWUueCwgcHJvcHMuc2NhbGUudmFsdWUueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKF9iID0gcHJvcHMudHJhbnNsYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwcm9wcy50cmFuc2xhdGUudmFsdWUueCwgcHJvcHMudHJhbnNsYXRlLnZhbHVlLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNoaWxkKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJDaGlsZChjb250ZXh0LCBpdGVtLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRbc3RhdGVfMS5zdGF0ZVN5bWJvbF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRbYXVydW1qc18xLmF1cnVtRWxlbWVudE1vZGVsSWRlbnRpdGl5XSkge1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJDYWNoZS5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIHN0YXRlOiB1bnJlbmRlcmVkIGF1cnVtIGVsZW1lbnQgbWFkZSBpdCBpbnRvIHRoZSBjYW52YXMgcmVuZGVyIHBoYXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IHJlbmRlckNhY2hlLmdldChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgYXVydW1qc18xLkFycmF5RGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGNoaWxkLmdldERhdGEoKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlckNoaWxkKGNvbnRleHQsIG5vZGUsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGF1cnVtanNfMS5EYXRhU291cmNlIHx8IGNoaWxkIGluc3RhbmNlb2YgYXVydW1qc18xLkR1cGxleERhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJlbmRlckNoaWxkKGNvbnRleHQsIGNoaWxkLnZhbHVlLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgbGV0IGlkbGU7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLlBBVEg6XG4gICAgICAgICAgICAgICAgaWRsZSA9ICgwLCByZW5kZXJpbmdfMS5yZW5kZXJQYXRoKShjb250ZXh0LCBjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbXBvbmVudF9tb2RlbF8xLkNvbXBvbmVudFR5cGUuUkVHVUxBUl9QT0xZR09OOlxuICAgICAgICAgICAgICAgIGlkbGUgPSAoMCwgcmVuZGVyaW5nXzEucmVuZGVyUmVndWxhclBvbHlnb24pKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5SRUNUQU5HTEU6XG4gICAgICAgICAgICAgICAgaWRsZSA9ICgwLCByZW5kZXJpbmdfMS5yZW5kZXJSZWN0YW5nbGUpKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5URVhUOlxuICAgICAgICAgICAgICAgIGlkbGUgPSAoMCwgcmVuZGVyaW5nXzEucmVuZGVyVGV4dCkoY29udGV4dCwgY2hpbGQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLkxJTkU6XG4gICAgICAgICAgICAgICAgaWRsZSA9ICgwLCByZW5kZXJpbmdfMS5yZW5kZXJMaW5lKShjb250ZXh0LCBjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbXBvbmVudF9tb2RlbF8xLkNvbXBvbmVudFR5cGUuUVVBRFJBVElDX0NVUlZFOlxuICAgICAgICAgICAgICAgIGlkbGUgPSAoMCwgcmVuZGVyaW5nXzEucmVuZGVyUXVhZHJhdGljQ3VydmUpKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5CRVpJRVJfQ1VSVkU6XG4gICAgICAgICAgICAgICAgaWRsZSA9ICgwLCByZW5kZXJpbmdfMS5yZW5kZXJCZXppZXJDdXJ2ZSkoY29udGV4dCwgY2hpbGQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLkVMSVBTRTpcbiAgICAgICAgICAgICAgICBpZGxlID0gKDAsIHJlbmRlcmluZ18xLnJlbmRlckVsaXBzZSkoY29udGV4dCwgY2hpbGQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLkdST1VQOlxuICAgICAgICAgICAgICAgIGlkbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaWRsZSkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZShjb250ZXh0LmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzdWJDaGlsZCBvZiBjaGlsZC5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmVuZGVyQ2hpbGQoY29udGV4dCwgc3ViQ2hpbGQsICgwLCB1dGlsaXRpZXNfMS5kZXJlZikoY2hpbGQueCkgKyBvZmZzZXRYLCAoMCwgdXRpbGl0aWVzXzEuZGVyZWYpKGNoaWxkLnkpICsgb2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5BdXJ1bUNhbnZhcyA9IEF1cnVtQ2FudmFzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FudmFzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wb25lbnRUeXBlID0gdm9pZCAwO1xudmFyIENvbXBvbmVudFR5cGU7XG4oZnVuY3Rpb24gKENvbXBvbmVudFR5cGUpIHtcbiAgICBDb21wb25lbnRUeXBlW0NvbXBvbmVudFR5cGVbXCJSRUNUQU5HTEVcIl0gPSAwXSA9IFwiUkVDVEFOR0xFXCI7XG4gICAgQ29tcG9uZW50VHlwZVtDb21wb25lbnRUeXBlW1wiRUxJUFNFXCJdID0gMV0gPSBcIkVMSVBTRVwiO1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIkxJTkVcIl0gPSAyXSA9IFwiTElORVwiO1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIlRFWFRcIl0gPSAzXSA9IFwiVEVYVFwiO1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIklNQUdFXCJdID0gNF0gPSBcIklNQUdFXCI7XG4gICAgQ29tcG9uZW50VHlwZVtDb21wb25lbnRUeXBlW1wiR1JPVVBcIl0gPSA1XSA9IFwiR1JPVVBcIjtcbiAgICBDb21wb25lbnRUeXBlW0NvbXBvbmVudFR5cGVbXCJTVEFURVwiXSA9IDZdID0gXCJTVEFURVwiO1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIlBBVEhcIl0gPSA3XSA9IFwiUEFUSFwiO1xuICAgIENvbXBvbmVudFR5cGVbQ29tcG9uZW50VHlwZVtcIlFVQURSQVRJQ19DVVJWRVwiXSA9IDhdID0gXCJRVUFEUkFUSUNfQ1VSVkVcIjtcbiAgICBDb21wb25lbnRUeXBlW0NvbXBvbmVudFR5cGVbXCJCRVpJRVJfQ1VSVkVcIl0gPSA5XSA9IFwiQkVaSUVSX0NVUlZFXCI7XG4gICAgQ29tcG9uZW50VHlwZVtDb21wb25lbnRUeXBlW1wiUkVHVUxBUl9QT0xZR09OXCJdID0gMTBdID0gXCJSRUdVTEFSX1BPTFlHT05cIjtcbn0pKENvbXBvbmVudFR5cGUgPSBleHBvcnRzLkNvbXBvbmVudFR5cGUgfHwgKGV4cG9ydHMuQ29tcG9uZW50VHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnRfbW9kZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF1cnVtRWxpcHNlID0gdm9pZCAwO1xuY29uc3QgYXVydW1qc18xID0gcmVxdWlyZShcImF1cnVtanNcIik7XG5jb25zdCBjb21wb25lbnRfbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRfbW9kZWxcIik7XG5mdW5jdGlvbiBBdXJ1bUVsaXBzZShwcm9wcywgY2hpbGRyZW4sIGFwaSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsYyA9ICgwLCBhdXJ1bWpzXzEuY3JlYXRlTGlmZUN5Y2xlKSgpO1xuICAgIGFwaS5zeW5jaHJvbml6ZUxpZmVDeWNsZShsYyk7XG4gICAgaWYgKHByb3BzLm9uQXR0YWNoKSB7XG4gICAgICAgIGFwaS5vbkF0dGFjaCgoKSA9PiBwcm9wcy5vbkF0dGFjaCgpKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uRGV0YWNoKSB7XG4gICAgICAgIGFwaS5vbkRldGFjaCgoKSA9PiBwcm9wcy5vbkRldGFjaCgpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFwaS5wcmVyZW5kZXIoY2hpbGRyZW4sIGxjKS5maWx0ZXIoKGMpID0+ICEhYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG9wYWNpdHk6IChfYSA9IHByb3BzLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEsXG4gICAgICAgIHJlbmRlcmVkU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46IGNvbXBvbmVudHMsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICB0eXBlOiBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLkVMSVBTRVxuICAgIH07XG59XG5leHBvcnRzLkF1cnVtRWxpcHNlID0gQXVydW1FbGlwc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJ1bV9lbGlwc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF1cnVtR3JvdXAgPSB2b2lkIDA7XG5jb25zdCBhdXJ1bWpzXzEgPSByZXF1aXJlKFwiYXVydW1qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9tb2RlbF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudF9tb2RlbFwiKTtcbmZ1bmN0aW9uIEF1cnVtR3JvdXAocHJvcHMsIGNoaWxkcmVuLCBhcGkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxjID0gKDAsIGF1cnVtanNfMS5jcmVhdGVMaWZlQ3ljbGUpKCk7XG4gICAgYXBpLnN5bmNocm9uaXplTGlmZUN5Y2xlKGxjKTtcbiAgICBpZiAocHJvcHMub25BdHRhY2gpIHtcbiAgICAgICAgYXBpLm9uQXR0YWNoKCgpID0+IHByb3BzLm9uQXR0YWNoKCkpO1xuICAgIH1cbiAgICBpZiAocHJvcHMub25EZXRhY2gpIHtcbiAgICAgICAgYXBpLm9uRGV0YWNoKCgpID0+IHByb3BzLm9uRGV0YWNoKCkpO1xuICAgIH1cbiAgICAoX2EgPSBwcm9wcy54KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocHJvcHMueCA9IDApO1xuICAgIChfYiA9IHByb3BzLnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChwcm9wcy55ID0gMCk7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFwaS5wcmVyZW5kZXIoY2hpbGRyZW4sIGxjKS5maWx0ZXIoKGMpID0+ICEhYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHJlbmRlcmVkU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46IGNvbXBvbmVudHMsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICB0eXBlOiBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLkdST1VQXG4gICAgfTtcbn1cbmV4cG9ydHMuQXVydW1Hcm91cCA9IEF1cnVtR3JvdXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJ1bV9ncm91cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXVydW1JbWFnZSA9IHZvaWQgMDtcbmNvbnN0IGF1cnVtanNfMSA9IHJlcXVpcmUoXCJhdXJ1bWpzXCIpO1xuY29uc3QgY29tcG9uZW50X21vZGVsXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50X21vZGVsXCIpO1xuZnVuY3Rpb24gQXVydW1JbWFnZShwcm9wcywgY2hpbGRyZW4sIGFwaSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsYyA9ICgwLCBhdXJ1bWpzXzEuY3JlYXRlTGlmZUN5Y2xlKSgpO1xuICAgIGFwaS5zeW5jaHJvbml6ZUxpZmVDeWNsZShsYyk7XG4gICAgaWYgKHByb3BzLm9uQXR0YWNoKSB7XG4gICAgICAgIGFwaS5vbkF0dGFjaCgoKSA9PiBwcm9wcy5vbkF0dGFjaCgpKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uRGV0YWNoKSB7XG4gICAgICAgIGFwaS5vbkRldGFjaCgoKSA9PiBwcm9wcy5vbkRldGFjaCgpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFwaS5wcmVyZW5kZXIoY2hpbGRyZW4sIGxjKS5maWx0ZXIoKGMpID0+ICEhYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG9wYWNpdHk6IChfYSA9IHByb3BzLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEsXG4gICAgICAgIHJlbmRlcmVkU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46IGNvbXBvbmVudHMsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICB0eXBlOiBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLklNQUdFXG4gICAgfTtcbn1cbmV4cG9ydHMuQXVydW1JbWFnZSA9IEF1cnVtSW1hZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJ1bV9pbWFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXVydW1MaW5lID0gdm9pZCAwO1xuY29uc3QgYXVydW1qc18xID0gcmVxdWlyZShcImF1cnVtanNcIik7XG5jb25zdCBjb21wb25lbnRfbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRfbW9kZWxcIik7XG5mdW5jdGlvbiBBdXJ1bUxpbmUocHJvcHMsIGNoaWxkcmVuLCBhcGkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxjID0gKDAsIGF1cnVtanNfMS5jcmVhdGVMaWZlQ3ljbGUpKCk7XG4gICAgYXBpLnN5bmNocm9uaXplTGlmZUN5Y2xlKGxjKTtcbiAgICBpZiAocHJvcHMub25BdHRhY2gpIHtcbiAgICAgICAgYXBpLm9uQXR0YWNoKCgpID0+IHByb3BzLm9uQXR0YWNoKCkpO1xuICAgIH1cbiAgICBpZiAocHJvcHMub25EZXRhY2gpIHtcbiAgICAgICAgYXBpLm9uRGV0YWNoKCgpID0+IHByb3BzLm9uRGV0YWNoKCkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnRzID0gYXBpLnByZXJlbmRlcihjaGlsZHJlbiwgbGMpLmZpbHRlcigoYykgPT4gISFjKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgb3BhY2l0eTogKF9hID0gcHJvcHMub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSxcbiAgICAgICAgbGluZVdpZHRoOiAoX2IgPSBwcm9wcy5saW5lV2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEsXG4gICAgICAgIHJlbmRlcmVkU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46IGNvbXBvbmVudHMsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICB0eXBlOiBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLkxJTkVcbiAgICB9O1xufVxuZXhwb3J0cy5BdXJ1bUxpbmUgPSBBdXJ1bUxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJ1bV9saW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXJ1bVBhdGggPSB2b2lkIDA7XG5jb25zdCBhdXJ1bWpzXzEgPSByZXF1aXJlKFwiYXVydW1qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9tb2RlbF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudF9tb2RlbFwiKTtcbmZ1bmN0aW9uIEF1cnVtUGF0aChwcm9wcywgY2hpbGRyZW4sIGFwaSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsYyA9ICgwLCBhdXJ1bWpzXzEuY3JlYXRlTGlmZUN5Y2xlKSgpO1xuICAgIGFwaS5zeW5jaHJvbml6ZUxpZmVDeWNsZShsYyk7XG4gICAgaWYgKHByb3BzLm9uQXR0YWNoKSB7XG4gICAgICAgIGFwaS5vbkF0dGFjaCgoKSA9PiBwcm9wcy5vbkF0dGFjaCgpKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uRGV0YWNoKSB7XG4gICAgICAgIGFwaS5vbkRldGFjaCgoKSA9PiBwcm9wcy5vbkRldGFjaCgpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFwaS5wcmVyZW5kZXIoY2hpbGRyZW4sIGxjKS5maWx0ZXIoKGMpID0+ICEhYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG9wYWNpdHk6IChfYSA9IHByb3BzLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEsXG4gICAgICAgIHJlbmRlcmVkU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46IGNvbXBvbmVudHMsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICB0eXBlOiBjb21wb25lbnRfbW9kZWxfMS5Db21wb25lbnRUeXBlLlBBVEhcbiAgICB9O1xufVxuZXhwb3J0cy5BdXJ1bVBhdGggPSBBdXJ1bVBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJ1bV9wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXJ1bVJlY3RhbmdsZSA9IHZvaWQgMDtcbmNvbnN0IGF1cnVtanNfMSA9IHJlcXVpcmUoXCJhdXJ1bWpzXCIpO1xuY29uc3QgY29tcG9uZW50X21vZGVsXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50X21vZGVsXCIpO1xuZnVuY3Rpb24gQXVydW1SZWN0YW5nbGUocHJvcHMsIGNoaWxkcmVuLCBhcGkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbGMgPSAoMCwgYXVydW1qc18xLmNyZWF0ZUxpZmVDeWNsZSkoKTtcbiAgICBhcGkuc3luY2hyb25pemVMaWZlQ3ljbGUobGMpO1xuICAgIGlmIChwcm9wcy5vbkF0dGFjaCkge1xuICAgICAgICBhcGkub25BdHRhY2goKCkgPT4gcHJvcHMub25BdHRhY2goKSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5vbkRldGFjaCkge1xuICAgICAgICBhcGkub25EZXRhY2goKCkgPT4gcHJvcHMub25EZXRhY2goKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBhcGkucHJlcmVuZGVyKGNoaWxkcmVuLCBsYykuZmlsdGVyKChjKSA9PiAhIWMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBvcGFjaXR5OiAoX2EgPSBwcm9wcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgICAgICByZW5kZXJlZFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgIGNoaWxkcmVuOiBjb21wb25lbnRzLFxuICAgICAgICBhbmltYXRpb25zOiBbXSxcbiAgICAgICAgdHlwZTogY29tcG9uZW50X21vZGVsXzEuQ29tcG9uZW50VHlwZS5SRUNUQU5HTEVcbiAgICB9O1xufVxuZXhwb3J0cy5BdXJ1bVJlY3RhbmdsZSA9IEF1cnVtUmVjdGFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVydW1fcmVjdGFuZ2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXJ1bVJlZ3VsYXJQb2x5Z29uID0gdm9pZCAwO1xuY29uc3QgYXVydW1qc18xID0gcmVxdWlyZShcImF1cnVtanNcIik7XG5jb25zdCBjb21wb25lbnRfbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRfbW9kZWxcIik7XG5mdW5jdGlvbiBBdXJ1bVJlZ3VsYXJQb2x5Z29uKHByb3BzLCBjaGlsZHJlbiwgYXBpKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxjID0gKDAsIGF1cnVtanNfMS5jcmVhdGVMaWZlQ3ljbGUpKCk7XG4gICAgYXBpLnN5bmNocm9uaXplTGlmZUN5Y2xlKGxjKTtcbiAgICBpZiAocHJvcHMub25BdHRhY2gpIHtcbiAgICAgICAgYXBpLm9uQXR0YWNoKCgpID0+IHByb3BzLm9uQXR0YWNoKCkpO1xuICAgIH1cbiAgICBpZiAocHJvcHMub25EZXRhY2gpIHtcbiAgICAgICAgYXBpLm9uRGV0YWNoKCgpID0+IHByb3BzLm9uRGV0YWNoKCkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnRzID0gYXBpLnByZXJlbmRlcihjaGlsZHJlbiwgbGMpLmZpbHRlcigoYykgPT4gISFjKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgb3BhY2l0eTogKF9hID0gcHJvcHMub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSxcbiAgICAgICAgcmVuZGVyZWRTdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBjaGlsZHJlbjogY29tcG9uZW50cyxcbiAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgIHR5cGU6IGNvbXBvbmVudF9tb2RlbF8xLkNvbXBvbmVudFR5cGUuUkVHVUxBUl9QT0xZR09OXG4gICAgfTtcbn1cbmV4cG9ydHMuQXVydW1SZWd1bGFyUG9seWdvbiA9IEF1cnVtUmVndWxhclBvbHlnb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXJ1bV9yZWd1bGFyX3BvbHlnb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF1cnVtVGV4dCA9IHZvaWQgMDtcbmNvbnN0IGF1cnVtanNfMSA9IHJlcXVpcmUoXCJhdXJ1bWpzXCIpO1xuY29uc3QgY29tcG9uZW50X21vZGVsXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50X21vZGVsXCIpO1xuZnVuY3Rpb24gQXVydW1UZXh0KHByb3BzLCBjaGlsZHJlbiwgYXBpKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxjID0gKDAsIGF1cnVtanNfMS5jcmVhdGVMaWZlQ3ljbGUpKCk7XG4gICAgYXBpLnN5bmNocm9uaXplTGlmZUN5Y2xlKGxjKTtcbiAgICBpZiAocHJvcHMub25BdHRhY2gpIHtcbiAgICAgICAgYXBpLm9uQXR0YWNoKCgpID0+IHByb3BzLm9uQXR0YWNoKCkpO1xuICAgIH1cbiAgICBpZiAocHJvcHMub25EZXRhY2gpIHtcbiAgICAgICAgYXBpLm9uRGV0YWNoKCgpID0+IHByb3BzLm9uRGV0YWNoKCkpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gYXBpLnByZXJlbmRlcihjaGlsZHJlbiwgbGMpLmZpbHRlcigoYykgPT4gISFjKTtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IGF1cnVtanNfMS5EYXRhU291cmNlKCcnKTtcbiAgICBpZiAocHJvcHMuZm9udCBpbnN0YW5jZW9mIGF1cnVtanNfMS5EYXRhU291cmNlKSB7XG4gICAgICAgIHByb3BzLmZvbnQubGlzdGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVuZGVyZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlZFN0YXRlLmxpbmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFwaS5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mb250V2VpZ2h0IGluc3RhbmNlb2YgYXVydW1qc18xLkRhdGFTb3VyY2UpIHtcbiAgICAgICAgcHJvcHMuZm9udFdlaWdodC5saXN0ZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW5kZXJlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVkU3RhdGUubGluZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYXBpLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZvbnRTaXplIGluc3RhbmNlb2YgYXVydW1qc18xLkRhdGFTb3VyY2UpIHtcbiAgICAgICAgcHJvcHMuZm9udFNpemUubGlzdGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVuZGVyZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlZFN0YXRlLmxpbmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFwaS5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGlmIChwcm9wcy53aWR0aCBpbnN0YW5jZW9mIGF1cnVtanNfMS5EYXRhU291cmNlKSB7XG4gICAgICAgIHByb3BzLndpZHRoLmxpc3RlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbmRlcmVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZWRTdGF0ZS5saW5lcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhcGkuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBpZiAocHJvcHMud3JhcFdpZHRoIGluc3RhbmNlb2YgYXVydW1qc18xLkRhdGFTb3VyY2UpIHtcbiAgICAgICAgcHJvcHMud3JhcFdpZHRoLmxpc3RlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbmRlcmVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZWRTdGF0ZS5saW5lcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhcGkuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgY29udGVudCkge1xuICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIGF1cnVtanNfMS5EYXRhU291cmNlKSB7XG4gICAgICAgICAgICBpLnRyYW5zZm9ybSgoMCwgYXVydW1qc18xLmRzVW5pcXVlKSgpLCBhcGkuY2FuY2VsbGF0aW9uVG9rZW4pLmxpc3RlbigodikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVuZGVyZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZWRTdGF0ZS5saW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVUZXh0KHRleHQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVGV4dCh0ZXh0LCBjb250ZW50KTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBvcGFjaXR5OiAoX2EgPSBwcm9wcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgICAgICByZW5kZXJlZFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHRleHQsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgIHR5cGU6IGNvbXBvbmVudF9tb2RlbF8xLkNvbXBvbmVudFR5cGUuVEVYVFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuQXVydW1UZXh0ID0gQXVydW1UZXh0O1xuZnVuY3Rpb24gdXBkYXRlVGV4dCh0ZXh0LCBjb250ZW50KSB7XG4gICAgdGV4dC51cGRhdGUoY29udGVudC5yZWR1Y2UoKHAsIGMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGAke3B9JHtjfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtwfSR7Yy52YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAnJykpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVydW1fdGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdGUgPSBleHBvcnRzLnN0YXRlU3ltYm9sID0gdm9pZCAwO1xuY29uc3QgYXVydW1qc18xID0gcmVxdWlyZShcImF1cnVtanNcIik7XG5jb25zdCBjb21wb25lbnRfbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRfbW9kZWxcIik7XG5leHBvcnRzLnN0YXRlU3ltYm9sID0gU3ltYm9sKCdzdGF0ZScpO1xuZnVuY3Rpb24gU3RhdGUocHJvcHMsIGNoaWxkcmVuLCBhcGkpIHtcbiAgICBjb25zdCBsYyA9ICgwLCBhdXJ1bWpzXzEuY3JlYXRlTGlmZUN5Y2xlKSgpO1xuICAgIGFwaS5zeW5jaHJvbml6ZUxpZmVDeWNsZShsYyk7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFwaS5wcmVyZW5kZXIoY2hpbGRyZW4sIGxjKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbZXhwb3J0cy5zdGF0ZVN5bWJvbF06IHRydWUsXG4gICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcmVuZGVyZWRTdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBhbmltYXRpb25zOiBbXSxcbiAgICAgICAgY2hpbGRyZW46IGNvbXBvbmVudHMsXG4gICAgICAgIHR5cGU6IGNvbXBvbmVudF9tb2RlbF8xLkNvbXBvbmVudFR5cGUuU1RBVEVcbiAgICB9O1xufVxuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluaXRpYWxpemVab29tRmVhdHVyZSA9IGV4cG9ydHMuaW5pdGlhbGl6ZU1vdXNlUGFubmluZ0ZlYXR1cmUgPSBleHBvcnRzLmluaXRpYWxpemVLZXlib2FyZFBhbm5pbmdGZWF0dXJlID0gdm9pZCAwO1xuY29uc3QgYXVydW1qc18xID0gcmVxdWlyZShcImF1cnVtanNcIik7XG5mdW5jdGlvbiBpbml0aWFsaXplS2V5Ym9hcmRQYW5uaW5nRmVhdHVyZShwcm9wcywgY2FudmFzKSB7XG4gICAgbGV0IG1vdmVUb2tlbjtcbiAgICBjb25zdCBrZXlEb3duID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1vdmVWZWN0b3IgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IHByb3BzLmZlYXR1cmVzLnBhbm5pbmcua2V5Ym9hcmQubGVmdEtleUNvZGUgfHwgZS5rZXlDb2RlID09PSBwcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLnJpZ2h0S2V5Q29kZSkge1xuICAgICAgICAgICAgbW92ZVZlY3Rvci54ID0gMDtcbiAgICAgICAgICAgIGtleURvd24uZGVsZXRlKGUua2V5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gcHJvcHMuZmVhdHVyZXMucGFubmluZy5rZXlib2FyZC51cEtleUNvZGUgfHwgZS5rZXlDb2RlID09PSBwcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLmRvd25LZXlDb2RlKSB7XG4gICAgICAgICAgICBtb3ZlVmVjdG9yLnkgPSAwO1xuICAgICAgICAgICAga2V5RG93bi5kZWxldGUoZS5rZXlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZVRva2VuICYmIGtleURvd24uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgbW92ZVRva2VuLmNhbmNlbCgpO1xuICAgICAgICAgICAgbW92ZVRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBwcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLmxlZnRLZXlDb2RlKSB7XG4gICAgICAgICAgICBtb3ZlVmVjdG9yLnggPSBwcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLnBpeGVsc1BlckZyYW1lO1xuICAgICAgICAgICAga2V5RG93bi5hZGQoZS5rZXlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBwcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLmRvd25LZXlDb2RlKSB7XG4gICAgICAgICAgICBtb3ZlVmVjdG9yLnkgPSAtcHJvcHMuZmVhdHVyZXMucGFubmluZy5rZXlib2FyZC5waXhlbHNQZXJGcmFtZTtcbiAgICAgICAgICAgIGtleURvd24uYWRkKGUua2V5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gcHJvcHMuZmVhdHVyZXMucGFubmluZy5rZXlib2FyZC5yaWdodEtleUNvZGUpIHtcbiAgICAgICAgICAgIG1vdmVWZWN0b3IueCA9IC1wcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLnBpeGVsc1BlckZyYW1lO1xuICAgICAgICAgICAga2V5RG93bi5hZGQoZS5rZXlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBwcm9wcy5mZWF0dXJlcy5wYW5uaW5nLmtleWJvYXJkLnVwS2V5Q29kZSkge1xuICAgICAgICAgICAgbW92ZVZlY3Rvci55ID0gcHJvcHMuZmVhdHVyZXMucGFubmluZy5rZXlib2FyZC5waXhlbHNQZXJGcmFtZTtcbiAgICAgICAgICAgIGtleURvd24uYWRkKGUua2V5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb3ZlVG9rZW4gJiYga2V5RG93bi5zaXplID4gMCkge1xuICAgICAgICAgICAgbW92ZVRva2VuID0gbmV3IGF1cnVtanNfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICAgICAgbW92ZVRva2VuLmFuaW1hdGlvbkxvb3AoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb3BzLnRyYW5zbGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICB4OiBwcm9wcy50cmFuc2xhdGUudmFsdWUueCArIG1vdmVWZWN0b3IueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcHJvcHMudHJhbnNsYXRlLnZhbHVlLnkgKyBtb3ZlVmVjdG9yLnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmluaXRpYWxpemVLZXlib2FyZFBhbm5pbmdGZWF0dXJlID0gaW5pdGlhbGl6ZUtleWJvYXJkUGFubmluZ0ZlYXR1cmU7XG5mdW5jdGlvbiBpbml0aWFsaXplTW91c2VQYW5uaW5nRmVhdHVyZShwcm9wcywgY2FudmFzKSB7XG4gICAgbGV0IGRvd25YO1xuICAgIGxldCBkb3duWTtcbiAgICBsZXQgYmVmb3JlWDtcbiAgICBsZXQgYmVmb3JlWTtcbiAgICBsZXQgZG93biA9IGZhbHNlO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgICAgICBkb3duWCA9IGUuY2xpZW50WDtcbiAgICAgICAgZG93blkgPSBlLmNsaWVudFk7XG4gICAgICAgIGJlZm9yZVggPSBwcm9wcy50cmFuc2xhdGUudmFsdWUueDtcbiAgICAgICAgYmVmb3JlWSA9IHByb3BzLnRyYW5zbGF0ZS52YWx1ZS55O1xuICAgICAgICBkb3duID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgcHJvcHMudHJhbnNsYXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgeDogYmVmb3JlWCAtIChkb3duWCAtIGUuY2xpZW50WCkgLyBwcm9wcy5zY2FsZS52YWx1ZS54LFxuICAgICAgICAgICAgICAgIHk6IGJlZm9yZVkgLSAoZG93blkgLSBlLmNsaWVudFkpIC8gcHJvcHMuc2NhbGUudmFsdWUueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGUpID0+IHtcbiAgICAgICAgZG93biA9IGZhbHNlO1xuICAgIH0pO1xufVxuZXhwb3J0cy5pbml0aWFsaXplTW91c2VQYW5uaW5nRmVhdHVyZSA9IGluaXRpYWxpemVNb3VzZVBhbm5pbmdGZWF0dXJlO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVpvb21GZWF0dXJlKHByb3BzLCBjYW52YXMpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5kZWx0YVkgPiAwKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuc2NhbGUudmFsdWUueCA8IHByb3BzLmZlYXR1cmVzLm1vdXNlV2hlZWxab29tLm1pblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy50cmFuc2xhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB4OiBwcm9wcy50cmFuc2xhdGUudmFsdWUueCArIChlLm9mZnNldFggKiAocHJvcHMuZmVhdHVyZXMubW91c2VXaGVlbFpvb20uem9vbUluY3JlbWVudHMgLSAxKSkgLyBwcm9wcy5zY2FsZS52YWx1ZS54LFxuICAgICAgICAgICAgICAgIHk6IHByb3BzLnRyYW5zbGF0ZS52YWx1ZS55ICsgKGUub2Zmc2V0WSAqIChwcm9wcy5mZWF0dXJlcy5tb3VzZVdoZWVsWm9vbS56b29tSW5jcmVtZW50cyAtIDEpKSAvIHByb3BzLnNjYWxlLnZhbHVlLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvcHMuc2NhbGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB4OiBwcm9wcy5zY2FsZS52YWx1ZS54IC8gcHJvcHMuZmVhdHVyZXMubW91c2VXaGVlbFpvb20uem9vbUluY3JlbWVudHMsXG4gICAgICAgICAgICAgICAgeTogcHJvcHMuc2NhbGUudmFsdWUueSAvIHByb3BzLmZlYXR1cmVzLm1vdXNlV2hlZWxab29tLnpvb21JbmNyZW1lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5zY2FsZS52YWx1ZS54ID4gcHJvcHMuZmVhdHVyZXMubW91c2VXaGVlbFpvb20ubWF4Wm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLnNjYWxlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgeDogcHJvcHMuc2NhbGUudmFsdWUueCAqIHByb3BzLmZlYXR1cmVzLm1vdXNlV2hlZWxab29tLnpvb21JbmNyZW1lbnRzLFxuICAgICAgICAgICAgICAgIHk6IHByb3BzLnNjYWxlLnZhbHVlLnkgKiBwcm9wcy5mZWF0dXJlcy5tb3VzZVdoZWVsWm9vbS56b29tSW5jcmVtZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9wcy50cmFuc2xhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB4OiBwcm9wcy50cmFuc2xhdGUudmFsdWUueCAtIChlLm9mZnNldFggKiAocHJvcHMuZmVhdHVyZXMubW91c2VXaGVlbFpvb20uem9vbUluY3JlbWVudHMgLSAxKSkgLyBwcm9wcy5zY2FsZS52YWx1ZS54LFxuICAgICAgICAgICAgICAgIHk6IHByb3BzLnRyYW5zbGF0ZS52YWx1ZS55IC0gKGUub2Zmc2V0WSAqIChwcm9wcy5mZWF0dXJlcy5tb3VzZVdoZWVsWm9vbS56b29tSW5jcmVtZW50cyAtIDEpKSAvIHByb3BzLnNjYWxlLnZhbHVlLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmluaXRpYWxpemVab29tRmVhdHVyZSA9IGluaXRpYWxpemVab29tRmVhdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlYXR1cmVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlVmFsdWVzID0gZXhwb3J0cy5yZW5kZXJSZWN0YW5nbGUgPSBleHBvcnRzLnJlbmRlclRleHQgPSBleHBvcnRzLnJlbmRlclJlZ3VsYXJQb2x5Z29uID0gZXhwb3J0cy5yZW5kZXJQYXRoID0gZXhwb3J0cy5yZW5kZXJCZXppZXJDdXJ2ZSA9IGV4cG9ydHMucmVuZGVyUXVhZHJhdGljQ3VydmUgPSBleHBvcnRzLnJlbmRlckxpbmUgPSBleHBvcnRzLnJlbmRlckVsaXBzZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxpdGllc18xID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzXCIpO1xuY29uc3QgcmVndWxhclBvbHlnb25LZXlzID0gWyd4JywgJ3knLCAnb3BhY2l0eScsICdzdHJva2VDb2xvcicsICdmaWxsQ29sb3InLCAncGF0aCcsICdzaWRlcycsICdyYWRpdXMnLCAnb3JpZ2luWCcsICdvcmlnaW5ZJ107XG5jb25zdCBwYXRoS2V5cyA9IFsneCcsICd5JywgJ29wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnZmlsbENvbG9yJywgJ3BhdGgnLCAnbGluZVdpZHRoJywgJ29yaWdpblgnLCAnb3JpZ2luWSddO1xuY29uc3QgZWxpcHNlS2V5cyA9IFsneCcsICd5JywgJ29wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnZmlsbENvbG9yJywgJ3JvdGF0aW9uJywgJ3J4JywgJ3J5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnb3JpZ2luWCcsICdvcmlnaW5ZJ107XG5jb25zdCBsaW5lS2V5cyA9IFsneCcsICd5JywgJ29wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnZmlsbENvbG9yJywgJ3R4JywgJ3R5JywgJ2xpbmVXaWR0aCcsICdvcmlnaW5YJywgJ29yaWdpblknXTtcbmNvbnN0IHF1YWRyYXRpY0N1cnZlS2V5cyA9IFsneCcsICd5JywgJ29wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnZmlsbENvbG9yJywgJ3R4JywgJ3R5JywgJ2N4JywgJ2N5JywgJ2xpbmVXaWR0aCcsICdvcmlnaW5YJywgJ29yaWdpblknXTtcbmNvbnN0IGJlemllckN1cnZlS2V5cyA9IFsneCcsICd5JywgJ29wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnZmlsbENvbG9yJywgJ3R4JywgJ3R5JywgJ2N4JywgJ2N5JywgJ2MyeCcsICdjMnknLCAnbGluZVdpZHRoJywgJ29yaWdpblgnLCAnb3JpZ2luWSddO1xuY29uc3QgdGV4dEtleXMgPSBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAncmVhbFdpZHRoJyxcbiAgICAnd2lkdGgnLFxuICAgICdmb250JyxcbiAgICAnZm9udFNpemUnLFxuICAgICdvcGFjaXR5JyxcbiAgICAnc3Ryb2tlQ29sb3InLFxuICAgICdmaWxsQ29sb3InLFxuICAgICd0ZXh0JyxcbiAgICAnZm9udFdlaWdodCcsXG4gICAgJ3dyYXBXaWR0aCcsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICd0ZXh0QmFzZWxpbmUnLFxuICAgICdvcmlnaW5YJyxcbiAgICAnb3JpZ2luWSdcbl07XG5jb25zdCByZWN0YW5nbGVLZXlzID0gWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ29wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnZmlsbENvbG9yJywgJ29yaWdpblgnLCAnb3JpZ2luWSddO1xuZnVuY3Rpb24gcmVuZGVyRWxpcHNlKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlbmRlcmVkU3RhdGUgPSByZXNvbHZlVmFsdWVzKGNoaWxkLCBlbGlwc2VLZXlzLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICBjb25zdCB7IHgsIHksIGlkbGUsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IsIG9wYWNpdHksIHJ4LCByeSwgcm90YXRpb24sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSByZW5kZXJlZFN0YXRlO1xuICAgIGNoaWxkLnJlbmRlcmVkU3RhdGUgPSByZW5kZXJlZFN0YXRlO1xuICAgIChfYSA9IGNoaWxkLm9uUHJlRHJhdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY2hpbGQsIGNoaWxkLnJlbmRlcmVkU3RhdGUpO1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGNvbnN0IHBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAoKGZpbGxDb2xvciB8fCBzdHJva2VDb2xvcikgJiYgcnggPiAwLjAxICYmIHJ5ID4gMC4wMSAmJiAoc3RhcnRBbmdsZSAhPT0gbnVsbCAmJiBzdGFydEFuZ2xlICE9PSB2b2lkIDAgPyBzdGFydEFuZ2xlIDogMCAhPT0gZW5kQW5nbGUpKSB7XG4gICAgICAgIHBhdGgyZC5lbGxpcHNlKHgsIHksIHJ4LCByeSwgcm90YXRpb24gIT09IG51bGwgJiYgcm90YXRpb24gIT09IHZvaWQgMCA/IHJvdGF0aW9uIDogMCwgc3RhcnRBbmdsZSAhPT0gbnVsbCAmJiBzdGFydEFuZ2xlICE9PSB2b2lkIDAgPyBzdGFydEFuZ2xlIDogMCwgZW5kQW5nbGUgIT09IG51bGwgJiYgZW5kQW5nbGUgIT09IHZvaWQgMCA/IGVuZEFuZ2xlIDogTWF0aC5QSSAqIDIpO1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSBwYXRoMmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRyYXdDYW52YXNQYXRoKGNoaWxkLCBjb250ZXh0LCBwYXRoMmQsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IpO1xuICAgIHJldHVybiBpZGxlO1xufVxuZXhwb3J0cy5yZW5kZXJFbGlwc2UgPSByZW5kZXJFbGlwc2U7XG5mdW5jdGlvbiByZW5kZXJMaW5lKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlbmRlcmVkU3RhdGUgPSByZXNvbHZlVmFsdWVzKGNoaWxkLCBsaW5lS2V5cywgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgY29uc3QgeyB4LCB5LCBpZGxlLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yLCBvcGFjaXR5LCB0eCwgdHksIGxpbmVXaWR0aCB9ID0gcmVuZGVyZWRTdGF0ZTtcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlID0gcmVuZGVyZWRTdGF0ZTtcbiAgICAoX2EgPSBjaGlsZC5vblByZURyYXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoaWxkLCBjaGlsZC5yZW5kZXJlZFN0YXRlKTtcbiAgICBjb25zdCBwYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgaWYgKGZpbGxDb2xvciB8fCBzdHJva2VDb2xvcikge1xuICAgICAgICBwYXRoMmQubW92ZVRvKHgsIHkpO1xuICAgICAgICBwYXRoMmQubGluZVRvKHR4LCB0eSk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSBwYXRoMmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRyYXdDYW52YXNQYXRoKGNoaWxkLCBjb250ZXh0LCBwYXRoMmQsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IpO1xuICAgIHJldHVybiBpZGxlO1xufVxuZXhwb3J0cy5yZW5kZXJMaW5lID0gcmVuZGVyTGluZTtcbmZ1bmN0aW9uIHJlbmRlclF1YWRyYXRpY0N1cnZlKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlbmRlcmVkU3RhdGUgPSByZXNvbHZlVmFsdWVzKGNoaWxkLCBxdWFkcmF0aWNDdXJ2ZUtleXMsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnN0IHsgeCwgeSwgY3gsIGN5LCBpZGxlLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yLCBvcGFjaXR5LCB0eCwgdHksIGxpbmVXaWR0aCB9ID0gcmVuZGVyZWRTdGF0ZTtcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlID0gcmVuZGVyZWRTdGF0ZTtcbiAgICAoX2EgPSBjaGlsZC5vblByZURyYXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoaWxkLCBjaGlsZC5yZW5kZXJlZFN0YXRlKTtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBjb25zdCBwYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGZpbGxDb2xvciB8fCBzdHJva2VDb2xvcikge1xuICAgICAgICBwYXRoMmQubW92ZVRvKHgsIHkpO1xuICAgICAgICBwYXRoMmQucXVhZHJhdGljQ3VydmVUbyhjeCwgY3ksIHR4LCB0eSk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSBwYXRoMmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRyYXdDYW52YXNQYXRoKGNoaWxkLCBjb250ZXh0LCBwYXRoMmQsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IpO1xuICAgIHJldHVybiBpZGxlO1xufVxuZXhwb3J0cy5yZW5kZXJRdWFkcmF0aWNDdXJ2ZSA9IHJlbmRlclF1YWRyYXRpY0N1cnZlO1xuZnVuY3Rpb24gcmVuZGVyQmV6aWVyQ3VydmUoY29udGV4dCwgY2hpbGQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVuZGVyZWRTdGF0ZSA9IHJlc29sdmVWYWx1ZXMoY2hpbGQsIGJlemllckN1cnZlS2V5cywgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgY29uc3QgeyB4LCB5LCBjeCwgY3ksIGMyeCwgYzJ5LCBpZGxlLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yLCBvcGFjaXR5LCB0eCwgdHksIGxpbmVXaWR0aCB9ID0gcmVuZGVyZWRTdGF0ZTtcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlID0gcmVuZGVyZWRTdGF0ZTtcbiAgICAoX2EgPSBjaGlsZC5vblByZURyYXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoaWxkLCBjaGlsZC5yZW5kZXJlZFN0YXRlKTtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBjb25zdCBwYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGZpbGxDb2xvciB8fCBzdHJva2VDb2xvcikge1xuICAgICAgICBwYXRoMmQubW92ZVRvKHgsIHkpO1xuICAgICAgICBwYXRoMmQuYmV6aWVyQ3VydmVUbyhjeCwgY3ksIGMyeCwgYzJ5LCB0eCwgdHkpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY2hpbGQucmVuZGVyZWRTdGF0ZS5wYXRoID0gcGF0aDJkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQucmVuZGVyZWRTdGF0ZS5wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkcmF3Q2FudmFzUGF0aChjaGlsZCwgY29udGV4dCwgcGF0aDJkLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yKTtcbiAgICByZXR1cm4gaWRsZTtcbn1cbmV4cG9ydHMucmVuZGVyQmV6aWVyQ3VydmUgPSByZW5kZXJCZXppZXJDdXJ2ZTtcbmZ1bmN0aW9uIGRyYXdDYW52YXNQYXRoKGNoaWxkLCBjb250ZXh0LCBwYXRoMmQsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IpIHtcbiAgICBpZiAoY2hpbGQuZmlsbENvbG9yKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgICAgICBjb250ZXh0LmZpbGwocGF0aDJkKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgY29udGV4dC5zdHJva2UocGF0aDJkKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLmNsaXApIHtcbiAgICAgICAgY29udGV4dC5jbGlwKHBhdGgyZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyUGF0aChjb250ZXh0LCBjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZW5kZXJlZFN0YXRlID0gcmVzb2x2ZVZhbHVlcyhjaGlsZCwgcGF0aEtleXMsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnN0IHsgeCwgeSwgaWRsZSwgZmlsbENvbG9yLCBzdHJva2VDb2xvciwgb3BhY2l0eSwgcGF0aCwgbGluZVdpZHRoIH0gPSByZW5kZXJlZFN0YXRlO1xuICAgIGNoaWxkLnJlbmRlcmVkU3RhdGUgPSByZW5kZXJlZFN0YXRlO1xuICAgIChfYSA9IGNoaWxkLm9uUHJlRHJhdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY2hpbGQsIGNoaWxkLnJlbmRlcmVkU3RhdGUpO1xuICAgIGxldCBwYXRoMmQ7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgaWYgKGZpbGxDb2xvciB8fCBzdHJva2VDb2xvcikge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgcGF0aDJkID0gbmV3IFBhdGgyRChwYXRoKTtcbiAgICAgICAgY2hpbGQucmVuZGVyZWRTdGF0ZS5wYXRoID0gcGF0aDJkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQucmVuZGVyZWRTdGF0ZS5wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY2hpbGQuZmlsbENvbG9yKSB7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICAgICAgY29udGV4dC5maWxsKHBhdGgyZCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5zdHJva2VDb2xvcikge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoMmQpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cbiAgICBpZiAoY2hpbGQuY2xpcCkge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY29udGV4dC5jbGlwKHBhdGgyZCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuICAgIHJldHVybiBpZGxlO1xufVxuZXhwb3J0cy5yZW5kZXJQYXRoID0gcmVuZGVyUGF0aDtcbmZ1bmN0aW9uIHJlbmRlclJlZ3VsYXJQb2x5Z29uKGNvbnRleHQsIGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlbmRlcmVkU3RhdGUgPSByZXNvbHZlVmFsdWVzKGNoaWxkLCByZWd1bGFyUG9seWdvbktleXMsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnN0IHsgeCwgeSwgaWRsZSwgZmlsbENvbG9yLCBzdHJva2VDb2xvciwgb3BhY2l0eSwgc2lkZXMsIHJhZGl1cyB9ID0gcmVuZGVyZWRTdGF0ZTtcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlID0gcmVuZGVyZWRTdGF0ZTtcbiAgICAoX2EgPSBjaGlsZC5vblByZURyYXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoaWxkLCBjaGlsZC5yZW5kZXJlZFN0YXRlKTtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBpZiAocmVuZGVyZWRTdGF0ZS5zaWRlcyA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGlkbGU7XG4gICAgfVxuICAgIGNvbnN0IHBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAoZmlsbENvbG9yIHx8IHN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGxldCBhbmdsZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIChzaWRlcyAvIDIpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0WCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBhdGgyZC5tb3ZlVG8odGFyZ2V0WCArIHJhZGl1cyArIHgsIHRhcmdldFkgKyByYWRpdXMgKyB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGgyZC5saW5lVG8odGFyZ2V0WCArIHJhZGl1cyArIHgsIHRhcmdldFkgKyByYWRpdXMgKyB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSBwYXRoMmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRyYXdDYW52YXNQYXRoKGNoaWxkLCBjb250ZXh0LCBwYXRoMmQsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IpO1xuICAgIHJldHVybiBpZGxlO1xufVxuZXhwb3J0cy5yZW5kZXJSZWd1bGFyUG9seWdvbiA9IHJlbmRlclJlZ3VsYXJQb2x5Z29uO1xuZnVuY3Rpb24gcmVuZGVyVGV4dChjb250ZXh0LCBjaGlsZCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgcmVuZGVyZWRTdGF0ZSA9IHJlc29sdmVWYWx1ZXMoY2hpbGQsIHRleHRLZXlzLCBvZmZzZXRYLCBvZmZzZXRZLCBmYWxzZSk7XG4gICAgbGV0IHsgeCwgeSwgaWRsZSwgZm9udFNpemUgPSAxNiwgdGV4dEJhc2VsaW5lLCBmb250LCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yLCBvcGFjaXR5LCB0ZXh0LCBmb250V2VpZ2h0LCB3aWR0aCwgd3JhcFdpZHRoLCBsaW5lSGVpZ2h0LCBvcmlnaW5YIH0gPSByZW5kZXJlZFN0YXRlO1xuICAgIGlmICgoKF9hID0gY2hpbGQucmVuZGVyZWRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSAmJiAhcmVuZGVyZWRTdGF0ZS53aWR0aCkge1xuICAgICAgICByZW5kZXJlZFN0YXRlLndpZHRoID0gY2hpbGQucmVuZGVyZWRTdGF0ZS53aWR0aDtcbiAgICB9XG4gICAgaWYgKCgoX2IgPSBjaGlsZC5yZW5kZXJlZFN0YXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVhbFdpZHRoKSAmJiAhcmVuZGVyZWRTdGF0ZS5yZWFsV2lkdGgpIHtcbiAgICAgICAgcmVuZGVyZWRTdGF0ZS5yZWFsV2lkdGggPSBjaGlsZC5yZW5kZXJlZFN0YXRlLnJlYWxXaWR0aDtcbiAgICB9XG4gICAgcmVuZGVyZWRTdGF0ZS5saW5lcyA9IChfYyA9IGNoaWxkLnJlbmRlcmVkU3RhdGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5saW5lcztcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlID0gcmVuZGVyZWRTdGF0ZTtcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLmxpbmVzID0gKF9kID0gY2hpbGQucmVuZGVyZWRTdGF0ZS5saW5lcykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgbGV0IGxpbmVzID0gY2hpbGQucmVuZGVyZWRTdGF0ZS5saW5lcztcbiAgICBpZiAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgIH1cbiAgICBjb250ZXh0LmZvbnQgPSBgJHtmb250V2VpZ2h0ID8gZm9udFdlaWdodCArICcgJyA6ICcnfSR7Zm9udFNpemV9cHggJHtmb250ICE9PSBudWxsICYmIGZvbnQgIT09IHZvaWQgMCA/IGZvbnQgOiAnQXJpYWwnfWA7XG4gICAgcmVuZGVyZWRTdGF0ZS5oZWlnaHQgPSBmb250U2l6ZTtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh3cmFwV2lkdGgpIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcmVkU3RhdGUucmVhbFdpZHRoID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlcyA9IHRleHQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBsaW5lID0gcGllY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICB3aGlsZSAocGllY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxpbmUgKyAnICcgKyBwaWVjZXNbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFdpZHRoLndpZHRoID4gY2hpbGQucmVuZGVyZWRTdGF0ZS5yZWFsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVuZGVyZWRTdGF0ZS5yZWFsV2lkdGggPSBtZWFzdXJlZFdpZHRoLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRXaWR0aCA8PSB3cmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSArPSAnICcgKyBwaWVjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBwaWVjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnJlbmRlcmVkU3RhdGUucmVhbFdpZHRoID0gY2hpbGQucmVuZGVyZWRTdGF0ZS53aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW5kZXJlZFN0YXRlLnJlYWxXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIChfZSA9IGNoaWxkLm9uUHJlRHJhdykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoY2hpbGQsIGNoaWxkLnJlbmRlcmVkU3RhdGUpO1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGlmIChvcmlnaW5YKSB7XG4gICAgICAgIHggLT0gTWF0aC5taW4oY2hpbGQucmVuZGVyZWRTdGF0ZS5yZWFsV2lkdGgsIGNoaWxkLnJlbmRlcmVkU3RhdGUud2lkdGgpICogb3JpZ2luWDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZmlsbENvbG9yKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIHgsIHkgKyAobGluZUhlaWdodCAhPT0gbnVsbCAmJiBsaW5lSGVpZ2h0ICE9PSB2b2lkIDAgPyBsaW5lSGVpZ2h0IDogMTYpICogaSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2VDb2xvcikge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2ldLCB4LCB5ICsgKGxpbmVIZWlnaHQgIT09IG51bGwgJiYgbGluZUhlaWdodCAhPT0gdm9pZCAwID8gbGluZUhlaWdodCA6IDE2KSAqIGksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRsZTtcbn1cbmV4cG9ydHMucmVuZGVyVGV4dCA9IHJlbmRlclRleHQ7XG5mdW5jdGlvbiByZW5kZXJSZWN0YW5nbGUoY29udGV4dCwgY2hpbGQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVuZGVyZWRTdGF0ZSA9IHJlc29sdmVWYWx1ZXMoY2hpbGQsIHJlY3RhbmdsZUtleXMsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgaWRsZSwgZmlsbENvbG9yLCBzdHJva2VDb2xvciwgb3BhY2l0eSB9ID0gcmVuZGVyZWRTdGF0ZTtcbiAgICBjaGlsZC5yZW5kZXJlZFN0YXRlID0gcmVuZGVyZWRTdGF0ZTtcbiAgICAoX2EgPSBjaGlsZC5vblByZURyYXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNoaWxkLCBjaGlsZC5yZW5kZXJlZFN0YXRlKTtcbiAgICBpZiAob3BhY2l0eSA8PSAwICYmICFjaGlsZC5jbGlwKSB7XG4gICAgICAgIHJldHVybiBpZGxlO1xuICAgIH1cbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBpZiAoZmlsbENvbG9yKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5jbGlwKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgfVxuICAgIHJldHVybiBpZGxlO1xufVxuZXhwb3J0cy5yZW5kZXJSZWN0YW5nbGUgPSByZW5kZXJSZWN0YW5nbGU7XG5mdW5jdGlvbiByZXNvbHZlVmFsdWVzKG5vZGUsIHByb3BzLCBvZmZzZXRYLCBvZmZzZXRZLCBhcHBseU9yaWdpbiA9IHRydWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBpZGxlOiB0cnVlLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgfTtcbiAgICBsZXQgaWRsZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcHJvcHMpIHtcbiAgICAgICAgY29uc3QgYmFzZVZhbHVlID0gKDAsIHV0aWxpdGllc18xLmRlcmVmKShub2RlW2tleV0pO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IChfYSA9IG5vZGUuYW5pbWF0aW9uU3RhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgobikgPT4gbltrZXldICE9IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByb2dyZXNzO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS50cmFuc2l0aW9uVGltZSkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gTWF0aC5taW4oMSwgKERhdGUubm93KCkgLSBub2RlLmFuaW1hdGlvblRpbWUpIC8gKDAsIHV0aWxpdGllc18xLmRlcmVmKShzdGF0ZS50cmFuc2l0aW9uVGltZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlVmFsdWUgKyAodGFyZ2V0VmFsdWUgLSBiYXNlVmFsdWUpICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICAgICAgaWRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnggKz0gb2Zmc2V0WDtcbiAgICByZXN1bHQueSArPSBvZmZzZXRZO1xuICAgIGlmIChhcHBseU9yaWdpbikge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgaWYgKHJlc3VsdC5vcmlnaW5YICYmIHJlc3VsdC53aWR0aCkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICByZXN1bHQueCAtPSByZXN1bHQud2lkdGggKiByZXN1bHQub3JpZ2luWDtcbiAgICAgICAgfVxuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgaWYgKHJlc3VsdC5vcmlnaW5ZICYmIHJlc3VsdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVzdWx0LnkgLT0gcmVzdWx0LmhlaWdodCAqIHJlc3VsdC5vcmlnaW5ZO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgndHgnIGluIHJlc3VsdCkge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmVzdWx0LnR4ICs9IG9mZnNldFg7XG4gICAgfVxuICAgIGlmICgndHknIGluIHJlc3VsdCkge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmVzdWx0LnR5ICs9IG9mZnNldFk7XG4gICAgfVxuICAgIGlmICgnY3gnIGluIHJlc3VsdCkge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmVzdWx0LmN4ICs9IG9mZnNldFg7XG4gICAgfVxuICAgIGlmICgnY3knIGluIHJlc3VsdCkge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmVzdWx0LmN5ICs9IG9mZnNldFk7XG4gICAgfVxuICAgIGlmICgnYzJ4JyBpbiByZXN1bHQpIHtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIHJlc3VsdC5jMnggKz0gb2Zmc2V0WDtcbiAgICB9XG4gICAgaWYgKCdjMnknIGluIHJlc3VsdCkge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmVzdWx0LmMyeSArPSBvZmZzZXRZO1xuICAgIH1cbiAgICByZXN1bHQuaWRsZSA9IGlkbGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmVzb2x2ZVZhbHVlcyA9IHJlc29sdmVWYWx1ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXJpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcmVmID0gdm9pZCAwO1xuY29uc3QgYXVydW1qc18xID0gcmVxdWlyZShcImF1cnVtanNcIik7XG5mdW5jdGlvbiBkZXJlZihzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgYXVydW1qc18xLkRhdGFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxufVxuZXhwb3J0cy5kZXJlZiA9IGRlcmVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==