var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define("src/utilities/cancellation_token", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.registerAnimationLoop = exports.CancellationToken = void 0;
    class CancellationToken {
        constructor(...cancellables) {
            this.cancelables = cancellables !== null && cancellables !== void 0 ? cancellables : [];
            this._isCancelled = false;
        }
        get isCanceled() {
            return this._isCancelled;
        }
        static fromMultiple(tokens) {
            const result = new CancellationToken();
            for (const token of tokens) {
                token.chain(result);
            }
            return result;
        }
        hasCancellables() {
            return this.cancelables.length > 0;
        }
        /**
         * Attaches a new cancelable to this token
         * @param delegate
         */
        addCancelable(delegate) {
            this.throwIfCancelled('attempting to add cancellable to token that is already cancelled');
            this.cancelables.push(delegate);
            if (this.cancelables.length === 200) {
                console.log('potential memory leak: cancellation token has over 200 clean up calls');
            }
            return this;
        }
        removeCancelable(delegate) {
            this.throwIfCancelled('attempting to remove cancellable from token that is already cancelled');
            const index = this.cancelables.indexOf(delegate);
            if (index !== -1) {
                this.cancelables.splice(index, 1);
            }
            return this;
        }
        setTimeout(cb, time = 0) {
            const id = setTimeout(() => {
                this.removeCancelable(cancelable);
                cb();
            }, time);
            const cancelable = () => clearTimeout(id);
            this.addCancelable(cancelable);
        }
        setInterval(cb, time) {
            const id = setInterval(cb, time);
            this.addCancelable(() => clearInterval(id));
        }
        requestAnimationFrame(cb) {
            const id = requestAnimationFrame(() => {
                this.removeCancelable(cancelable);
                cb();
            });
            const cancelable = () => cancelAnimationFrame(id);
            this.addCancelable(cancelable);
        }
        animationLoop(cb) {
            registerAnimationLoop(cb, this);
        }
        throwIfCancelled(msg) {
            if (this.isCanceled) {
                throw new Error(msg || 'cancellation token is cancelled');
            }
        }
        chain(target, twoWays = false) {
            const cancelable = () => target.cancel();
            if (twoWays) {
                target.chain(this, false);
            }
            else {
                target.addCancelable(() => {
                    if (!this.isCanceled) {
                        this.removeCancelable(cancelable);
                    }
                });
            }
            this.addCancelable(cancelable);
            return this;
        }
        /**
         * Registers an event using addEventListener and if you cancel the token the event will be canceled as well
         */
        registerDomEvent(eventEmitter, event, callback) {
            eventEmitter.addEventListener(event, callback);
            this.addCancelable(() => eventEmitter.removeEventListener(event, callback));
            return this;
        }
        /**
         * Cancels everything attached to this token
         */
        cancel() {
            if (this.isCanceled) {
                return;
            }
            this._isCancelled = true;
            this.cancelables.forEach((c) => c());
            this.cancelables = undefined;
        }
    }
    exports.CancellationToken = CancellationToken;
    CancellationToken.forever = new CancellationToken();
    const animationCbs = [];
    let looping = false;
    function registerAnimationLoop(callback, token) {
        animationCbs.push(callback);
        token.addCancelable(() => {
            animationCbs.splice(animationCbs.indexOf(callback), 1);
        });
        if (!looping) {
            looping = true;
            requestAnimationFrame(loop);
        }
    }
    exports.registerAnimationLoop = registerAnimationLoop;
    function loop(time) {
        for (const cb of animationCbs) {
            try {
                cb(time);
            }
            catch (e) {
                console.error(e);
            }
        }
        if (animationCbs.length === 0) {
            looping = false;
        }
        if (looping) {
            requestAnimationFrame(loop);
        }
    }
    CancellationToken.forever.addCancelable = () => void 0;
    CancellationToken.forever.cancel = () => {
        throw new Error('Cannot cancel forever token');
    };
});
define("src/utilities/event_emitter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventEmitter = void 0;
    /**
     * Event emitter is at the core of aurums stream system. It's a basic pub sub style typesafe event system optimized for high update throughput
     */
    class EventEmitter {
        constructor() {
            this.subscribeChannel = [];
            this.subscribeOnceChannel = [];
            this.onAfterFire = [];
        }
        /**
         * Set a number of subscriptions that any event can have at most before emitting warnings. The subscriptions will continue working but the warnings can be used
         * to track potential subscription memory leaks
         */
        static setSubscriptionLeakWarningThreshold(limit) {
            EventEmitter.leakWarningThreshold = limit;
        }
        /**
         * returns the count of subscriptions both one time and regular
         */
        get subscriptions() {
            return this.subscribeChannel.length + this.subscribeOnceChannel.length;
        }
        /**
         * Subscribe to the event. The callback will be called whenever the event fires an update
         */
        subscribe(callback, cancellationToken) {
            const { facade } = this.createSubscription(callback, this.subscribeChannel, cancellationToken);
            if (EventEmitter.leakWarningThreshold && this.subscribeChannel.length > EventEmitter.leakWarningThreshold) {
                console.warn(`Observable has ${this.subscribeChannel.length} subscriptions. This could potentially indicate a memory leak`);
            }
            return facade;
        }
        /**
         * Subscribe to the event. The callback will be called when the event next fires an update after which the subscription is cancelled
         */
        subscribeOnce(callback, cancellationToken) {
            const { facade } = this.createSubscription(callback, this.subscribeOnceChannel, cancellationToken);
            if (EventEmitter.leakWarningThreshold && this.subscribeOnceChannel.length > EventEmitter.leakWarningThreshold) {
                console.warn(`Observable has ${this.subscribeOnceChannel.length} one time subscriptions. This could potentially indicate a memory leak`);
            }
            return facade;
        }
        /**
         * Whether the event has any subscriptions
         */
        hasSubscriptions() {
            return this.subscriptions > 0;
        }
        /**
         * Removes all currently active subscriptions. If called in the callback of a subscription will be defered until after the fire event finished
         */
        cancelAll() {
            var _a;
            if (!this.isFiring) {
                this.subscribeChannel.length = 0;
                this.subscribeOnceChannel.length = 0;
                (_a = this.onEmpty) === null || _a === void 0 ? void 0 : _a.call(this);
            }
            else {
                this.onAfterFire.push(() => {
                    var _a;
                    this.subscribeChannel.length = 0;
                    this.subscribeOnceChannel.length = 0;
                    (_a = this.onEmpty) === null || _a === void 0 ? void 0 : _a.call(this);
                });
            }
        }
        afterFire() {
            if (this.onAfterFire.length > 0) {
                this.onAfterFire.forEach((cb) => cb());
                this.onAfterFire.length = 0;
            }
        }
        /**
         * Publishes a new value all subscribers will be called
         * Errors in the callbacks are caught and deferred until after fire finishes before throwing to avoid interrupting the propagation of the event
         * to all subscribers simply because of one faulty subscriber
         */
        fire(data) {
            const length = this.subscribeChannel.length;
            const lengthOnce = this.subscribeOnceChannel.length;
            if (length === 0 && lengthOnce === 0) {
                //Cut some overhead in the case nothing is listening
                return;
            }
            this.isFiring = true;
            let error = undefined;
            for (let i = 0; i < length; i++) {
                try {
                    this.subscribeChannel[i].callback(data);
                }
                catch (e) {
                    error = e;
                    console.error(e);
                }
            }
            if (this.subscribeOnceChannel.length > 0) {
                for (let i = 0; i < lengthOnce; i++) {
                    try {
                        this.subscribeOnceChannel[i].callback(data);
                    }
                    catch (e) {
                        error = e;
                        console.error(e);
                    }
                }
                this.subscribeOnceChannel.length = 0;
            }
            this.isFiring = false;
            this.afterFire();
            if (error) {
                throw error;
            }
        }
        createSubscription(callback, channel, cancellationToken) {
            const that = this;
            const subscription = {
                callback
            };
            const facade = {
                cancel() {
                    that.cancel(subscription, channel);
                }
            };
            if (cancellationToken !== undefined) {
                cancellationToken.addCancelable(() => that.cancel(subscription, channel));
            }
            if (this.isFiring) {
                this.onAfterFire.push(() => channel.push(subscription));
            }
            else {
                channel.push(subscription);
            }
            return { subscription, facade };
        }
        cancel(subscription, channel) {
            var _a;
            let index = channel.indexOf(subscription);
            if (index >= 0) {
                if (!this.isFiring) {
                    channel.splice(index, 1);
                    if (!this.hasSubscriptions()) {
                        (_a = this.onEmpty) === null || _a === void 0 ? void 0 : _a.call(this);
                    }
                }
                else {
                    this.onAfterFire.push(() => this.cancel(subscription, channel));
                }
            }
        }
    }
    exports.EventEmitter = EventEmitter;
});
define("src/stream/operator_model", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperationType = void 0;
    var OperationType;
    (function (OperationType) {
        OperationType[OperationType["FILTER"] = 0] = "FILTER";
        OperationType[OperationType["NOOP"] = 1] = "NOOP";
        OperationType[OperationType["MAP"] = 2] = "MAP";
        OperationType[OperationType["DELAY"] = 3] = "DELAY";
        OperationType[OperationType["MAP_DELAY"] = 4] = "MAP_DELAY";
        OperationType[OperationType["DELAY_FILTER"] = 5] = "DELAY_FILTER";
        OperationType[OperationType["MAP_DELAY_FILTER"] = 6] = "MAP_DELAY_FILTER";
    })(OperationType = exports.OperationType || (exports.OperationType = {}));
});
define("src/stream/stream", ["require", "exports", "src/utilities/cancellation_token", "src/stream/data_source"], function (require, exports, cancellation_token_js_1, data_source_js_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stream = void 0;
    /**
     * Lets you logically combine 2 data sources so that update calls go through the input source and listen goes to the output source
     */
    class Stream {
        constructor() { }
        get name() {
            return `IN:${this.input.name} OUT:${this.output.name}`;
        }
        /**
         * The current value of this data source, can be changed through update
         */
        get value() {
            return this.output.value;
        }
        static fromFetchRaw(url) {
            const input = new data_source_js_1.DataSource();
            const output = new data_source_js_1.DataSource();
            input.listen((value) => {
                output.update(fetch(url, value));
            });
            return Stream.fromPreconnectedSources(input, output);
        }
        static fromPreconnectedSources(inputSource, outputSource) {
            const result = new Stream();
            result.input = inputSource !== null && inputSource !== void 0 ? inputSource : new data_source_js_1.DataSource();
            result.output = outputSource !== null && outputSource !== void 0 ? outputSource : result.input;
            return result;
        }
        aggregate(otherSources, combinator, cancellationToken) {
            cancellationToken = cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_1.CancellationToken();
            const aggregatedSource = new data_source_js_1.DataSource(combinator(this.value, ...otherSources.map((s) => s.value)));
            for (let i = 0; i < otherSources.length; i++) {
                otherSources[i].listen(() => {
                    aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s.value)));
                }, cancellationToken);
            }
            this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s.value))), cancellationToken);
            return aggregatedSource;
        }
        static fromStreamTransformation(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ) {
            const result = new Stream();
            result.input = new data_source_js_1.DataSource();
            result.output = result.input.transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ);
            return result;
        }
        static fromFetchPostJson(url, baseRequestData) {
            const input = new data_source_js_1.DataSource();
            const output = new data_source_js_1.DataSource();
            input.listen(async (value) => {
                output.update(await fetch(url, Object.assign({
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                }, baseRequestData, {
                    body: JSON.stringify(value)
                })).then((s) => s.json()));
            });
            return Stream.fromPreconnectedSources(input, output);
        }
        static fromFetchGetJson(url, baseRequestData) {
            const input = new data_source_js_1.DataSource();
            const output = new data_source_js_1.DataSource();
            input.listen(async () => {
                output.update(await fetch(url).then((s) => s.json()));
            });
            return Stream.fromPreconnectedSources(input, output);
        }
        update(data) {
            this.input.update(data);
        }
        transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
            let token;
            const operations = [
                operationA,
                operationB,
                operationC,
                operationD,
                operationE,
                operationF,
                operationG,
                operationH,
                operationI,
                operationJ,
                operationK
            ].filter((e) => e && (e instanceof cancellation_token_js_1.CancellationToken ? ((token = e), false) : true));
            if (cancellationToken) {
                token = cancellationToken;
            }
            const result = new data_source_js_1.DataSource(undefined, this.output.name + ' ' + operations.map((v) => v.name).join(' '));
            this.listen((0, data_source_js_1.processTransform)(operations, result), token);
            return Stream.fromPreconnectedSources(this.input, result);
        }
        getInput() {
            return this.input;
        }
        getOutput() {
            return this.output;
        }
        listen(callback, cancellationToken) {
            return this.output.listen(callback, cancellationToken);
        }
        listenAndRepeat(callback, cancellationToken) {
            return this.output.listenAndRepeat(callback, cancellationToken);
        }
        listenOnce(callback, cancellationToken) {
            return this.output.listenOnce(callback, cancellationToken);
        }
        awaitNextUpdate(cancellationToken) {
            return this.output.awaitNextUpdate(cancellationToken);
        }
        cancelAll() {
            this.input.cancelAll();
            this.output.cancelAll();
        }
    }
    exports.Stream = Stream;
});
define("src/stream/data_source_operators", ["require", "exports", "src/utilities/event_emitter", "src/stream/data_source", "src/stream/stream", "src/stream/operator_model", "src/utilities/cancellation_token"], function (require, exports, event_emitter_js_1, data_source_js_2, stream_js_1, operator_model_js_1, cancellation_token_js_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dsPipeAll = exports.dsLog = exports.dsLoadBalance = exports.dsTap = exports.dsThroughputMeter = exports.dsHistory = exports.dsPipeUp = exports.dsPipe = exports.dsPick = exports.dsBuffer = exports.dsThrottle = exports.dsLock = exports.dsThrottleFrame = exports.dsMicroDebounce = exports.dsDebounce = exports.dsDelay = exports.dsStringJoin = exports.dsReduce = exports.dsAwaitLatest = exports.dsAwaitOrdered = exports.dsAwait = exports.dsUnique = exports.dsSemaphore = exports.dsCutOffDynamic = exports.dsCutOff = exports.dsSkip = exports.dsSkipDynamic = exports.dsMax = exports.dsMin = exports.dsOdd = exports.dsEven = exports.dsFilterAsync = exports.dsFilter = exports.dsUpdateToken = exports.dsDiff = exports.dsMapAsync = exports.dsFork = exports.dsMap = void 0;
    /**
     * Mutates an update
     */
    function dsMap(mapper) {
        return {
            name: 'map',
            operationType: operator_model_js_1.OperationType.MAP,
            operation: (v) => mapper(v)
        };
    }
    exports.dsMap = dsMap;
    /**
     * Forwards an update to one of two possible sources based on a condition
     */
    function dsFork(condition, truthyPath, falsyPath) {
        return {
            name: 'fork',
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                if (condition(v)) {
                    truthyPath.update(v);
                }
                else {
                    falsyPath.update(v);
                }
                return v;
            }
        };
    }
    exports.dsFork = dsFork;
    /**
     * Same as map but with an async mapper function
     */
    function dsMapAsync(mapper) {
        return {
            name: 'mapAsync',
            operationType: operator_model_js_1.OperationType.MAP_DELAY,
            operation: (v) => mapper(v)
        };
    }
    exports.dsMapAsync = dsMapAsync;
    /**
     * Changes updates to contain the value of the previous update as well as the current
     */
    function dsDiff() {
        let lastValue = undefined;
        return {
            name: 'diff',
            operationType: operator_model_js_1.OperationType.MAP,
            operation: (v) => {
                let result = {
                    oldValue: lastValue,
                    newValue: v
                };
                lastValue = v;
                return result;
            }
        };
    }
    exports.dsDiff = dsDiff;
    /**
     * Changes updates to contain the value of the previous update as well as the current
     */
    function dsUpdateToken() {
        let token;
        return {
            name: 'diff',
            operationType: operator_model_js_1.OperationType.MAP,
            operation: (v) => {
                if (token) {
                    token.cancel();
                }
                token = new cancellation_token_js_2.CancellationToken();
                return {
                    token,
                    value: v
                };
            }
        };
    }
    exports.dsUpdateToken = dsUpdateToken;
    /**
     * Blocks updates that don't pass the filter predicate
     */
    function dsFilter(predicate) {
        return {
            name: 'filter',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => predicate(v)
        };
    }
    exports.dsFilter = dsFilter;
    /**
     * Same as filter but with an async predicate function
     */
    function dsFilterAsync(predicate) {
        return {
            name: 'filterAsync',
            operationType: operator_model_js_1.OperationType.DELAY_FILTER,
            operation: (v) => predicate(v)
        };
    }
    exports.dsFilterAsync = dsFilterAsync;
    /**
     * Only propagate an update if the value is even
     */
    function dsEven() {
        return {
            name: 'even',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => v % 2 === 0
        };
    }
    exports.dsEven = dsEven;
    /**
     * Only propagate an update if the value is odd
     */
    function dsOdd() {
        return {
            name: 'odd',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => v % 2 !== 0
        };
    }
    exports.dsOdd = dsOdd;
    /**
     * Only propagate an update if the value is lower than the previous update
     */
    function dsMin() {
        let last = Number.MAX_SAFE_INTEGER;
        return {
            name: 'min',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => {
                if (v < last) {
                    last = v;
                    return true;
                }
                else {
                    return false;
                }
            }
        };
    }
    exports.dsMin = dsMin;
    /**
     * Only propagate an update if the value is higher than the previous update
     */
    function dsMax() {
        let last = Number.MIN_SAFE_INTEGER;
        return {
            name: 'max',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => {
                if (v > last) {
                    last = v;
                    return true;
                }
                else {
                    return false;
                }
            }
        };
    }
    exports.dsMax = dsMax;
    /**
     * Ignore the first N updates where N depends on an external source
     */
    function dsSkipDynamic(amountLeft) {
        return {
            operationType: operator_model_js_1.OperationType.FILTER,
            name: 'skipDynamic',
            operation: (v) => {
                if (amountLeft.value === 0) {
                    return true;
                }
                else {
                    amountLeft.update(amountLeft.value - 1);
                    return false;
                }
            }
        };
    }
    exports.dsSkipDynamic = dsSkipDynamic;
    /**
     * Ignore the first N updates
     */
    function dsSkip(amount) {
        return {
            operationType: operator_model_js_1.OperationType.FILTER,
            name: `skip ${amount}`,
            operation: (v) => {
                if (amount === 0) {
                    return true;
                }
                else {
                    amount--;
                    return false;
                }
            }
        };
    }
    exports.dsSkip = dsSkip;
    /**
     * Allows only a certain number of updates to pass decreasing a counter on each pass
     * If the counter reaches 0 the updates are lost
     */
    function dsCutOff(amount) {
        return {
            name: `cutoff ${amount}`,
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => {
                if (amount === 0) {
                    return false;
                }
                else {
                    amount--;
                    return true;
                }
            }
        };
    }
    exports.dsCutOff = dsCutOff;
    /**
     * Allows only a certain number of updates to pass decreasing a counter on each pass, the counter being an external
     * datasource can be changed externally.
     * If the counter reaches 0 the updates are lost
     */
    function dsCutOffDynamic(amountLeft) {
        return {
            name: 'cutoffDynamic',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => {
                if (amountLeft.value === 0) {
                    return false;
                }
                else {
                    amountLeft.update(amountLeft.value - 1);
                    return true;
                }
            }
        };
    }
    exports.dsCutOffDynamic = dsCutOffDynamic;
    /**
     * Allows only a certain number of updates to pass decreasing a counter on each pass, the counter being an external
     * datasource can be changed externally.
     * If the counter reaches 0 the updates are buffered until they are unlocked again
     */
    function dsSemaphore(state) {
        return {
            operationType: operator_model_js_1.OperationType.DELAY,
            name: 'semaphore',
            operation: (v) => {
                return new Promise((resolve) => {
                    if (state.value > 0) {
                        state.update(state.value - 1);
                        resolve(v);
                    }
                    else {
                        const cancel = state.listen(() => {
                            if (state.value > 0) {
                                cancel();
                                state.update(state.value - 1);
                                resolve(v);
                            }
                        });
                    }
                });
            }
        };
    }
    exports.dsSemaphore = dsSemaphore;
    /**
     * Filters out updates if they have the same value as the previous update, uses reference equality by default
     */
    function dsUnique(isEqual) {
        let primed = false;
        let last;
        return {
            name: 'unique',
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => {
                if (primed && (isEqual ? isEqual(last, v) : v === last)) {
                    return false;
                }
                else {
                    primed = true;
                    last = v;
                    return true;
                }
            }
        };
    }
    exports.dsUnique = dsUnique;
    /**
     * Takes promises and updates with the resolved value, if multiple promises come in processes updates as promises resolve in any order
     */
    function dsAwait() {
        return {
            name: 'await',
            operationType: operator_model_js_1.OperationType.MAP_DELAY,
            operation: (v) => {
                return v;
            }
        };
    }
    exports.dsAwait = dsAwait;
    /**
     * Takes promises and updates with the resolved value, if multiple promises come in makes sure the updates fire in the same order that the promises came in
     */
    function dsAwaitOrdered() {
        const queue = [];
        const onDequeue = new event_emitter_js_1.EventEmitter();
        return {
            operationType: operator_model_js_1.OperationType.MAP_DELAY,
            name: 'awaitOrdered',
            operation: async (v) => {
                queue.push(v);
                if (queue.length === 1) {
                    return processItem();
                }
                else {
                    const unsub = onDequeue.subscribe(async () => {
                        if (queue[0] === v) {
                            unsub.cancel();
                            return processItem();
                        }
                    });
                }
            }
        };
        async function processItem() {
            await queue[0];
            const item = queue.shift();
            onDequeue.fire();
            return item;
        }
    }
    exports.dsAwaitOrdered = dsAwaitOrdered;
    /**
     * awaits promise and forwards the resolved value, if a new promise comes in while the first isn't resolved then the first
     * promise will be ignored even if it resolves first and instead we focus on the newest promise. This is useful for cancellable
     * async operations where we only care about the result if it's the latest action
     */
    function dsAwaitLatest() {
        let freshnessToken;
        return {
            operationType: operator_model_js_1.OperationType.MAP_DELAY_FILTER,
            name: 'awaitLatest',
            operation: async (v) => {
                freshnessToken = Date.now();
                const timestamp = freshnessToken;
                const resolved = await v;
                if (freshnessToken === timestamp) {
                    return {
                        item: resolved,
                        cancelled: false
                    };
                }
                else {
                    return {
                        item: undefined,
                        cancelled: true
                    };
                }
            }
        };
    }
    exports.dsAwaitLatest = dsAwaitLatest;
    /**
     * Reduces all updates down to a value
     */
    function dsReduce(reducer, initialValue) {
        let last = initialValue;
        return {
            name: 'reduce',
            operationType: operator_model_js_1.OperationType.MAP,
            operation: (v) => {
                last = reducer(last, v);
                return last;
            }
        };
    }
    exports.dsReduce = dsReduce;
    /**
     * Builds a string where each update is appened to the string optionally with a seperator
     */
    function dsStringJoin(seperator = ', ') {
        let last;
        return {
            name: `stringJoin ${seperator}`,
            operationType: operator_model_js_1.OperationType.MAP,
            operation: (v) => {
                if (last) {
                    last += seperator + v;
                }
                else {
                    last = v;
                }
                return last;
            }
        };
    }
    exports.dsStringJoin = dsStringJoin;
    /**
     * Adds a fixed amount of lag to updates
     */
    function dsDelay(time) {
        return {
            name: `delay ${time}ms`,
            operationType: operator_model_js_1.OperationType.DELAY,
            operation: (v) => {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(v);
                    }, time);
                });
            }
        };
    }
    exports.dsDelay = dsDelay;
    /**
     * Starts a timer when an update occurs, delays the update until the timer passed if a new update arrives the initial
     * update is cancelled and the process starts again
     */
    function dsDebounce(time) {
        let timeout;
        let cancelled = new event_emitter_js_1.EventEmitter();
        return {
            operationType: operator_model_js_1.OperationType.DELAY_FILTER,
            name: `debounce ${time}ms`,
            operation: (v) => {
                return new Promise((resolve) => {
                    clearTimeout(timeout);
                    cancelled.fire();
                    cancelled.subscribeOnce(() => {
                        resolve(false);
                    });
                    timeout = setTimeout(() => {
                        resolve(true);
                        cancelled.cancelAll();
                    }, time);
                });
            }
        };
    }
    exports.dsDebounce = dsDebounce;
    /**
     * Only allow up to 1 update to propagate per frame makes update run as a microtask
     */
    function dsMicroDebounce() {
        let scheduled;
        return {
            operationType: operator_model_js_1.OperationType.DELAY_FILTER,
            name: `microDebounce`,
            operation: (v) => {
                return new Promise((resolve) => {
                    if (!scheduled) {
                        scheduled = true;
                        queueMicrotask(() => resolve(true));
                    }
                    else {
                        resolve(false);
                    }
                });
            }
        };
    }
    exports.dsMicroDebounce = dsMicroDebounce;
    /**
     * Debounce update to occur at most one per animation frame
     */
    function dsThrottleFrame() {
        let timeout;
        let cancelled = new event_emitter_js_1.EventEmitter();
        return {
            operationType: operator_model_js_1.OperationType.DELAY_FILTER,
            name: `throttle frame`,
            operation: (v) => {
                return new Promise((resolve) => {
                    clearTimeout(timeout);
                    cancelled.fire();
                    cancelled.subscribeOnce(() => {
                        resolve(false);
                    });
                    timeout = requestAnimationFrame(() => {
                        resolve(true);
                        cancelled.cancelAll();
                    });
                });
            }
        };
    }
    exports.dsThrottleFrame = dsThrottleFrame;
    /**
     * May or may not block all updates based on the state provided by another source
     * When unblocked the last value that was blocked is passed through
     * lock state
     * true => updates pass through
     * false => latest update state is buffered and passes once unlocked
     */
    function dsLock(state) {
        return {
            name: 'lock',
            operationType: operator_model_js_1.OperationType.DELAY,
            operation: (v) => {
                return new Promise((resolve) => {
                    if (state.value) {
                        resolve(v);
                    }
                    else {
                        const cancel = state.listen(() => {
                            if (state.value) {
                                cancel();
                                resolve(v);
                            }
                        });
                    }
                });
            }
        };
    }
    exports.dsLock = dsLock;
    /**
     * Allows at most one update per N milliseconds to pass through
     */
    function dsThrottle(time) {
        let cooldown = false;
        return {
            name: `throttle ${time}ms`,
            operationType: operator_model_js_1.OperationType.FILTER,
            operation: (v) => {
                if (!cooldown) {
                    cooldown = true;
                    setTimeout(() => {
                        cooldown = false;
                    }, time);
                    return true;
                }
                else {
                    return false;
                }
            }
        };
    }
    exports.dsThrottle = dsThrottle;
    /**
     * When an update occurs a timer is started, during that time all subsequent updates are collected in an array and then
     * once the timer runs out an update is made with all updates collected so far as an array
     */
    function dsBuffer(time) {
        let buffer = [];
        let promise;
        return {
            name: `buffer ${time}ms`,
            operationType: operator_model_js_1.OperationType.MAP_DELAY_FILTER,
            operation: (v) => {
                buffer.push(v);
                if (!promise) {
                    promise = new Promise((resolve) => {
                        setTimeout(() => {
                            promise = undefined;
                            resolve({
                                cancelled: false,
                                item: buffer
                            });
                            buffer = [];
                        }, time);
                    });
                    return promise;
                }
                else {
                    return Promise.resolve({
                        cancelled: true,
                        item: undefined
                    });
                }
            }
        };
    }
    exports.dsBuffer = dsBuffer;
    /**
     * Extracts only the value of a key of the update value
     */
    function dsPick(key) {
        return {
            name: `pick ${key.toString()}`,
            operationType: operator_model_js_1.OperationType.MAP,
            operation: (v) => {
                if (v !== undefined && v !== null) {
                    return v[key];
                }
                else {
                    return v;
                }
            }
        };
    }
    exports.dsPick = dsPick;
    /**
     * Forwards an event to another source
     */
    function dsPipe(target) {
        return {
            name: `pipe ${target.name}`,
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                if (target instanceof data_source_js_2.DataSource || target instanceof stream_js_1.Stream) {
                    target.update(v);
                }
                else {
                    target.updateDownstream(v);
                }
                return v;
            }
        };
    }
    exports.dsPipe = dsPipe;
    /**
     * Same as pipe except for duplex data sources it pipes upstream
     */
    function dsPipeUp(target) {
        return {
            name: `pipeup ${target.name}`,
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                if (target instanceof data_source_js_2.DataSource || target instanceof stream_js_1.Stream) {
                    target.update(v);
                }
                else {
                    target.updateUpstream(v);
                }
                return v;
            }
        };
    }
    exports.dsPipeUp = dsPipeUp;
    /**
     * Lets you keep a history of the updates of a source by pushing it onto an array datasource
     */
    function dsHistory(reportTarget, generations, cancellationToken = new cancellation_token_js_2.CancellationToken()) {
        return {
            operationType: operator_model_js_1.OperationType.NOOP,
            name: `history`,
            operation: (v) => {
                if (!cancellationToken.isCanceled) {
                    if (generations) {
                        if (reportTarget.length.value >= generations) {
                            reportTarget.removeLeft(reportTarget.length.value - generations);
                        }
                    }
                    reportTarget.push(v);
                }
                return v;
            }
        };
    }
    exports.dsHistory = dsHistory;
    /**
     * Monitors the number of events per interval
     */
    function dsThroughputMeter(reportTarget, interval, cancellationToken = new cancellation_token_js_2.CancellationToken()) {
        let amount = 0;
        cancellationToken.setInterval(() => {
            reportTarget.update(amount);
            amount = 0;
        }, interval);
        return {
            operationType: operator_model_js_1.OperationType.NOOP,
            name: `throughput meter`,
            operation: (v) => {
                amount++;
                return v;
            }
        };
    }
    exports.dsThroughputMeter = dsThroughputMeter;
    /**
     * Allows inserting a callback that gets called with an update
     */
    function dsTap(cb) {
        return {
            name: 'tap',
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                cb(v);
                return v;
            }
        };
    }
    exports.dsTap = dsTap;
    /**
     * Pipes updates to the targets in round-robin fashion
     */
    function dsLoadBalance(targets) {
        let i = 0;
        return {
            name: `loadBalance [${targets.map((v) => v.name).join()}]`,
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                const target = targets[i++];
                if (i >= targets.length) {
                    i = 0;
                }
                if (target instanceof data_source_js_2.DataSource || target instanceof stream_js_1.Stream) {
                    target.update(v);
                }
                else {
                    target.updateDownstream(v);
                }
                return v;
            }
        };
    }
    exports.dsLoadBalance = dsLoadBalance;
    /**
     * Logs updates to the console
     */
    function dsLog(prefix = '', suffix = '') {
        return {
            name: `log`,
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                console.log(`${prefix}${v}${suffix}`);
                return v;
            }
        };
    }
    exports.dsLog = dsLog;
    function dsPipeAll(...sources) {
        return {
            name: `pipeAll [${sources.map((v) => v.name).join()}]`,
            operationType: operator_model_js_1.OperationType.NOOP,
            operation: (v) => {
                sources.forEach((source) => {
                    if (source instanceof data_source_js_2.DataSource || source instanceof stream_js_1.Stream) {
                        source.update(v);
                    }
                    else {
                        source.updateDownstream(v);
                    }
                });
                return v;
            }
        };
    }
    exports.dsPipeAll = dsPipeAll;
});
define("src/stream/duplex_data_source_operators", ["require", "exports", "src/stream/data_source_operators", "src/stream/operator_model"], function (require, exports, data_source_operators_js_1, operator_model_js_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddsUnique = exports.ddsFilter = exports.ddsOneWayFlow = exports.ddsDebounce = exports.ddsMap = exports.DataFlowBoth = exports.DataFlow = void 0;
    var DataFlow;
    (function (DataFlow) {
        DataFlow[DataFlow["UPSTREAM"] = 0] = "UPSTREAM";
        DataFlow[DataFlow["DOWNSTREAM"] = 1] = "DOWNSTREAM";
    })(DataFlow = exports.DataFlow || (exports.DataFlow = {}));
    var DataFlowBoth;
    (function (DataFlowBoth) {
        DataFlowBoth[DataFlowBoth["UPSTREAM"] = 0] = "UPSTREAM";
        DataFlowBoth[DataFlowBoth["DOWNSTREAM"] = 1] = "DOWNSTREAM";
        DataFlowBoth[DataFlowBoth["BOTH"] = 2] = "BOTH";
    })(DataFlowBoth = exports.DataFlowBoth || (exports.DataFlowBoth = {}));
    function ddsMap(mapDown, mapUp) {
        return {
            name: 'map',
            operationType: operator_model_js_2.OperationType.MAP,
            operationDown: (v) => mapDown(v),
            operationUp: (v) => mapUp(v)
        };
    }
    exports.ddsMap = ddsMap;
    /**
     * Starts a timer when an update occurs, delays the update until the timer passed if a new update arrives the initial
     * update is cancelled and the process starts again
     */
    function ddsDebounce(time, direction) {
        const debounceDown = (0, data_source_operators_js_1.dsDebounce)(time);
        const debounceUp = (0, data_source_operators_js_1.dsDebounce)(time);
        return {
            operationType: operator_model_js_2.OperationType.DELAY_FILTER,
            name: `debounce ${time}ms`,
            operationDown: (v) => {
                if (direction === undefined || direction === DataFlowBoth.DOWNSTREAM || direction === DataFlowBoth.BOTH) {
                    return debounceDown.operation(v);
                }
                else {
                    return Promise.resolve(true);
                }
            },
            operationUp: (v) => {
                if (direction === undefined || direction === DataFlowBoth.UPSTREAM || direction === DataFlowBoth.BOTH) {
                    return debounceUp.operation(v);
                }
                else {
                    return Promise.resolve(true);
                }
            }
        };
    }
    exports.ddsDebounce = ddsDebounce;
    function ddsOneWayFlow(direction) {
        if (direction === DataFlow.DOWNSTREAM) {
            return ddsFilter(() => true, () => false);
        }
        else {
            return ddsFilter(() => false, () => true);
        }
    }
    exports.ddsOneWayFlow = ddsOneWayFlow;
    function ddsFilter(predicateDown, predicateUp) {
        return {
            name: 'filter',
            operationType: operator_model_js_2.OperationType.FILTER,
            operationDown: (v) => predicateDown(v),
            operationUp: (v) => predicateUp(v)
        };
    }
    exports.ddsFilter = ddsFilter;
    function ddsUnique(direction, isEqual) {
        let lastDown;
        let lastUp;
        let primedUp = false;
        let primedDown = false;
        return {
            name: 'filter',
            operationType: operator_model_js_2.OperationType.FILTER,
            operationDown: (v) => {
                if (direction === undefined || direction === DataFlowBoth.DOWNSTREAM || direction === DataFlowBoth.BOTH) {
                    if (primedDown && (isEqual ? isEqual(lastDown, v) : v === lastDown)) {
                        return false;
                    }
                    else {
                        primedDown = true;
                        lastDown = v;
                        return true;
                    }
                }
                else {
                    return true;
                }
            },
            operationUp: (v) => {
                if (direction === undefined || direction === DataFlowBoth.UPSTREAM || direction === DataFlowBoth.BOTH) {
                    if (primedUp && (isEqual ? isEqual(lastUp, v) : v === lastUp)) {
                        return false;
                    }
                    else {
                        lastUp = v;
                        primedUp = true;
                        return true;
                    }
                }
                else {
                    return true;
                }
            }
        };
    }
    exports.ddsUnique = ddsUnique;
});
define("src/stream/duplex_data_source", ["require", "exports", "src/aurum_server/aurum_server_client", "src/utilities/cancellation_token", "src/utilities/event_emitter", "src/stream/data_source", "src/stream/duplex_data_source_operators", "src/stream/operator_model"], function (require, exports, aurum_server_client_js_1, cancellation_token_js_3, event_emitter_js_2, data_source_js_3, duplex_data_source_operators_js_1, operator_model_js_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processTransformDuplex = exports.DuplexDataSource = void 0;
    /**
     * Same as DataSource except data can flow in both directions
     */
    class DuplexDataSource {
        /**
         *
         * @param initialValue
         * @param rootNode If a write is done propagate this update back down to all the consumers. Useful at the root node
         */
        constructor(initialValue, rootNode = true, name = 'RootDuplexDataSource') {
            this.name = name;
            this.value = initialValue;
            this.primed = initialValue !== undefined;
            this.updateDownstreamEvent = new event_emitter_js_2.EventEmitter();
            this.updateUpstreamEvent = new event_emitter_js_2.EventEmitter();
            this.propagateWritesToReadStream = rootNode;
        }
        /**
         * Connects to an aurum-server exposed datasource view https://github.com/CyberPhoenix90/aurum-server for more information
         * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated
         * @param  {AurumServerInfo} aurumServerInfo
         * @returns DataSource
         */
        static fromRemoteSource(aurumServerInfo, cancellation) {
            const result = new DuplexDataSource(undefined, false);
            (0, aurum_server_client_js_1.syncDuplexDataSource)(result, aurumServerInfo, cancellation);
            return result;
        }
        static toDuplexDataSource(value) {
            if (value instanceof DuplexDataSource) {
                return value;
            }
            else {
                return new DuplexDataSource(value);
            }
        }
        /**
         * Makes it possible to have 2 completely separate data flow pipelines for each direction
         * @param downStream stream to pipe downstream data to
         * @param upstream  stream to pipe upstream data to
         */
        static fromTwoDataSource(downStream, upstream, initialValue, propagateWritesToReadStream = true) {
            const result = new DuplexDataSource(initialValue, propagateWritesToReadStream);
            //@ts-ignore
            result.updateDownstreamEvent = downStream.updateEvent;
            //@ts-ignore
            result.updateUpstreamEvent = upstream.updateEvent;
            return result;
        }
        /**
         * Updates the data source with a value if it has never had a value before
         */
        withInitial(value) {
            if (!this.primed) {
                this.updateDownstream(value);
            }
            return this;
        }
        toString() {
            return this.value.toString();
        }
        /**
         * Allows creating a duplex stream that blocks data in one direction. Useful for plugging into code that uses two way flow but only one way is desired
         * @param direction direction of the dataflow that is allowed
         */
        static createOneWay(direction = duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM, initialValue) {
            return new DuplexDataSource(initialValue, false).transformDuplex((0, duplex_data_source_operators_js_1.ddsOneWayFlow)(direction));
        }
        /**
         * Updates the value in the data source and calls the listen callback for all listeners
         * @param newValue new value for the data source
         */
        updateDownstream(newValue) {
            if (this.updatingDownstream) {
                throw new Error('Problem in datas source: Unstable value propagation, when updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed');
            }
            this.primed = true;
            this.updatingDownstream = true;
            this.value = newValue;
            this.updateDownstreamEvent.fire(newValue);
            this.updatingDownstream = false;
        }
        /**
         * Updates the value in the data source and calls the listen callback for all listeners
         * @param newValue new value for the data source
         */
        updateUpstream(newValue) {
            if (this.updatingUpstream) {
                throw new Error('Problem in datas source: Unstable value propagation, when updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed');
            }
            this.primed = true;
            this.updatingUpstream = true;
            this.value = newValue;
            this.updateUpstreamEvent.fire(newValue);
            if (this.propagateWritesToReadStream) {
                this.updateDownstreamEvent.fire(newValue);
            }
            this.updatingUpstream = false;
        }
        /**
         * Same as listen but will immediately call the callback with the current value first
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenAndRepeat(callback, cancellationToken) {
            if (this.primed) {
                callback(this.value);
            }
            return this.listen(callback, cancellationToken);
        }
        /**
         * alias for listenDownstream
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listen(callback, cancellationToken) {
            return this.listenInternal(callback, cancellationToken);
        }
        listenInternal(callback, cancellationToken) {
            return this.updateDownstreamEvent.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Subscribes exclusively to updates of the data stream that occur due to an update flowing upstream
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenUpstream(callback, cancellationToken) {
            return this.updateUpstreamEvent.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Subscribes exclusively to updates of the data stream that occur due to an update flowing upstream
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenUpstreamAndRepeat(callback, cancellationToken) {
            if (this.primed) {
                callback(this.value);
            }
            return this.updateUpstreamEvent.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Subscribes exclusively to one update of the data stream that occur due to an update flowing upstream
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenUpstreamOnce(callback, cancellationToken) {
            return this.updateUpstreamEvent.subscribeOnce(callback, cancellationToken).cancel;
        }
        /**
         * Subscribes exclusively to updates of the data stream that occur due to an update flowing downstream
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenDownstream(callback, cancellationToken) {
            return this.updateDownstreamEvent.subscribe(callback, cancellationToken).cancel;
        }
        downStreamToDataSource(cancellationToken) {
            const downStreamDatasource = new data_source_js_3.DataSource(this.value);
            this.listenDownstream((newVal) => {
                downStreamDatasource.update(newVal);
            }, cancellationToken);
            return downStreamDatasource;
        }
        aggregate(otherSources, combinator, cancellationToken) {
            var _a;
            cancellationToken = cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_3.CancellationToken();
            const aggregatedSource = new data_source_js_3.DataSource(combinator(this.value, ...otherSources.map((s) => s === null || s === void 0 ? void 0 : s.value)));
            for (let i = 0; i < otherSources.length; i++) {
                (_a = otherSources[i]) === null || _a === void 0 ? void 0 : _a.listen(() => {
                    aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s === null || s === void 0 ? void 0 : s.value)));
                }, cancellationToken);
            }
            this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s === null || s === void 0 ? void 0 : s.value))), cancellationToken);
            return aggregatedSource;
        }
        transformDuplex(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
            let token;
            const operations = [
                operationA,
                operationB,
                operationC,
                operationD,
                operationE,
                operationF,
                operationG,
                operationH,
                operationI,
                operationJ,
                operationK
            ].filter((e) => e && (e instanceof cancellation_token_js_3.CancellationToken ? ((token = e), false) : true));
            if (cancellationToken) {
                token = cancellationToken;
            }
            const result = new DuplexDataSource(undefined, false, this.name + ' ' + operations.map((v) => v.name).join(' '));
            (this.primed ? this.listenAndRepeat : this.listen).call(this, processTransformDuplex(operations, result, duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM), token);
            result.listenUpstream.call(result, processTransformDuplex(operations, this, duplex_data_source_operators_js_1.DataFlow.UPSTREAM), token);
            return result;
        }
        transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
            let token;
            const operations = [
                operationA,
                operationB,
                operationC,
                operationD,
                operationE,
                operationF,
                operationG,
                operationH,
                operationI,
                operationJ,
                operationK
            ].filter((e) => e && (e instanceof cancellation_token_js_3.CancellationToken ? ((token = e), false) : true));
            if (cancellationToken) {
                token = cancellationToken;
            }
            const result = new data_source_js_3.DataSource(undefined, this.name + ' ' + operations.map((v) => v.name).join(' '));
            (this.primed ? this.listenAndRepeat : this.listen).call(this, (0, data_source_js_3.processTransform)(operations, result), token);
            return result;
        }
        /**
         * Forwards all updates from this source to another
         * @param targetDataSource datasource to pipe the updates to
         * @param cancellationToken  Cancellation token to cancel the subscriptions added to the datasources by this operation
         */
        pipe(targetDataSource, cancellationToken) {
            this.listenDownstream((newVal) => targetDataSource.updateDownstream(newVal), cancellationToken);
            targetDataSource.listenUpstream((newVal) => this.updateUpstream(newVal), cancellationToken);
            return this;
        }
        listenOnce(callback, cancellationToken) {
            return this.updateDownstreamEvent.subscribeOnce(callback, cancellationToken).cancel;
        }
        /**
         * Returns a promise that resolves when the next update occurs
         * @param cancellationToken
         */
        awaitNextUpdate(cancellationToken) {
            return new Promise((resolve) => {
                this.listenOnce((value) => resolve(value), cancellationToken);
            });
        }
        /**
         * Remove all listeners
         */
        cancelAll() {
            this.updateDownstreamEvent.cancelAll();
            this.updateUpstreamEvent.cancelAll();
        }
        cancelAllDownstream() {
            this.updateDownstreamEvent.cancelAll();
        }
        cancelAllUpstream() {
            this.updateUpstreamEvent.cancelAll();
        }
        /**
         * Assign a function to handle errors and map them back to regular values. Rethrow the error in case you want to fallback to emitting error
         */
        handleErrors(callback) {
            this.errorHandler = callback;
            return this;
        }
        onError(callback, cancellationToken) {
            this.errorEvent.subscribe(callback, cancellationToken);
            return this;
        }
        emitError(e, direction) {
            if (this.errorHandler) {
                try {
                    if (direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM) {
                        return this.updateDownstream(this.errorHandler(e));
                    }
                    else {
                        return this.updateUpstream(this.errorHandler(e));
                    }
                }
                catch (newError) {
                    e = newError;
                }
            }
            if (this.errorEvent.hasSubscriptions()) {
                this.errorEvent.fire(e);
            }
            else {
                throw e;
            }
        }
    }
    exports.DuplexDataSource = DuplexDataSource;
    function processTransformDuplex(operations, result, direction) {
        return async (v) => {
            try {
                for (const operation of operations) {
                    switch (operation.operationType) {
                        case operator_model_js_3.OperationType.NOOP:
                        case operator_model_js_3.OperationType.MAP:
                            v =
                                direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM
                                    ? operation.operationDown(v)
                                    : operation.operationUp(v);
                            break;
                        case operator_model_js_3.OperationType.MAP_DELAY_FILTER:
                            const tmp = direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM
                                ? await operation.operationDown(v)
                                : await operation.operationUp(v);
                            if (tmp.cancelled) {
                                return;
                            }
                            else {
                                v = await tmp.item;
                            }
                            break;
                        case operator_model_js_3.OperationType.DELAY:
                        case operator_model_js_3.OperationType.MAP_DELAY:
                            v =
                                direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM
                                    ? await operation.operationDown(v)
                                    : await operation.operationUp(v);
                            break;
                        case operator_model_js_3.OperationType.DELAY_FILTER:
                            if (!(direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM
                                ? await operation.operationDown(v)
                                : await operation.operationUp(v))) {
                                return;
                            }
                            break;
                        case operator_model_js_3.OperationType.FILTER:
                            if (!(direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM
                                ? operation.operationDown(v)
                                : operation.operationUp(v))) {
                                return;
                            }
                            break;
                    }
                }
                if (direction === duplex_data_source_operators_js_1.DataFlow.DOWNSTREAM) {
                    result.updateDownstream(v);
                }
                else {
                    result.updateUpstream(v);
                }
            }
            catch (e) {
                result.emitError(e, direction);
            }
        };
    }
    exports.processTransformDuplex = processTransformDuplex;
});
define("src/stream/object_data_source", ["require", "exports", "src/aurum_server/aurum_server_client", "src/utilities/event_emitter", "src/stream/data_source", "src/stream/duplex_data_source"], function (require, exports, aurum_server_client_js_2, event_emitter_js_3, data_source_js_4, duplex_data_source_js_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectDataSource = void 0;
    class ObjectDataSource {
        constructor(initialData) {
            this.data = initialData;
            this.updateEvent = new event_emitter_js_3.EventEmitter();
            this.updateEventOnKey = new Map();
        }
        /**
         * Connects to an aurum-server exposed object datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
         * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server
         * @param  {AurumServerInfo} aurumServerInfo
         * @returns DataSource
         */
        static fromRemoteSource(aurumServerInfo, cancellation) {
            const result = new ObjectDataSource(undefined);
            (0, aurum_server_client_js_2.syncObjectDataSource)(result, aurumServerInfo, cancellation);
            return result;
        }
        static toObjectDataSource(value) {
            if (value instanceof ObjectDataSource) {
                return value;
            }
            else {
                return new ObjectDataSource(value);
            }
        }
        toString() {
            return this.data.toString();
        }
        /**
         * Remove all listeners
         */
        cancelAll() {
            this.updateEvent.cancelAll();
            this.updateEventOnKey.forEach((v) => v.cancelAll());
        }
        pickObject(key, cancellationToken) {
            if (typeof this.data[key] === 'object') {
                const subDataSource = new ObjectDataSource(this.data[key]);
                subDataSource.listen((change) => {
                    if (change.deleted) {
                        delete this.data[key][change.key];
                    }
                    else {
                        this.get(key)[change.key] = change.newValue;
                    }
                }, cancellationToken);
                this.listenOnKey(key, (v) => {
                    if (typeof v.newValue === 'object') {
                        if (v.newValue !== subDataSource.data) {
                            subDataSource.merge(v.newValue);
                        }
                    }
                    else {
                        subDataSource.clear();
                    }
                });
                return subDataSource;
            }
            else {
                throw new Error('Cannot pick a non object key');
            }
        }
        pickArray(key, cancellationToken) {
            var _a;
            if (Array.isArray(this.data[key])) {
                const subDataSource = new data_source_js_4.ArrayDataSource((_a = this.data) === null || _a === void 0 ? void 0 : _a[key]);
                subDataSource.listen((change) => {
                    this.set(key, change.newState);
                }, cancellationToken);
                this.listenOnKey(key, (v) => {
                    if (Array.isArray(v.newValue)) {
                        if (v.newValue.length !== subDataSource.length.value || !subDataSource.getData().every((item, index) => v.newValue[index] === item)) {
                            subDataSource.merge(v.newValue);
                        }
                    }
                    else {
                        subDataSource.clear();
                    }
                });
                return subDataSource;
            }
            else {
                throw new Error('Cannot pick a non array key');
            }
        }
        /**
         * Creates a datasource for a single key of the object
         * @param key
         * @param cancellationToken
         */
        pick(key, cancellationToken) {
            var _a;
            const subDataSource = new data_source_js_4.DataSource((_a = this.data) === null || _a === void 0 ? void 0 : _a[key]);
            subDataSource.listen(() => {
                this.set(key, subDataSource.value);
            }, cancellationToken);
            this.listenOnKey(key, (v) => {
                if (subDataSource.value !== v.newValue) {
                    subDataSource.update(v.newValue);
                }
            }, cancellationToken);
            return subDataSource;
        }
        /**
         * Creates a duplexdatasource for a single key of the object
         * @param key
         * @param cancellationToken
         */
        pickDuplex(key, cancellationToken) {
            var _a;
            const subDataSource = new duplex_data_source_js_1.DuplexDataSource((_a = this.data) === null || _a === void 0 ? void 0 : _a[key]);
            subDataSource.listenUpstream((v) => {
                this.set(key, v);
            });
            this.listenOnKey(key, (v) => {
                if (subDataSource.value !== v.newValue) {
                    subDataSource.updateDownstream(v.newValue);
                }
            }, cancellationToken);
            return subDataSource;
        }
        hasKey(key) {
            return this.data.hasOwnProperty(key);
        }
        applyObjectChange(change) {
            if (change.deleted && this.hasKey(change.key)) {
                this.delete(change.key);
            }
            else if (change.newValue !== this.get(change.key)) {
                this.set(change.key, change.newValue);
            }
        }
        /**
         * Listen to changes of the object
         */
        listen(callback, cancellationToken) {
            return this.updateEvent.subscribe(callback, cancellationToken).cancel;
        }
        map(mapper) {
            const stateMap = new Map();
            const result = new data_source_js_4.ArrayDataSource();
            this.listenAndRepeat((change) => {
                if (change.deleted && stateMap.has(change.key)) {
                    const item = stateMap.get(change.key);
                    result.remove(item);
                    stateMap.delete(change.key);
                }
                else if (stateMap.has(change.key)) {
                    const newItem = mapper(change.key, change.newValue);
                    result.replace(stateMap.get(change.key), newItem);
                    stateMap.set(change.key, newItem);
                }
                else if (!stateMap.has(change.key) && !change.deleted) {
                    const newItem = mapper(change.key, change.newValue);
                    result.push(newItem);
                    stateMap.set(change.key, newItem);
                }
            });
            return result;
        }
        /**
         * Same as listen but will immediately call the callback with the current value of each key
         */
        listenAndRepeat(callback, cancellationToken) {
            const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;
            for (const key in this.data) {
                callback({
                    key,
                    newValue: this.data[key],
                    oldValue: undefined,
                    deleted: false
                });
            }
            return c;
        }
        /**
         * Same as listenOnKey but will immediately call the callback with the current value first
         */
        listenOnKeyAndRepeat(key, callback, cancellationToken) {
            callback({
                key,
                newValue: this.data[key],
                oldValue: undefined
            });
            return this.listenOnKey(key, callback, cancellationToken);
        }
        /**
         * Listen to changes of a single key of the object
         */
        listenOnKey(key, callback, cancellationToken) {
            if (!this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.set(key, new event_emitter_js_3.EventEmitter());
            }
            const event = this.updateEventOnKey.get(key);
            return event.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Returns all the keys of the object in the source
         */
        keys() {
            return Object.keys(this.data);
        }
        /**
         * Returns all the values of the object in the source
         */
        values() {
            return Object.values(this.data);
        }
        /**
         * get the current value of a key of the object
         * @param key
         */
        get(key) {
            return this.data[key];
        }
        /**
         * delete a key from the object
         * @param key
         * @param value
         */
        delete(key) {
            if (this.hasKey(key)) {
                const old = this.data[key];
                delete this.data[key];
                this.updateEvent.fire({ oldValue: old, key, newValue: undefined, deleted: true });
                if (this.updateEventOnKey.has(key)) {
                    this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: undefined });
                }
            }
        }
        /**
         * set the value for a key of the object
         * @param key
         * @param value
         */
        set(key, value) {
            if (this.data[key] === value) {
                return;
            }
            const old = this.data[key];
            this.data[key] = value;
            this.updateEvent.fire({ oldValue: old, key, newValue: this.data[key] });
            if (this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: this.data[key] });
            }
        }
        /**
         * Merge the key value pairs of an object into this object non recursively
         * @param newData
         */
        assign(newData) {
            if (newData instanceof ObjectDataSource) {
                for (const key of newData.keys()) {
                    this.set(key, newData.data[key]);
                }
            }
            else {
                for (const key of Object.keys(newData)) {
                    this.set(key, newData[key]);
                }
            }
        }
        /**
         * Merge the key value pairs of an object into this object non recursively and delete properties that do not exist in the newData
         * @param newData
         */
        merge(newData) {
            var _a;
            const keys = new Set(Object.keys((_a = this.data) !== null && _a !== void 0 ? _a : {}));
            if (newData instanceof ObjectDataSource) {
                for (const key of newData.keys()) {
                    keys.delete(key);
                    this.set(key, newData.data[key]);
                }
            }
            else {
                for (const key of Object.keys(newData)) {
                    keys.delete(key);
                    this.set(key, newData[key]);
                }
            }
            for (const key of keys) {
                this.delete(key);
            }
        }
        /**
         * Deletes all keys
         */
        clear() {
            if (this.data == undefined) {
                return;
            }
            for (const key in this.data) {
                this.delete(key);
            }
        }
        getData() {
            return this.data;
        }
        /**
         * Returns a shallow copy of the object
         */
        toObject() {
            return { ...this.data };
        }
        /**
         * Returns a simplified version of this datasource
         */
        toDataSource() {
            const stream = new data_source_js_4.DataSource(this.data);
            this.listen((s) => {
                stream.update(this.data);
            });
            return stream;
        }
    }
    exports.ObjectDataSource = ObjectDataSource;
});
define("src/aurum_server/aurum_server_client", ["require", "exports", "src/utilities/cancellation_token"], function (require, exports, cancellation_token_js_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syncDuplexDataSource = exports.syncArrayDataSource = exports.syncDataSource = exports.syncMapDataSource = exports.syncObjectDataSource = exports.syncSetDataSource = exports.getRemoteFunction = exports.RemoteProtocol = void 0;
    var RemoteProtocol;
    (function (RemoteProtocol) {
        RemoteProtocol[RemoteProtocol["HEARTBEAT"] = 0] = "HEARTBEAT";
        RemoteProtocol[RemoteProtocol["LISTEN_DATASOURCE"] = 1] = "LISTEN_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_DATASOURCE_ERR"] = 2] = "LISTEN_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["UPDATE_DATASOURCE"] = 3] = "UPDATE_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_DATASOURCE_ERR"] = 4] = "UPDATE_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["CANCEL_DATASOURCE"] = 5] = "CANCEL_DATASOURCE";
        RemoteProtocol[RemoteProtocol["PERFORM_RPC"] = 6] = "PERFORM_RPC";
        RemoteProtocol[RemoteProtocol["PERFORM_RPC_ERR"] = 7] = "PERFORM_RPC_ERR";
        RemoteProtocol[RemoteProtocol["PERFORM_RPC_RESULT"] = 8] = "PERFORM_RPC_RESULT";
        RemoteProtocol[RemoteProtocol["PERFORM_RPC_RESULT_ERR"] = 9] = "PERFORM_RPC_RESULT_ERR";
        RemoteProtocol[RemoteProtocol["LISTEN_DUPLEX_DATASOURCE_ERR"] = 10] = "LISTEN_DUPLEX_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["LISTEN_DUPLEX_DATASOURCE"] = 11] = "LISTEN_DUPLEX_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_DUPLEX_DATASOURCE"] = 12] = "UPDATE_DUPLEX_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_DUPLEX_DATASOURCE_ERR"] = 13] = "UPDATE_DUPLEX_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["CANCEL_DUPLEX_DATASOURCE"] = 14] = "CANCEL_DUPLEX_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_ARRAY_DATASOURCE"] = 15] = "LISTEN_ARRAY_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_ARRAY_DATASOURCE_ERR"] = 16] = "LISTEN_ARRAY_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["UPDATE_ARRAY_DATASOURCE"] = 17] = "UPDATE_ARRAY_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_ARRAY_DATASOURCE_ERR"] = 18] = "UPDATE_ARRAY_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["CANCEL_ARRAY_DATASOURCE"] = 19] = "CANCEL_ARRAY_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_MAP_DATASOURCE"] = 20] = "LISTEN_MAP_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_MAP_DATASOURCE_ERR"] = 21] = "LISTEN_MAP_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["UPDATE_MAP_DATASOURCE"] = 22] = "UPDATE_MAP_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_MAP_DATASOURCE_ERR"] = 23] = "UPDATE_MAP_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["CANCEL_MAP_DATASOURCE"] = 24] = "CANCEL_MAP_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_OBJECT_DATASOURCE"] = 25] = "LISTEN_OBJECT_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_OBJECT_DATASOURCE_ERR"] = 26] = "LISTEN_OBJECT_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["UPDATE_OBJECT_DATASOURCE"] = 27] = "UPDATE_OBJECT_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_OBJECT_DATASOURCE_ERR"] = 28] = "UPDATE_OBJECT_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["CANCEL_OBJECT_DATASOURCE"] = 29] = "CANCEL_OBJECT_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_SET_DATASOURCE"] = 30] = "LISTEN_SET_DATASOURCE";
        RemoteProtocol[RemoteProtocol["LISTEN_SET_DATASOURCE_ERR"] = 31] = "LISTEN_SET_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["UPDATE_SET_DATASOURCE"] = 32] = "UPDATE_SET_DATASOURCE";
        RemoteProtocol[RemoteProtocol["UPDATE_SET_DATASOURCE_ERR"] = 33] = "UPDATE_SET_DATASOURCE_ERR";
        RemoteProtocol[RemoteProtocol["CANCEL_SET_DATASOURCE"] = 34] = "CANCEL_SET_DATASOURCE";
    })(RemoteProtocol = exports.RemoteProtocol || (exports.RemoteProtocol = {}));
    const pendingRPCResponses = new Map();
    function getRemoteFunction(aurumServerInfo, cancellation) {
        return syncFunction(aurumServerInfo, cancellation);
    }
    exports.getRemoteFunction = getRemoteFunction;
    function syncFunction(aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        return async (input) => {
            await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
            return new Promise((resolve, reject) => {
                const client = connections.get(key);
                if (!client) {
                    throw new Error('Client not connected');
                }
                return client.performRPC(input, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation).then(resolve, reject);
            });
        };
    }
    async function syncSetDataSource(source, aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
        connections.get(key).syncSetDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
    }
    exports.syncSetDataSource = syncSetDataSource;
    async function syncObjectDataSource(source, aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
        connections.get(key).syncObjectDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
    }
    exports.syncObjectDataSource = syncObjectDataSource;
    async function syncMapDataSource(source, aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
        connections.get(key).syncMapDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
    }
    exports.syncMapDataSource = syncMapDataSource;
    async function syncDataSource(source, aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
        connections.get(key).syncDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
    }
    exports.syncDataSource = syncDataSource;
    function makeKey(protocol, host) {
        return `${resolveProtocol(protocol)}://${resolveHost(host)}`;
    }
    async function syncArrayDataSource(source, aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
        connections.get(key).syncArrayDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
    }
    exports.syncArrayDataSource = syncArrayDataSource;
    async function syncDuplexDataSource(source, aurumServerInfo, cancellation) {
        const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
        connections.get(key).syncDuplexDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
    }
    exports.syncDuplexDataSource = syncDuplexDataSource;
    const connections = new Map();
    const pendingConnections = new Map();
    class AurumServerClient {
        constructor(connection) {
            this.masterToken = new cancellation_token_js_4.CancellationToken();
            this.connection = connection;
            this.synchedDataSources = new Map();
            this.synchedDuplexDataSources = new Map();
            this.synchedArrayDataSources = new Map();
            this.synchedMapDataSources = new Map();
            this.synchedObjectDataSources = new Map();
            this.synchedSetDataSources = new Map();
        }
        syncDataSource(source, id, authenticationToken, cancellation) {
            this.syncSource(cancellation, id, authenticationToken, source, this.synchedDataSources, RemoteProtocol.LISTEN_DATASOURCE, RemoteProtocol.CANCEL_DATASOURCE);
        }
        syncObjectDataSource(source, id, authenticationToken, cancellation) {
            this.syncSource(cancellation, id, authenticationToken, source, this.synchedObjectDataSources, RemoteProtocol.LISTEN_OBJECT_DATASOURCE, RemoteProtocol.CANCEL_OBJECT_DATASOURCE);
        }
        performRPC(input, endpointId, authenticationToken, cancellation) {
            return new Promise((resolve, reject) => {
                const uuid = Math.random().toString();
                pendingRPCResponses.set(uuid, { resolve, reject });
                this.connection.send(JSON.stringify({
                    type: RemoteProtocol.PERFORM_RPC,
                    token: authenticationToken,
                    id: endpointId,
                    value: input,
                    uuid
                }));
            });
        }
        syncSetDataSource(source, id, authenticationToken, cancellation) {
            this.syncSource(cancellation, id, authenticationToken, source, this.synchedSetDataSources, RemoteProtocol.LISTEN_SET_DATASOURCE, RemoteProtocol.CANCEL_SET_DATASOURCE);
        }
        syncMapDataSource(source, id, authenticationToken, cancellation) {
            this.syncSource(cancellation, id, authenticationToken, source, this.synchedMapDataSources, RemoteProtocol.LISTEN_MAP_DATASOURCE, RemoteProtocol.CANCEL_MAP_DATASOURCE);
        }
        syncArrayDataSource(source, id, authenticationToken, cancellation) {
            this.syncSource(cancellation, id, authenticationToken, source, this.synchedArrayDataSources, RemoteProtocol.LISTEN_ARRAY_DATASOURCE, RemoteProtocol.CANCEL_ARRAY_DATASOURCE);
        }
        syncDuplexDataSource(source, id, authenticationToken, cancellation) {
            this.syncSource(cancellation, id, authenticationToken, source, this.synchedDuplexDataSources, RemoteProtocol.LISTEN_DUPLEX_DATASOURCE, RemoteProtocol.CANCEL_DUPLEX_DATASOURCE);
            source.listenUpstream((v) => {
                this.connection.send(JSON.stringify({
                    type: RemoteProtocol.UPDATE_DUPLEX_DATASOURCE,
                    token: authenticationToken,
                    value: v,
                    id
                }));
            }, cancellation_token_js_4.CancellationToken.fromMultiple([cancellation, this.masterToken]));
        }
        syncSource(cancellation, id, authenticationToken, source, syncedSources, listenMessage, cancelMessage) {
            cancellation.addCancelable(() => {
                const listenersByAuth = syncedSources.get(id);
                const listeners = listenersByAuth.get(authenticationToken);
                listeners.listeners.splice(listeners.listeners.findIndex((s) => s.source === source));
                if (listeners.listeners.length === 0) {
                    listenersByAuth.delete(authenticationToken);
                    listeners.source.cancelAll();
                    this.connection.send(JSON.stringify({
                        type: cancelMessage,
                        id,
                        token: authenticationToken
                    }));
                }
            });
            if (!syncedSources.has(id)) {
                syncedSources.set(id, new Map());
            }
            if (!syncedSources.get(id).has(authenticationToken)) {
                this.connection.send(JSON.stringify({
                    type: listenMessage,
                    id,
                    token: authenticationToken
                }));
                syncedSources.get(id).set(authenticationToken, { source, listeners: [] });
            }
            syncedSources.get(id).get(authenticationToken).listeners.push({
                source,
                token: cancellation
            });
        }
        static connect(host, protocol) {
            let pendingToken = new cancellation_token_js_4.CancellationToken();
            let started = false;
            let latency = [0, 0, 0, 0, 0];
            let cycle = 0;
            let latencyTs;
            let lastBeat;
            return new Promise((resolve, reject) => {
                protocol = resolveProtocol(protocol);
                host = resolveHost(host);
                const connection = new WebSocket(`${protocol}://${host}`);
                const client = new AurumServerClient(connection);
                client.masterToken.addCancelable(() => {
                    connections.delete(makeKey(protocol, host));
                });
                pendingToken.setTimeout(() => {
                    connection.close(4001, 'no response');
                    reject();
                    client.masterToken.cancel();
                }, 5000);
                connection.addEventListener('message', (m) => {
                    lastBeat = Date.now();
                    try {
                        const msg = JSON.parse(m.data);
                        switch (msg.type) {
                            case RemoteProtocol.HEARTBEAT:
                                latency[cycle] = Date.now() - latencyTs;
                                if ((cycle + 1) % latency.length === 0) {
                                    console.log(`AurumServer latency: ${(latency.reduce((p, c) => p + c) / latency.length).toFixed(1)}ms`);
                                    cycle = 0;
                                }
                                else {
                                    cycle++;
                                }
                                break;
                            case RemoteProtocol.PERFORM_RPC_RESULT_ERR:
                            case RemoteProtocol.PERFORM_RPC_ERR:
                                pendingRPCResponses.get(msg.uuid).reject(new Error(msg.error));
                                pendingRPCResponses.delete(msg.uuid);
                                break;
                            case RemoteProtocol.PERFORM_RPC_RESULT:
                                pendingRPCResponses.get(msg.uuid).resolve(msg.result);
                                pendingRPCResponses.delete(msg.uuid);
                                break;
                            case RemoteProtocol.UPDATE_DATASOURCE:
                                if (client.synchedDataSources.has(msg.id)) {
                                    const byAuth = client.synchedDataSources.get(msg.id);
                                    for (const dss of byAuth.values()) {
                                        dss.source.update(msg.value);
                                    }
                                }
                                break;
                            case RemoteProtocol.UPDATE_ARRAY_DATASOURCE:
                                if (client.synchedArrayDataSources.has(msg.id)) {
                                    const byAuth = client.synchedArrayDataSources.get(msg.id);
                                    for (const dss of byAuth.values()) {
                                        const change = msg.change;
                                        dss.source.applyCollectionChange(change);
                                    }
                                }
                                break;
                            case RemoteProtocol.UPDATE_DUPLEX_DATASOURCE:
                                if (client.synchedDuplexDataSources.has(msg.id)) {
                                    const byAuth = client.synchedDuplexDataSources.get(msg.id);
                                    for (const dss of byAuth.values()) {
                                        dss.source.updateDownstream(msg.value);
                                    }
                                }
                                break;
                            case RemoteProtocol.UPDATE_MAP_DATASOURCE:
                                if (client.synchedMapDataSources.has(msg.id)) {
                                    const byAuth = client.synchedMapDataSources.get(msg.id);
                                    for (const dss of byAuth.values()) {
                                        dss.source.applyMapChange(msg.change);
                                    }
                                }
                                break;
                        }
                    }
                    catch (e) {
                        console.warn('Recieved malformed message from server');
                        console.warn(e);
                    }
                });
                connection.addEventListener('error', (e) => {
                    client.masterToken.cancel();
                    reject(e);
                });
                connection.addEventListener('open', () => {
                    pendingToken.cancel();
                    pendingToken = undefined;
                    started = true;
                    lastBeat = Date.now();
                    client.masterToken.setInterval(() => {
                        if (Date.now() - lastBeat > 10000) {
                            connection.close(4000, 'timeout');
                            return;
                        }
                        latencyTs = Date.now();
                        connection.send(JSON.stringify({
                            type: RemoteProtocol.HEARTBEAT
                        }));
                    }, 2500);
                    resolve(client);
                });
                connection.addEventListener('close', () => {
                    client.masterToken.cancel();
                    if (started) {
                        ensureConnection(makeKey(protocol, host), protocol, host).then((newClient) => {
                            newClient.migrate(client);
                        });
                    }
                    else {
                        reject();
                    }
                });
            });
        }
        migrate(client) {
            for (const id of client.synchedDataSources.keys()) {
                for (const auth of client.synchedDataSources.get(id).keys()) {
                    for (const { source, token } of client.synchedDataSources.get(id).get(auth).listeners) {
                        this.syncDataSource(source, id, auth, token);
                    }
                }
            }
            for (const id of client.synchedArrayDataSources.keys()) {
                for (const auth of client.synchedArrayDataSources.get(id).keys()) {
                    for (const { source, token } of client.synchedArrayDataSources.get(id).get(auth).listeners) {
                        this.syncArrayDataSource(source, id, auth, token);
                    }
                }
            }
            for (const id of client.synchedDuplexDataSources.keys()) {
                for (const auth of client.synchedDuplexDataSources.get(id).keys()) {
                    for (const { source, token } of client.synchedDuplexDataSources.get(id).get(auth).listeners) {
                        this.syncDuplexDataSource(source, id, auth, token);
                    }
                }
            }
            for (const id of client.synchedMapDataSources.keys()) {
                for (const auth of client.synchedMapDataSources.get(id).keys()) {
                    for (const { source, token } of client.synchedMapDataSources.get(id).get(auth).listeners) {
                        this.syncMapDataSource(source, id, auth, token);
                    }
                }
            }
            for (const id of client.synchedObjectDataSources.keys()) {
                for (const auth of client.synchedObjectDataSources.get(id).keys()) {
                    for (const { source, token } of client.synchedObjectDataSources.get(id).get(auth).listeners) {
                        this.syncObjectDataSource(source, id, auth, token);
                    }
                }
            }
            for (const id of client.synchedSetDataSources.keys()) {
                for (const auth of client.synchedSetDataSources.get(id).keys()) {
                    for (const { source, token } of client.synchedSetDataSources.get(id).get(auth).listeners) {
                        this.syncSetDataSource(source, id, auth, token);
                    }
                }
            }
            this.synchedDataSources = new Map();
            this.synchedDuplexDataSources = new Map();
            this.synchedArrayDataSources = new Map();
            this.synchedMapDataSources = new Map();
            this.synchedObjectDataSources = new Map();
            this.synchedSetDataSources = new Map();
        }
    }
    function resolveProtocol(protocol) {
        if (!protocol) {
            if (typeof location === 'undefined') {
                throw new Error('Protocol is not optional in non browser environments');
            }
            if (location.protocol.startsWith('https')) {
                protocol = 'wss';
            }
            else {
                protocol = 'ws';
            }
        }
        return protocol;
    }
    function resolveHost(host) {
        if (!host) {
            if (typeof location === 'undefined') {
                throw new Error('Host is not optional in non browser environments');
            }
            return location.host;
        }
        return host;
    }
    async function ensureConnection(key, protocol, host) {
        if (connections.has(key)) {
            return connections.get(key);
        }
        let backoff = 1000;
        if (pendingConnections.has(key)) {
            return pendingConnections.get(key);
        }
        else {
            const pendingConnection = new Promise((resolve) => {
                async function tryConnect() {
                    const p = AurumServerClient.connect(host, protocol);
                    try {
                        const client = await p;
                        connections.set(key, client);
                        pendingConnections.delete(key);
                        resolve(client);
                        backoff = 1000;
                    }
                    catch (e) {
                        setTimeout(() => {
                            backoff += 1000;
                            tryConnect();
                        }, backoff);
                    }
                }
                tryConnect();
            });
            pendingConnections.set(key, pendingConnection);
            return pendingConnection;
        }
    }
});
define("src/debug_mode", ["require", "exports", "src/utilities/event_emitter"], function (require, exports, event_emitter_js_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debugRegisterConsumer = exports.debugDeclareUpdate = exports.debugRegisterUnlink = exports.debugRegisterLink = exports.debugRegisterStream = exports.enableDebugMode = exports.enableDiagnosticMode = exports.diagnosticMode = exports.debugMode = void 0;
    exports.debugMode = false;
    exports.diagnosticMode = false;
    const customWindow = globalThis;
    let debugStreamData;
    function enableDiagnosticMode() {
        exports.diagnosticMode = true;
    }
    exports.enableDiagnosticMode = enableDiagnosticMode;
    /**
     * Initializes the debug features of aurum. Required for the use of aurum devtools
     * Run this function before creating any streams or any aurum components for best results
     * Enabling this harms performance and breaks backwards compatibility with some browsers
     * Do not enable in production
     */
    function enableDebugMode() {
        debugStreamData = [];
        exports.debugMode = true;
        setInterval(() => garbageCollect(), 60000);
        customWindow.__debugUpdates = new event_emitter_js_4.EventEmitter();
        customWindow.__debugNewSource = new event_emitter_js_4.EventEmitter();
        customWindow.__debugLinked = new event_emitter_js_4.EventEmitter();
        customWindow.__debugUnlinked = new event_emitter_js_4.EventEmitter();
        customWindow.__debugGetStreamData = () => debugStreamData.map(serializeStreamData);
    }
    exports.enableDebugMode = enableDebugMode;
    function serializeStreamData(ref) {
        let serializedValue;
        try {
            serializedValue = JSON.stringify(ref.value);
        }
        catch (e) {
            serializedValue = '[Unserializable]';
        }
        return {
            name: ref.name,
            value: serializedValue,
            children: ref.children,
            consumers: ref.consumers,
            id: ref.id,
            parents: ref.parents,
            stack: ref.stack,
            timestamp: ref.timestamp
        };
    }
    function debugRegisterStream(stream, stack) {
        const ref = {
            name: stream.name,
            value: stream.value,
            id: Math.random(),
            children: [],
            parents: [],
            stack,
            timestamp: Date.now(),
            reference: new WeakRef(stream),
            consumers: []
        };
        debugStreamData.push(ref);
        customWindow.__debugNewSource.fire({
            source: serializeStreamData(ref)
        });
    }
    exports.debugRegisterStream = debugRegisterStream;
    function debugRegisterLink(parent, child) {
        let pref = findDataByRef(parent);
        let cref = findDataByRef(child);
        if (!pref) {
            throw new Error('illegal state');
        }
        if (!cref) {
            throw new Error('illegal state');
        }
        pref.children.push(cref.id);
        cref.parents.push(pref.id);
        customWindow.__debugLinked.fire({
            child: serializeStreamData(cref),
            parent: serializeStreamData(pref)
        });
    }
    exports.debugRegisterLink = debugRegisterLink;
    function debugRegisterUnlink(parent, child) {
        let pref = findDataByRef(parent);
        let cref = findDataByRef(child);
        if (!pref) {
            throw new Error('illegal state');
        }
        if (!cref) {
            throw new Error('illegal state');
        }
        const cindex = pref.children.indexOf(cref.id);
        if (cindex === -1) {
            throw new Error('illegal state');
        }
        pref.children.splice(cindex, 1);
        const pindex = cref.parents.indexOf(pref.id);
        if (pindex === -1) {
            throw new Error('illegal state');
        }
        cref.parents.splice(cindex, 1);
        customWindow.__debugUnlinked.fire({
            child: serializeStreamData(cref),
            parent: serializeStreamData(pref)
        });
    }
    exports.debugRegisterUnlink = debugRegisterUnlink;
    function debugDeclareUpdate(source, value, stack) {
        let ref = findDataByRef(source);
        if (!ref) {
            throw new Error('illegal state');
        }
        ref.value = source.value;
        customWindow.__debugUpdates.fire({
            newValue: value,
            source: serializeStreamData(ref),
            stack
        });
    }
    exports.debugDeclareUpdate = debugDeclareUpdate;
    function debugRegisterConsumer(stream, consumer, consumerStack) {
        let ref = findDataByRef(stream);
        if (!ref) {
            throw new Error('illegal state');
        }
        ref.consumers.push({
            code: consumer,
            stack: consumerStack
        });
    }
    exports.debugRegisterConsumer = debugRegisterConsumer;
    function garbageCollect() {
        debugStreamData = debugStreamData.filter((dsd) => dsd.reference.deref() !== undefined);
    }
    function findDataByRef(target) {
        return debugStreamData.find((dsd) => dsd.reference.deref() === target);
    }
});
define("src/stream/data_source", ["require", "exports", "src/aurumjs", "src/aurum_server/aurum_server_client", "src/debug_mode", "src/utilities/cancellation_token", "src/utilities/event_emitter", "src/stream/data_source_operators", "src/stream/duplex_data_source", "src/stream/operator_model", "src/stream/stream"], function (require, exports, aurumjs_js_1, aurum_server_client_js_3, debug_mode_js_1, cancellation_token_js_5, event_emitter_js_5, data_source_operators_js_2, duplex_data_source_js_2, operator_model_js_4, stream_js_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetDataSource = exports.MapDataSource = exports.processTransform = exports.FilteredArrayView = exports.SortedArrayView = exports.UniqueArrayView = exports.SlicedArrayView = exports.ReversedArrayView = exports.MappedArrayView = exports.FlattenedArrayView = exports.ArrayDataSource = exports.DataSource = void 0;
    /**
     * Datasources wrap a value and allow you to update it in an observable way. Datasources can be manipulated like streams and can be bound directly in the JSX syntax and will update the html whenever the value changes
     */
    class DataSource {
        constructor(initialValue, name = 'RootDataSource') {
            this.name = name;
            this.value = initialValue;
            if (debug_mode_js_1.debugMode) {
                (0, debug_mode_js_1.debugRegisterStream)(this, new Error().stack);
            }
            this.primed = initialValue !== undefined;
            this.errorEvent = new event_emitter_js_5.EventEmitter();
            this.updateEvent = new event_emitter_js_5.EventEmitter();
        }
        toString() {
            return this.value.toString();
        }
        static toDataSource(value) {
            if (value instanceof DataSource) {
                return value;
            }
            else {
                return new DataSource(value);
            }
        }
        static fromEvent(event, cancellation) {
            const result = new DataSource();
            event.subscribe((v) => result.update(v), cancellation);
            return result;
        }
        /**
         * Connects to an aurum-server exposed datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
         * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated
         * @param  {AurumServerInfo} aurumServerInfo
         * @returns DataSource
         */
        static fromRemoteSource(aurumServerInfo, cancellation) {
            const result = new DataSource();
            (0, aurum_server_client_js_3.syncDataSource)(result, aurumServerInfo, cancellation);
            return result;
        }
        static fromMultipleSources(sources, cancellation) {
            const result = new DataSource();
            for (const s of sources) {
                if (debug_mode_js_1.debugMode) {
                    (0, debug_mode_js_1.debugRegisterLink)(s, result);
                }
                s.listenInternal((v) => result.update(v), cancellation);
            }
            result.name = `Combination of [${sources.map((v) => v.name).join(' & ')}]`;
            return result;
        }
        /**
         * Allows tapping into the stream and calls a function for each value.
         */
        tap(callback, cancellationToken) {
            this.listen((value) => {
                callback(value);
            }, cancellationToken);
            return this;
        }
        /**
         * Assign a function to handle errors and map them back to regular values. Rethrow the error in case you want to fallback to emitting error
         */
        handleErrors(callback) {
            this.errorHandler = callback;
            return this;
        }
        onError(callback, cancellationToken) {
            this.errorEvent.subscribe(callback, cancellationToken);
            return this;
        }
        emitError(e) {
            if (this.errorHandler) {
                try {
                    return this.update(this.errorHandler(e));
                }
                catch (newError) {
                    e = newError;
                }
            }
            if (this.errorEvent.hasSubscriptions()) {
                this.errorEvent.fire(e);
            }
            else {
                throw e;
            }
        }
        /**
         * Updates with the same value as the last value
         */
        repeatLast() {
            this.update(this.value);
            return this;
        }
        /**
         * Updates the value in the data source and calls the listen callback for all listeners
         * @param newValue new value for the data source
         */
        update(newValue) {
            this.primed = true;
            if (this.updating) {
                throw new Error('Problem in data source: Unstable value propagation. When updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed');
            }
            this.updating = true;
            this.value = newValue;
            this.updateEvent.fire(newValue);
            if (debug_mode_js_1.debugMode) {
                (0, debug_mode_js_1.debugDeclareUpdate)(this, newValue, new Error().stack);
            }
            this.updating = false;
        }
        /**
         * Updates the data source with a value if it has never had a value before
         */
        withInitial(value) {
            if (!this.primed) {
                this.update(value);
            }
            return this;
        }
        /**
         * Same as listen but will immediately call the callback with the current value first
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenAndRepeat(callback, cancellationToken) {
            if (this.primed) {
                callback(this.value);
            }
            return this.listen(callback, cancellationToken);
        }
        listenAndRepeatInternal(callback, cancellationToken, parent) {
            callback(this.value);
            return this.listenInternal(callback, cancellationToken, parent);
        }
        /**
         * Subscribes to the updates of the data stream
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listen(callback, cancellationToken) {
            if (debug_mode_js_1.debugMode) {
                (0, debug_mode_js_1.debugRegisterConsumer)(this, callback.toString(), new Error().stack);
            }
            return this.listenInternal(callback, cancellationToken);
        }
        listenInternal(callback, cancellationToken, parent) {
            const cancel = this.updateEvent.subscribe(callback, cancellationToken).cancel;
            return cancel;
        }
        /**
         * Subscribes to the updates of the data stream for a single update
         * @param callback Callback to call when value is updated
         * @param cancellationToken Optional token to control the cancellation of the subscription
         * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
         */
        listenOnce(callback, cancellationToken) {
            return this.updateEvent.subscribeOnce(callback, cancellationToken).cancel;
        }
        transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
            let token;
            const operations = [
                operationA,
                operationB,
                operationC,
                operationD,
                operationE,
                operationF,
                operationG,
                operationH,
                operationI,
                operationJ,
                operationK
            ].filter((e) => e && (e instanceof cancellation_token_js_5.CancellationToken ? ((token = e), false) : true));
            if (cancellationToken) {
                token = cancellationToken;
            }
            const result = new DataSource(undefined, this.name + ' ' + operations.map((v) => v.name).join(' '));
            if (debug_mode_js_1.debugMode) {
                (0, debug_mode_js_1.debugRegisterLink)(this, result);
            }
            (this.primed ? this.listenAndRepeatInternal : this.listenInternal).call(this, processTransform(operations, result), token);
            this.onError((e) => result.emitError(e), token);
            return result;
        }
        static fromAggregation(sources, combinator, cancellationToken) {
            var _a;
            cancellationToken = cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_5.CancellationToken();
            const aggregatedSource = new DataSource(combinator(...sources.map((s) => s === null || s === void 0 ? void 0 : s.value)));
            for (let i = 0; i < sources.length; i++) {
                (_a = sources[i]) === null || _a === void 0 ? void 0 : _a.listen(() => {
                    aggregatedSource.update(combinator(...sources.map((s) => s === null || s === void 0 ? void 0 : s.value)));
                }, cancellationToken);
            }
            return aggregatedSource;
        }
        aggregate(otherSources, combinator, cancellationToken) {
            var _a;
            cancellationToken = cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_5.CancellationToken();
            const aggregatedSource = new DataSource(combinator(this.value, ...otherSources.map((s) => s === null || s === void 0 ? void 0 : s.value)));
            for (let i = 0; i < otherSources.length; i++) {
                (_a = otherSources[i]) === null || _a === void 0 ? void 0 : _a.listen(() => {
                    aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s === null || s === void 0 ? void 0 : s.value)));
                }, cancellationToken);
            }
            this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s === null || s === void 0 ? void 0 : s.value))), cancellationToken);
            return aggregatedSource;
        }
        /**
         * Forwards all updates from this source to another
         * @param targetDataSource datasource to pipe the updates to
         * @param cancellationToken  Cancellation token to cancel the subscription the target datasource has to this datasource
         */
        pipe(targetDataSource, cancellationToken) {
            this.listen((v) => targetDataSource.update(v), cancellationToken);
            return this;
        }
        /**
         * Like aggregate except that it aggregates an array data source of datasources
         * @param data Second parent for the new source
         * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources
         */
        static dynamicAggregation(data, aggregate, cancellationToken) {
            cancellationToken = cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_5.CancellationToken();
            const session = new WeakMap();
            const result = new DataSource();
            data.listenAndRepeat((change) => {
                for (const item of change.items) {
                    listenToSubSource(item);
                }
                result.update(aggregate(data.getData().map((e) => e.value)));
            });
            data.onItemsAdded.subscribe((items) => {
                for (const item of items) {
                    listenToSubSource(item);
                }
            });
            data.onItemsRemoved.subscribe((items) => {
                for (const item of items) {
                    session.get(item).cancel();
                    session.delete(item);
                }
            });
            return result;
            function listenToSubSource(item) {
                session.set(item, new cancellation_token_js_5.CancellationToken());
                item.listen(() => {
                    result.update(aggregate(data.getData().map((e) => e.value)));
                }, session.get(item));
            }
        }
        /**
         * Like aggregate except that no combination method is needed as a result both parents must have the same type and the new stream just exposes the last update recieved from either parent
         * @param otherSource Second parent for the new source
         * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources
         */
        combine(otherSources, cancellationToken) {
            cancellationToken = cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_5.CancellationToken();
            let combinedDataSource;
            if (this.primed) {
                combinedDataSource = new DataSource(this.value);
            }
            else {
                combinedDataSource = new DataSource();
            }
            this.pipe(combinedDataSource, cancellationToken);
            for (const otherSource of otherSources) {
                otherSource.pipe(combinedDataSource, cancellationToken);
            }
            return combinedDataSource;
        }
        /**
         * Returns a promise that resolves when the next update occurs
         * @param cancellationToken
         */
        awaitNextUpdate(cancellationToken) {
            return new Promise((resolve) => {
                this.listenOnce((value) => resolve(value), cancellationToken);
            });
        }
        /**
         * Remove all listeners
         */
        cancelAll() {
            this.updateEvent.cancelAll();
        }
    }
    exports.DataSource = DataSource;
    class ArrayDataSource {
        constructor(initialData, name = 'RootArrayDataSource') {
            this.onItemsAdded = new event_emitter_js_5.EventEmitter();
            this.onItemsRemoved = new event_emitter_js_5.EventEmitter();
            this.name = name;
            if (initialData) {
                this.data = initialData.slice();
            }
            else {
                this.data = [];
            }
            this.lengthSource = new DataSource(this.data.length, this.name + '.length');
            this.updateEvent = new event_emitter_js_5.EventEmitter();
        }
        *[Symbol.iterator]() {
            yield* this.getData();
            return;
        }
        toSetDataSource(cancellationToken) {
            const result = new SetDataSource();
            this.listenAndRepeat((change) => {
                switch (change.operation) {
                    case 'add':
                        for (const item of change.items) {
                            result.add(item);
                        }
                        break;
                    case 'remove':
                        for (const item of change.items) {
                            if (!this.includes(item)) {
                                result.delete(item);
                            }
                        }
                        break;
                    case 'replace':
                        if (!this.includes(change.target)) {
                            result.delete(change.target);
                        }
                        for (const item of change.items) {
                            result.add(item);
                        }
                        break;
                    case 'merge':
                        result.clear();
                        for (const item of change.items) {
                            result.add(item);
                        }
                        break;
                }
            }, cancellationToken);
            return result;
        }
        toString() {
            return this.data.toString();
        }
        static fromFetchText(response, config = { itemSeperatorSequence: '\n' }) {
            const decoder = new TextDecoder('utf-8');
            const stream = new ArrayDataSource();
            const { onComplete, itemSeperatorSequence } = config;
            let buffer = '';
            const readerStream = response.body.getReader();
            function read(reader) {
                reader.read().then(({ done, value }) => {
                    if (!done) {
                        const data = (buffer + decoder.decode(value)).split(itemSeperatorSequence);
                        buffer = data.splice(data.length - 1, 1)[0];
                        stream.appendArray(data);
                        read(reader);
                    }
                    else {
                        if (buffer.length) {
                            stream.push(buffer);
                        }
                        onComplete === null || onComplete === void 0 ? void 0 : onComplete();
                    }
                });
            }
            read(readerStream);
            return stream;
        }
        static fromFetchJSON(response, config = {
            itemSeperatorSequence: '\n'
        }) {
            const decoder = new TextDecoder('utf-8');
            const stream = new ArrayDataSource();
            const { onParseError, onComplete, itemSeperatorSequence } = config;
            let buffer = '';
            const readerStream = response.body.getReader();
            function read(reader) {
                reader.read().then(({ done, value }) => {
                    if (!done) {
                        const data = (buffer + decoder.decode(value)).split(itemSeperatorSequence);
                        buffer = data.splice(data.length - 1, 1)[0];
                        for (const item of data) {
                            parseAndPush(item);
                        }
                        read(reader);
                    }
                    else {
                        if (buffer.length) {
                            parseAndPush(buffer);
                        }
                        onComplete === null || onComplete === void 0 ? void 0 : onComplete();
                    }
                });
            }
            read(readerStream);
            function parseAndPush(item) {
                try {
                    stream.push(JSON.parse(item));
                }
                catch (e) {
                    try {
                        stream.push(onParseError(item));
                    }
                    catch (e) {
                        // Ignore item if it can't be parsed and/or no error handler is provided
                    }
                }
            }
            return stream;
        }
        /**
         * Connects to an aurum-server exposed array datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
         * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated
         * @param  {AurumServerInfo} aurumServerInfo
         * @returns DataSource
         */
        static fromRemoteSource(aurumServerInfo, cancellation) {
            const result = new ArrayDataSource();
            (0, aurum_server_client_js_3.syncArrayDataSource)(result, aurumServerInfo, cancellation);
            return result;
        }
        static fromMultipleSources(sources, cancellationToken) {
            var _a;
            const boundaries = [0];
            const result = new ArrayDataSource(undefined, `ArrayDataSource of (${sources.reduce((p, c) => p + (c instanceof ArrayDataSource ? c.name + ' ' : ''), '')})`);
            for (let i = 0; i < sources.length; i++) {
                const item = sources[i];
                if (Array.isArray(item)) {
                    result.appendArray(item);
                }
                else if (item instanceof DataSource || item instanceof duplex_data_source_js_2.DuplexDataSource || item instanceof stream_js_2.Stream) {
                    let index = i;
                    item.transform((0, data_source_operators_js_2.dsDiff)(), (0, data_source_operators_js_2.dsTap)(({ newValue, oldValue }) => {
                        let sizeDiff = 0;
                        let oldSize = 0;
                        let newSize = 0;
                        if (Array.isArray(oldValue)) {
                            oldSize = oldValue.length;
                            sizeDiff -= oldValue.length;
                        }
                        else if (oldValue !== undefined) {
                            oldSize = 1;
                            sizeDiff--;
                        }
                        if (Array.isArray(newValue)) {
                            sizeDiff += newValue.length;
                            newSize = newValue.length;
                        }
                        else if (newValue !== undefined) {
                            sizeDiff++;
                            newSize = 1;
                        }
                        if (Array.isArray(newValue)) {
                            for (let i = 0; i < newValue.length; i++) {
                                if (i < oldSize) {
                                    result.set(boundaries[index] + i, newValue[i]);
                                }
                                else {
                                    result.insertAt(boundaries[index] + i, newValue[i]);
                                }
                            }
                        }
                        else if (newValue !== undefined) {
                            if (newSize <= oldSize) {
                                result.set(boundaries[index], newValue);
                            }
                            else {
                                result.insertAt(boundaries[index], newValue);
                            }
                        }
                        for (let i = 0; i < oldSize - newSize; i++) {
                            result.removeAt(boundaries[index] + newSize);
                        }
                        for (let i = index + 1; i < boundaries.length; i++) {
                            boundaries[i] += sizeDiff;
                        }
                    }), cancellationToken);
                }
                else {
                    result.appendArray((_a = sources[i].data) !== null && _a !== void 0 ? _a : []);
                    let index = i;
                    sources[i].listen((change) => {
                        switch (change.operationDetailed) {
                            case 'append':
                            case 'prepend':
                            case 'insert':
                                result.insertAt(change.index + boundaries[index], ...change.items);
                                for (let i = index + 1; i < boundaries.length; i++) {
                                    boundaries[i] += change.count;
                                }
                                break;
                            case 'remove':
                            case 'removeLeft':
                            case 'removeRight':
                            case 'clear':
                                result.removeRange(change.index + boundaries[index], change.index + boundaries[index] + change.count);
                                for (let i = index + 1; i < boundaries.length; i++) {
                                    boundaries[i] -= change.count;
                                }
                                break;
                            case 'merge':
                                const lengthDiff = change.newState.length + change.previousState.length;
                                result.removeRange(change.index + boundaries[index], change.index + boundaries[index] + change.previousState.length);
                                result.insertAt(change.index + boundaries[index], ...change.newState);
                                if (lengthDiff != 0) {
                                    for (let i = index + 1; i < boundaries.length; i++) {
                                        boundaries[i] += lengthDiff;
                                    }
                                }
                                break;
                            case 'replace':
                                result.set(change.index + boundaries[index], change.items[0]);
                                break;
                            case 'swap':
                                result.swap(change.index + boundaries[index], change.index2 + boundaries[index]);
                                break;
                        }
                    }, cancellationToken);
                }
                boundaries.push(result.length.value);
            }
            return result;
        }
        /**
         * Creates a new array data source where the type T is no longer wrapped by a DataSource however the values of these data sources are observed on the parent
         * array data source and changes are forwarded to the new array data source through array mutations. This makes it possible to use view methods such as map and filter
         * on the raw data instead of on data sources to cover highly dynamic use cases
         */
        static DynamicArrayDataSourceToArrayDataSource(arrayDataSource, cancellation) {
            const result = new ArrayDataSource();
            const session = new WeakMap();
            arrayDataSource.listenAndRepeat(({ operationDetailed, index, index2, count, items, previousState, newState, target }) => {
                switch (operationDetailed) {
                    case 'append':
                        for (const item of items) {
                            listenToItem(item);
                        }
                        result.appendArray(items.map((item) => (0, aurumjs_js_1.getValueOf)(item)));
                        break;
                    case 'prepend':
                        for (const item of items) {
                            listenToItem(item);
                        }
                        result.unshift(...items.map((item) => (0, aurumjs_js_1.getValueOf)(item)));
                        break;
                    case 'merge':
                        for (const item of previousState) {
                            stopLitenToItem(item);
                        }
                        for (const item of newState) {
                            listenToItem(item);
                        }
                        result.merge(newState.map((i) => (0, aurumjs_js_1.getValueOf)(i)));
                        break;
                    case 'insert':
                        for (const item of items) {
                            listenToItem(item);
                        }
                        result.insertAt(index, ...items.map((item) => (0, aurumjs_js_1.getValueOf)(item)));
                        break;
                    case 'clear':
                        for (const item of previousState) {
                            stopLitenToItem(item);
                        }
                        result.clear();
                        break;
                    case 'remove':
                        for (const item of items) {
                            stopLitenToItem(item);
                        }
                        result.removeRange(index, index + count);
                        break;
                    case 'removeLeft':
                        for (const item of items) {
                            stopLitenToItem(item);
                        }
                        result.removeLeft(count);
                        break;
                    case 'removeRight':
                        for (const item of items) {
                            stopLitenToItem(item);
                        }
                        result.removeRight(count);
                        break;
                    case 'replace':
                        stopLitenToItem(target);
                        listenToItem(items[0]);
                        result.set(index, (0, aurumjs_js_1.getValueOf)(items[0]));
                        break;
                    case 'swap':
                        result.swap(index, index2);
                        break;
                }
            }, cancellation);
            return result;
            function listenToItem(item) {
                if (!('listen' in item)) {
                    return;
                }
                session.set(item, new cancellation_token_js_5.CancellationToken());
                cancellation.chain(session.get(item));
                item.listen((value) => {
                    result.set(arrayDataSource.indexOf(item), value);
                }, session.get(item));
            }
            function stopLitenToItem(item) {
                if (session.has(item)) {
                    session.get(item).cancel();
                    session.delete(item);
                }
            }
        }
        static toArrayDataSource(value) {
            if (value instanceof ArrayDataSource) {
                return value;
            }
            else {
                return new ArrayDataSource(value);
            }
        }
        pipe(target, cancellation) {
            this.listenAndRepeat((c) => target.applyCollectionChange(c), cancellation);
        }
        /**
         * Remove all listeners
         */
        cancelAll() {
            this.onItemsAdded.cancelAll();
            this.onItemsRemoved.cancelAll();
            this.updateEvent.cancelAll();
        }
        /**
         * Same as listen but will immediately call the callback with an append of all existing elements first
         */
        listenAndRepeat(callback, cancellationToken) {
            if (this.data.length) {
                callback({
                    operation: 'add',
                    operationDetailed: 'append',
                    index: 0,
                    items: this.data,
                    newState: this.data,
                    count: this.data.length
                });
            }
            return this.listen(callback, cancellationToken);
        }
        /**
         * Sends a reset signal followed by an append with all items signal. This will force all the views of this source the synchronize can be useful in case your views rely on non pure transformation functions.
         */
        repeatCurrentState() {
            this.update({
                operation: 'remove',
                operationDetailed: 'clear',
                count: this.data.length,
                index: 0,
                items: this.data,
                newState: []
            });
            this.update({
                operation: 'add',
                operationDetailed: 'append',
                index: 0,
                items: this.data,
                newState: this.data,
                count: this.data.length
            });
        }
        listen(callback, cancellationToken) {
            return this.updateEvent.subscribe(callback, cancellationToken).cancel;
        }
        listenOnce(callback, cancellationToken) {
            return this.updateEvent.subscribeOnce(callback, cancellationToken).cancel;
        }
        /**
         * Applies the changes described in the colleciton change to the array. Useful for synchronizing array data sources over the network or workers by serializing the changes and sending them over
         * @param collectionChange
         */
        applyCollectionChange(collectionChange) {
            switch (collectionChange.operationDetailed) {
                case 'append':
                    this.appendArray(collectionChange.items);
                    break;
                case 'clear':
                    this.clear();
                    break;
                case 'insert':
                    this.insertAt(collectionChange.index, ...collectionChange.items);
                    break;
                case 'merge':
                    this.merge(collectionChange.items);
                    break;
                case 'prepend':
                    this.unshift(...collectionChange.items);
                    break;
                case 'remove':
                    this.removeRange(collectionChange.index, collectionChange.index + collectionChange.count);
                    break;
                case 'removeLeft':
                    this.removeLeft(collectionChange.count);
                    break;
                case 'removeRight':
                    this.removeRight(collectionChange.count);
                    break;
                case 'replace':
                    this.set(collectionChange.index, collectionChange.items[0]);
                    break;
                case 'swap':
                    this.swap(collectionChange.index, collectionChange.index2);
                    break;
            }
        }
        /**
         * Returns a promise that resolves when the next update occurs
         * @param cancellationToken
         */
        awaitNextUpdate(cancellationToken) {
            return new Promise((resolve) => {
                this.listenOnce((value) => resolve(value), cancellationToken);
            });
        }
        get length() {
            return this.lengthSource;
        }
        getData() {
            return this.data;
        }
        get(index) {
            return this.data[index];
        }
        set(index, item) {
            const old = this.data[index];
            if (old === item) {
                return;
            }
            this.data[index] = item;
            this.update({ operation: 'replace', operationDetailed: 'replace', target: old, count: 1, index, items: [item], newState: this.data });
            this.onItemsRemoved.fire([old]);
            this.onItemsAdded.fire([item]);
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
        }
        indexOf(item) {
            return this.data.indexOf(item);
        }
        find(predicate, thisArg) {
            return this.data.find(predicate, thisArg);
        }
        findIndex(predicate, thisArg) {
            return this.data.findIndex(predicate, thisArg);
        }
        lastIndexOf(item) {
            return this.data.lastIndexOf(item);
        }
        includes(item) {
            return this.data.includes(item);
        }
        replace(item, newItem) {
            const index = this.indexOf(item);
            if (index !== -1) {
                this.set(index, newItem);
            }
        }
        swap(indexA, indexB) {
            if (indexA === indexB) {
                return;
            }
            const itemA = this.data[indexA];
            const itemB = this.data[indexB];
            this.data[indexB] = itemA;
            this.data[indexA] = itemB;
            this.update({ operation: 'swap', operationDetailed: 'swap', index: indexA, index2: indexB, items: [itemA, itemB], newState: this.data });
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
        }
        swapItems(itemA, itemB) {
            if (itemA === itemB) {
                return;
            }
            const indexA = this.data.indexOf(itemA);
            const indexB = this.data.indexOf(itemB);
            if (indexA !== -1 && indexB !== -1) {
                this.data[indexB] = itemA;
                this.data[indexA] = itemB;
            }
            this.update({ operation: 'swap', operationDetailed: 'swap', index: indexA, index2: indexB, items: [itemA, itemB], newState: this.data });
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
        }
        appendArray(items) {
            if (!items || items.length === 0) {
                return;
            }
            if (items.length <= 65000) {
                //Push is significantly faster than concat but it is limited to 65535 items in one push
                this.data.push.apply(this.data, items);
            }
            else {
                console.warn('Appending over 65000 items in one go can lead to performance issues. Consider streaming your changes progressively');
                this.data = this.data.concat(items);
            }
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({
                operation: 'add',
                operationDetailed: 'append',
                count: items.length,
                index: this.data.length - items.length,
                items,
                newState: this.data
            });
            this.onItemsAdded.fire(items);
        }
        splice(index, deleteCount, ...insertion) {
            let removed = [];
            if (deleteCount > 0) {
                removed = this.removeAt(index, deleteCount);
            }
            if (insertion && insertion.length > 0) {
                this.insertAt(index, ...insertion);
            }
            return removed;
        }
        insertAt(index, ...items) {
            if (items.length === 0) {
                return;
            }
            this.data.splice(index, 0, ...items);
            this.update({
                operation: 'add',
                operationDetailed: 'insert',
                count: items.length,
                index,
                items,
                newState: this.data
            });
            this.onItemsAdded.fire(items);
            this.lengthSource.update(this.data.length);
        }
        push(...items) {
            this.appendArray(items);
        }
        unshift(...items) {
            this.data.unshift(...items);
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({ operation: 'add', operationDetailed: 'prepend', count: items.length, items, index: 0, newState: this.data });
            this.onItemsAdded.fire(items);
        }
        pop() {
            //This could technically just call removeRight(1) but removeRight is based on splicing which creates a new array so this can be significantly faster
            const item = this.data.pop();
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({
                operation: 'remove',
                operationDetailed: 'removeRight',
                count: 1,
                index: this.data.length,
                items: [item],
                newState: this.data
            });
            this.onItemsRemoved.fire([item]);
            return item;
        }
        merge(newData) {
            if (newData.length === 0) {
                return this.clear();
            }
            if (newData === this.data) {
                return;
            }
            const old = this.data;
            this.data = newData.slice();
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({
                operation: 'merge',
                operationDetailed: 'merge',
                previousState: old,
                index: 0,
                items: this.data,
                newState: this.data
            });
            this.onItemsRemoved.fire(old);
            this.onItemsAdded.fire(this.data);
        }
        removeRight(count) {
            const length = this.data.length;
            const result = this.data.splice(length - count, count);
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({ operation: 'remove', operationDetailed: 'removeRight', count, index: length - count, items: result, newState: this.data });
            this.onItemsRemoved.fire(result);
            return result;
        }
        removeLeft(count) {
            const removed = this.data.splice(0, count);
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({ operation: 'remove', operationDetailed: 'removeLeft', count, index: 0, items: removed, newState: this.data });
            this.onItemsRemoved.fire(removed);
        }
        removeAt(index, count = 1) {
            const removed = this.data.splice(index, count);
            this.update({ operation: 'remove', operationDetailed: 'remove', count: removed.length, index, items: removed, newState: this.data });
            this.onItemsRemoved.fire(removed);
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            return removed;
        }
        removeRange(start, end) {
            const removed = this.data.splice(start, end - start);
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({ operation: 'remove', operationDetailed: 'remove', count: removed.length, index: start, items: removed, newState: this.data });
            this.onItemsRemoved.fire(removed);
            return removed;
        }
        remove(item) {
            const index = this.data.indexOf(item);
            if (index !== -1) {
                return this.removeAt(index)[0];
            }
            else {
                return undefined;
            }
        }
        clear() {
            if (this.data.length === 0) {
                return;
            }
            const items = this.data;
            this.data = [];
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({
                operation: 'remove',
                operationDetailed: 'clear',
                count: items.length,
                index: 0,
                items,
                previousState: items,
                newState: this.data
            });
            this.onItemsRemoved.fire(items);
        }
        some(cb) {
            return this.data.some(cb);
        }
        every(cb) {
            return this.data.every(cb);
        }
        shift() {
            const item = this.data.shift();
            if (this.lengthSource.value !== this.data.length) {
                this.lengthSource.update(this.data.length);
            }
            this.update({ operation: 'remove', operationDetailed: 'removeLeft', items: [item], count: 1, index: 0, newState: this.data });
            this.onItemsRemoved.fire([item]);
            return item;
        }
        toArray() {
            return this.data.slice();
        }
        flat(cancellationToken, config) {
            const view = new FlattenedArrayView(this, 1, cancellationToken, this.name + '.flat()', config);
            return view;
        }
        reduce(reducer, initial, cancellationToken) {
            const result = new DataSource(initial);
            this.listenAndRepeat((change) => {
                switch (change.operation) {
                    case 'add':
                        let newVal = result.value;
                        for (const item of change.items) {
                            newVal = reducer(newVal, item);
                        }
                        result.update(newVal);
                        break;
                    case 'merge':
                    case 'replace':
                    case 'swap':
                    case 'remove':
                        let newVal2 = initial;
                        for (const item of change.newState) {
                            newVal2 = reducer(newVal2, item);
                        }
                        result.update(newVal2);
                        break;
                }
            }, cancellationToken);
            return result;
        }
        reverse(cancellationToken, config) {
            const view = new ReversedArrayView(this, cancellationToken, this.name + '.reverse()', config);
            return view;
        }
        sort(comparator = (a, b) => {
            if (a == undefined) {
                return 1;
            }
            if (b == undefined) {
                return -1;
            }
            if (typeof a === 'number' && typeof b === 'number') {
                return a - b;
            }
            else {
                return a.toString().localeCompare(b.toString());
            }
        }, dependencies = [], cancellationToken, config) {
            const view = new SortedArrayView(this, comparator, cancellationToken, this.name + '.sort()', config);
            dependencies.forEach((dep) => {
                dep.listen(() => view.refresh());
            }, cancellationToken);
            return view;
        }
        slice(start, end, cancellationToken, config) {
            if (typeof start === 'number') {
                start = new DataSource(start);
            }
            if (typeof end === 'number') {
                end = new DataSource(end);
            }
            if (end === undefined) {
                end = this.length;
            }
            return new SlicedArrayView(this, start, end, cancellationToken, this.name + '.slice()', config);
        }
        map(mapper, dependencies = [], cancellationToken, config) {
            const view = new MappedArrayView(this, mapper, cancellationToken, this.name + '.map()', config);
            dependencies.forEach((dep) => {
                dep.listen(() => view.refresh());
            }, cancellationToken);
            return view;
        }
        unique(cancellationToken, config) {
            return new UniqueArrayView(this, cancellationToken, this.name + '.unique()', config);
        }
        indexBy(key, cancellationToken, config) {
            const view = new MapDataSource();
            this.listenAndRepeat((change) => {
                var _a;
                if (!((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed))) {
                    switch (change.operation) {
                        case 'add':
                            for (const item of change.items) {
                                view.set(item[key], item);
                            }
                            break;
                        case 'remove':
                            for (const item of change.items) {
                                view.delete(item[key]);
                            }
                            break;
                        case 'replace':
                            view.delete(change.target[key]);
                            view.set(change.items[0][key], change.items[0]);
                            break;
                        case 'merge':
                            const oldKeys = new Set(view.keys());
                            const newKeys = new Set(change.items.map((item) => item[key]));
                            for (const oldKey of oldKeys) {
                                if (!newKeys.has(oldKey)) {
                                    view.delete(oldKey);
                                }
                            }
                            for (const newKey of newKeys) {
                                if (!oldKeys.has(newKey)) {
                                    view.set(newKey, change.items.find((item) => item[key] === newKey));
                                }
                            }
                            break;
                    }
                }
            }, cancellationToken);
            return view;
        }
        indexByProvider(provider, cancellationToken, config) {
            const view = new MapDataSource();
            this.listenAndRepeat((change) => {
                var _a;
                if (!((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed))) {
                    switch (change.operation) {
                        case 'add':
                            for (const item of change.items) {
                                view.set(provider(item), item);
                            }
                            break;
                        case 'remove':
                            for (const item of change.items) {
                                view.delete(provider(item));
                            }
                            break;
                        case 'replace':
                            view.delete(provider(change.target));
                            view.set(provider(change.items[0]), change.items[0]);
                            break;
                        case 'merge':
                            const oldKeys = new Set(view.keys());
                            const newKeys = new Set(change.items.map((item) => provider(item)));
                            for (const oldKey of oldKeys) {
                                if (!newKeys.has(oldKey)) {
                                    view.delete(oldKey);
                                }
                            }
                            for (const newKey of newKeys) {
                                if (!oldKeys.has(newKey)) {
                                    view.set(newKey, change.items.find((item) => provider(item) === newKey));
                                }
                            }
                            break;
                    }
                }
            }, cancellationToken);
            return view;
        }
        groupBy(key, cancellationToken, config) {
            const view = new MapDataSource();
            function handleRemove(item) {
                const list = view.get(item[key]);
                list.splice(list.indexOf(item), 1);
                if (list.length.value === 0) {
                    view.delete(item[key]);
                }
            }
            function handleAdd(item) {
                if (!view.has(item[key])) {
                    view.set(item[key], new ArrayDataSource());
                }
                view.get(item[key]).push(item);
            }
            this.listenAndRepeat((change) => {
                var _a;
                if (!((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed))) {
                    switch (change.operation) {
                        case 'add':
                            for (const item of change.items) {
                                handleAdd(item);
                            }
                            break;
                        case 'remove':
                            for (const item of change.items) {
                                handleRemove(item);
                            }
                            break;
                        case 'replace':
                            handleRemove(change.target);
                            handleAdd(change.items[0]);
                            break;
                        case 'merge':
                            const diff = change.previousState.filter((item) => !change.newState.includes(item));
                            for (const item of diff) {
                                if (view.has(item[key]) && view.get(item[key]).includes(item)) {
                                    handleRemove(item);
                                }
                            }
                            for (const item of change.items) {
                                if (!view.has(item[key])) {
                                    handleAdd(item);
                                }
                                else {
                                    if (!view.get(item[key]).includes(item)) {
                                        handleAdd(item);
                                    }
                                }
                            }
                            break;
                    }
                }
            }, cancellationToken);
            return view;
        }
        groupByProvider(provider, cancellationToken, config) {
            const view = new MapDataSource();
            function handleRemove(item) {
                const list = view.get(provider(item));
                list.splice(list.indexOf(item), 1);
                if (list.length.value === 0) {
                    view.delete(provider(item));
                }
            }
            function handleAdd(item) {
                if (!view.has(provider(item))) {
                    view.set(provider(item), new ArrayDataSource());
                }
                view.get(provider(item)).push(item);
            }
            this.listenAndRepeat((change) => {
                var _a;
                if (!((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed))) {
                    switch (change.operation) {
                        case 'add':
                            for (const item of change.items) {
                                handleAdd(item);
                            }
                            break;
                        case 'remove':
                            for (const item of change.items) {
                                handleRemove(item);
                            }
                            break;
                        case 'replace':
                            handleRemove(change.target);
                            handleAdd(change.items[0]);
                            break;
                        case 'merge':
                            const diff = change.previousState.filter((item) => !change.newState.includes(item));
                            for (const item of diff) {
                                if (view.has(provider(item)) && view.get(provider(item)).includes(item)) {
                                    handleRemove(item);
                                }
                            }
                            for (const item of change.items) {
                                if (!view.has(provider(item))) {
                                    handleAdd(item);
                                }
                                else {
                                    if (!view.get(provider(item)).includes(item)) {
                                        handleAdd(item);
                                    }
                                }
                            }
                            break;
                    }
                }
            }, cancellationToken);
            return view;
        }
        groupByMultiProvider(provider, cancellationToken, config) {
            const view = new MapDataSource();
            function handleRemove(item) {
                for (const i of provider(item)) {
                    const list = view.get(i);
                    list.splice(list.indexOf(item), 1);
                    if (list.length.value === 0) {
                        view.delete(i);
                    }
                }
            }
            function handleAdd(item) {
                for (const i of provider(item)) {
                    if (!view.has(i)) {
                        view.set(i, new ArrayDataSource());
                    }
                    view.get(i).push(item);
                }
            }
            this.listenAndRepeat((change) => {
                var _a;
                if (!((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed))) {
                    switch (change.operation) {
                        case 'add':
                            for (const item of change.items) {
                                handleAdd(item);
                            }
                            break;
                        case 'remove':
                            for (const item of change.items) {
                                handleRemove(item);
                            }
                            break;
                        case 'replace':
                            handleRemove(change.target);
                            handleAdd(change.items[0]);
                            break;
                        case 'merge':
                            const diff = change.previousState.filter((item) => !change.newState.includes(item));
                            for (const item of diff) {
                                for (const i of provider(item)) {
                                    if (view.has(i) && view.get(i).includes(item)) {
                                        handleRemove(item);
                                    }
                                }
                            }
                            for (const item of change.items) {
                                for (const i of provider(item)) {
                                    if (!view.has(i)) {
                                        handleAdd(item);
                                    }
                                    else {
                                        if (!view.get(i).includes(item)) {
                                            handleAdd(item);
                                        }
                                    }
                                }
                            }
                            break;
                    }
                }
            }, cancellationToken);
            return view;
        }
        filter(callback, dependencies = [], cancellationToken, config) {
            const view = new FilteredArrayView(this, callback, cancellationToken, this.name + '.filter()', config);
            dependencies.forEach((dep) => {
                dep.listen(() => view.refresh(), cancellationToken);
            });
            return view;
        }
        forEach(callbackfn) {
            return this.data.forEach(callbackfn);
        }
        update(change) {
            this.updateEvent.fire(change);
        }
    }
    exports.ArrayDataSource = ArrayDataSource;
    class FlattenedArrayView extends ArrayDataSource {
        constructor(parent, depth, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            super([], name);
            this.depth = depth;
            this.parent = parent;
            this.refresh();
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                switch (change.operationDetailed) {
                    case 'removeLeft':
                    case 'removeRight':
                    case 'remove':
                    case 'swap':
                    case 'replace':
                    case 'insert':
                    case 'merge':
                    case 'prepend':
                    case 'append':
                        this.refresh();
                        break;
                    case 'clear':
                        this.clear();
                        break;
                }
            }, cancellationToken);
        }
        refresh() {
            if (this.sessionToken) {
                this.sessionToken.cancel();
                this.sessionToken = undefined;
            }
            const data = this.parent.getData();
            if (data.length > 0) {
                if (data[0] instanceof ArrayDataSource) {
                    this.sessionToken = new cancellation_token_js_5.CancellationToken();
                    const combination = ArrayDataSource.fromMultipleSources(data);
                    combination.listen((change) => {
                        this.applyCollectionChange(change);
                    }, this.sessionToken);
                    this.merge(combination.getData());
                }
                else {
                    this.merge(data.flat(this.depth));
                }
            }
        }
    }
    exports.FlattenedArrayView = FlattenedArrayView;
    class MappedArrayView extends ArrayDataSource {
        constructor(parent, mapper, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            const initial = parent.getData().map(mapper);
            super(initial, name);
            this.parent = parent;
            this.mapper = mapper;
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                switch (change.operationDetailed) {
                    case 'removeLeft':
                        this.removeLeft(change.count);
                        break;
                    case 'removeRight':
                        this.removeRight(change.count);
                        break;
                    case 'remove':
                        for (let i = 0; i < change.items.length; i++) {
                            this.remove(this.data[change.index + i]);
                        }
                        break;
                    case 'clear':
                        this.clear();
                        break;
                    case 'prepend':
                        this.unshift(...change.items.map(this.mapper));
                        break;
                    case 'append':
                        this.appendArray(change.items.map(this.mapper));
                        break;
                    case 'insert':
                        this.insertAt(change.index, ...change.items.map(this.mapper));
                        break;
                    case 'swap':
                        this.swap(change.index, change.index2);
                        break;
                    case 'replace':
                        this.set(change.index, this.mapper(change.items[0]));
                        break;
                    case 'merge':
                        const old = this.data.slice();
                        const source = change.previousState.slice();
                        for (let i = 0; i < change.newState.length; i++) {
                            if (this.data.length <= i) {
                                this.data.push(this.mapper(change.newState[i]));
                                source.push(change.newState[i]);
                            }
                            else if (source[i] !== change.newState[i]) {
                                const index = source.indexOf(change.newState[i], i);
                                if (index !== -1) {
                                    const a = this.data[i];
                                    const b = this.data[index];
                                    this.data[i] = b;
                                    this.data[index] = a;
                                    const c = source[i];
                                    const d = source[index];
                                    source[i] = d;
                                    source[index] = c;
                                }
                                else {
                                    //@ts-ignore
                                    this.data.splice(i, 0, this.mapper(change.newState[i]));
                                    source.splice(i, 0, change.newState[i]);
                                }
                            }
                        }
                        if (this.data.length > change.newState.length) {
                            this.data.length = change.newState.length;
                        }
                        this.length.update(this.data.length);
                        this.update({
                            operation: 'merge',
                            operationDetailed: 'merge',
                            previousState: old,
                            index: 0,
                            items: this.data,
                            newState: this.data
                        });
                        this.onItemsRemoved.fire(old);
                        this.onItemsAdded.fire(this.data);
                        break;
                }
            }, cancellationToken);
        }
        refresh() {
            this.merge(this.parent.getData().map(this.mapper));
        }
    }
    exports.MappedArrayView = MappedArrayView;
    class ReversedArrayView extends ArrayDataSource {
        constructor(parent, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            const initial = parent.getData().slice().reverse();
            super(initial, name);
            this.parent = parent;
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                switch (change.operationDetailed) {
                    case 'removeLeft':
                        this.removeRight(change.count);
                        break;
                    case 'removeRight':
                        this.removeLeft(change.count);
                        break;
                    case 'remove':
                        for (const item of change.items) {
                            this.remove(item);
                        }
                        break;
                    case 'clear':
                        this.clear();
                        break;
                    case 'prepend':
                        this.appendArray(change.items.reverse());
                        break;
                    case 'append':
                        this.unshift(...change.items.reverse());
                        break;
                    case 'insert':
                        this.merge(change.newState.slice().reverse());
                        break;
                    case 'merge':
                        this.merge(change.items.slice().reverse());
                        break;
                    case 'swap':
                        this.merge(change.newState.slice().reverse());
                        break;
                    case 'replace':
                        this.merge(change.newState.slice().reverse());
                        break;
                }
            }, cancellationToken);
        }
        refresh() {
            this.merge(this.parent.getData().slice().reverse());
        }
    }
    exports.ReversedArrayView = ReversedArrayView;
    class SlicedArrayView extends ArrayDataSource {
        constructor(parent, start, end, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            const initial = parent.getData().slice(start.value, end.value);
            super(initial, name);
            start.listen(() => this.merge(parent.getData().slice(start.value, end.value)), cancellationToken);
            end.listen(() => this.merge(parent.getData().slice(start.value, end.value)), cancellationToken);
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                switch (change.operationDetailed) {
                    case 'removeLeft':
                    case 'removeRight':
                    case 'remove':
                    case 'append':
                    case 'prepend':
                    case 'insert':
                    case 'swap':
                    case 'replace':
                    case 'merge':
                        this.merge(parent.getData().slice(start.value, end.value));
                        break;
                    case 'clear':
                        this.clear();
                        break;
                }
            }, cancellationToken);
        }
    }
    exports.SlicedArrayView = SlicedArrayView;
    class UniqueArrayView extends ArrayDataSource {
        constructor(parent, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            const initial = Array.from(new Set(parent.getData()));
            super(initial, name);
            let filteredItems;
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                switch (change.operationDetailed) {
                    case 'removeLeft':
                    case 'removeRight':
                    case 'remove':
                        for (const item of change.items) {
                            if (!change.newState.includes(item)) {
                                this.remove(item);
                            }
                        }
                        break;
                    case 'clear':
                        this.clear();
                        break;
                    case 'prepend':
                        filteredItems = change.items.filter((e) => !this.data.includes(e));
                        this.unshift(...filteredItems);
                        break;
                    case 'append':
                        filteredItems = change.items.filter((e) => !this.data.includes(e));
                        this.appendArray(filteredItems);
                        break;
                    case 'insert':
                        filteredItems = change.items.filter((e) => !this.data.includes(e));
                        this.insertAt(change.index, ...filteredItems);
                        break;
                    case 'merge':
                        this.merge(Array.from(new Set(parent.getData())));
                        break;
                    case 'swap':
                        this.swap(change.index, change.index2);
                        break;
                    case 'replace':
                        if (this.data.includes(change.items[0])) {
                            this.remove(change.target);
                        }
                        else {
                            this.set(change.index, change.items[0]);
                        }
                        break;
                }
            }, cancellationToken);
        }
    }
    exports.UniqueArrayView = UniqueArrayView;
    class SortedArrayView extends ArrayDataSource {
        constructor(parent, comparator, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            const initial = parent.getData().slice().sort(comparator);
            super(initial, name);
            this.parent = parent;
            this.comparator = comparator;
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                switch (change.operationDetailed) {
                    case 'removeLeft':
                    case 'removeRight':
                    case 'remove':
                        for (const item of change.items) {
                            this.remove(item);
                        }
                        break;
                    case 'clear':
                        this.clear();
                        break;
                    case 'prepend':
                        this.unshift(...change.items);
                        this.data.sort(this.comparator);
                        break;
                    case 'append':
                        this.appendSorted(change.items);
                        break;
                    case 'insert':
                        this.appendSorted(change.items);
                        break;
                    case 'merge':
                        this.merge(change.items.slice().sort(this.comparator));
                        break;
                    case 'swap':
                        break;
                    case 'replace':
                        this.remove(change.target);
                        this.appendSorted(change.items);
                        break;
                }
            }, cancellationToken);
        }
        appendSorted(items) {
            if (items.length === 1 && this.data.length === 0) {
                this.push(items[0]);
            }
            else {
                this.merge(this.data.concat(items).sort(this.comparator));
            }
        }
        refresh() {
            this.merge(this.parent.getData().slice().sort(this.comparator));
        }
    }
    exports.SortedArrayView = SortedArrayView;
    class FilteredArrayView extends ArrayDataSource {
        constructor(parent, filter, cancellationToken = new cancellation_token_js_5.CancellationToken(), name, config) {
            if (Array.isArray(parent)) {
                parent = new ArrayDataSource(parent);
            }
            filter = filter !== null && filter !== void 0 ? filter : (() => true);
            const initial = parent.data.filter(filter);
            super(initial, name);
            this.parent = parent;
            this.viewFilter = filter;
            parent.listen((change) => {
                var _a;
                if ((_a = config === null || config === void 0 ? void 0 : config.ignoredOperations) === null || _a === void 0 ? void 0 : _a.includes(change.operationDetailed)) {
                    return;
                }
                let filteredItems;
                switch (change.operationDetailed) {
                    case 'clear':
                        this.clear();
                        break;
                    case 'removeLeft':
                    case 'removeRight':
                    case 'remove':
                        for (const item of change.items) {
                            this.remove(item);
                        }
                        break;
                    case 'prepend':
                        filteredItems = change.items.filter(this.viewFilter);
                        this.unshift(...filteredItems);
                        break;
                    case 'append':
                        filteredItems = change.items.filter(this.viewFilter);
                        this.appendArray(filteredItems);
                        break;
                    case 'insert':
                        filteredItems = change.items.filter(this.viewFilter);
                        this.insertAt(change.index, ...filteredItems);
                        break;
                    case 'merge':
                        this.merge(change.items.filter(this.viewFilter));
                        break;
                    case 'swap':
                        const indexA = this.data.indexOf(change.items[0]);
                        const indexB = this.data.indexOf(change.items[1]);
                        if (indexA !== -1 && indexB !== -1) {
                            this.swap(indexA, indexB);
                        }
                        break;
                    case 'replace':
                        const index = this.data.indexOf(change.target);
                        if (index !== -1) {
                            const acceptNew = this.viewFilter(change.items[0]);
                            if (acceptNew) {
                                this.set(index, change.items[0]);
                            }
                            else {
                                this.remove(change.target);
                            }
                        }
                        break;
                }
            }, cancellationToken);
        }
        /**
         * Replaces the filter function
         * @param filter
         * @returns returns new size of array view after applying filter
         */
        updateFilter(filter) {
            if (this.viewFilter === filter) {
                return this.data.length;
            }
            this.viewFilter = filter;
            this.refresh();
            return this.data.length;
        }
        /**
         * Recalculates the filter. Only needed if your filter function isn't pure and you know the result would be different if run again compared to before
         */
        refresh() {
            this.merge(this.parent.data.filter(this.viewFilter));
        }
    }
    exports.FilteredArrayView = FilteredArrayView;
    function processTransform(operations, result) {
        return async (v) => {
            try {
                for (const operation of operations) {
                    switch (operation.operationType) {
                        case operator_model_js_4.OperationType.NOOP:
                        case operator_model_js_4.OperationType.MAP:
                            v = operation.operation(v);
                            break;
                        case operator_model_js_4.OperationType.MAP_DELAY_FILTER:
                            const tmp = await operation.operation(v);
                            if (tmp.cancelled) {
                                return;
                            }
                            else {
                                v = await tmp.item;
                            }
                            break;
                        case operator_model_js_4.OperationType.DELAY:
                        case operator_model_js_4.OperationType.MAP_DELAY:
                            v = await operation.operation(v);
                            break;
                        case operator_model_js_4.OperationType.DELAY_FILTER:
                            if (!(await operation.operation(v))) {
                                return;
                            }
                            break;
                        case operator_model_js_4.OperationType.FILTER:
                            if (!operation.operation(v)) {
                                return;
                            }
                            break;
                    }
                }
                result.update(v);
            }
            catch (e) {
                result.emitError(e);
            }
        };
    }
    exports.processTransform = processTransform;
    class MapDataSource {
        constructor(initialData) {
            this.data = initialData !== null && initialData !== void 0 ? initialData : new Map();
            this.updateEvent = new event_emitter_js_5.EventEmitter();
            this.updateEventOnKey = new Map();
        }
        cancelAll() {
            this.updateEvent.cancelAll();
            this.updateEventOnKey.forEach((v, k) => v.cancelAll());
            this.updateEventOnKey.clear();
        }
        /**
         * Connects to an aurum-server exposed map datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
         * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server
         * @param  {AurumServerInfo} aurumServerInfo
         * @returns DataSource
         */
        static fromRemoteSource(aurumServerInfo, cancellation) {
            const result = new MapDataSource();
            (0, aurum_server_client_js_3.syncMapDataSource)(result, aurumServerInfo, cancellation);
            return result;
        }
        static fromMultipleMaps(maps, cancellationToken) {
            const result = new MapDataSource();
            let i = 0;
            for (const map of maps) {
                let index = i;
                result.assign(map);
                map.listen((change) => {
                    let isOverwritten = false;
                    for (let j = index + 1; j < maps.length; j++) {
                        if (maps[j].has(change.key)) {
                            isOverwritten = true;
                            break;
                        }
                    }
                    if (!isOverwritten) {
                        if (change.deleted) {
                            result.delete(change.key);
                        }
                        else {
                            result.set(change.key, change.newValue);
                        }
                    }
                }, cancellationToken);
            }
            return result;
        }
        pipe(target, cancellation) {
            this.listenAndRepeat((c) => target.applyMapChange(c), cancellation);
        }
        forEach(callbackfn, thisArg) {
            this.data.forEach(callbackfn, thisArg);
        }
        toString() {
            return this.data.toString();
        }
        static toMapDataSource(value) {
            if (value instanceof MapDataSource) {
                return value;
            }
            else {
                return new MapDataSource(value);
            }
        }
        applyMapChange(change) {
            if (change.deleted && this.data.has(change.key)) {
                this.delete(change.key);
            }
            else if (!change.deleted && !this.data.has(change.key)) {
                this.set(change.key, change.newValue);
            }
        }
        /**
         * Creates a datasource for a single key of the object
         * @param key
         * @param cancellationToken
         */
        pick(key, cancellationToken) {
            const subDataSource = new DataSource(this.data.get(key));
            this.listenOnKey(key, (v) => {
                subDataSource.update(v.newValue);
            }, cancellationToken);
            return subDataSource;
        }
        /**
         * Listen to changes of the object
         */
        listen(callback, cancellationToken) {
            return this.updateEvent.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Same as listen but will immediately call the callback with the current value of each key
         */
        listenAndRepeat(callback, cancellationToken) {
            const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;
            for (const key of this.data.keys()) {
                callback({
                    key,
                    newValue: this.data.get(key),
                    oldValue: undefined,
                    deleted: false
                });
            }
            return c;
        }
        map(mapper, cancellation) {
            const result = new MapDataSource();
            const lifeTimeMap = new Map();
            this.listenAndRepeat((change) => {
                if (change.deleted) {
                    lifeTimeMap.get(change.key).cancel();
                    lifeTimeMap.delete(change.key);
                    result.delete(change.key);
                }
                else {
                    const lifeTimeToken = new cancellation_token_js_5.CancellationToken();
                    if (lifeTimeMap.has(change.key)) {
                        lifeTimeMap.get(change.key).cancel();
                    }
                    lifeTimeMap.set(change.key, lifeTimeToken);
                    const newItem = mapper(change.key, change.newValue, lifeTimeToken);
                    result.set(change.key, newItem);
                }
            }, cancellation);
            return result;
        }
        toArrayDataSource(cancellation) {
            const stateMap = new Map();
            const result = new ArrayDataSource();
            this.listenAndRepeat((change) => {
                if (change.deleted && stateMap.has(change.key)) {
                    const item = stateMap.get(change.key);
                    result.remove(item);
                    stateMap.delete(change.key);
                }
                else if (stateMap.has(change.key)) {
                    const newItem = change.newValue;
                    result.replace(stateMap.get(change.key), newItem);
                    stateMap.set(change.key, newItem);
                }
                else if (!stateMap.has(change.key) && !change.deleted) {
                    const newItem = change.newValue;
                    result.push(newItem);
                    stateMap.set(change.key, newItem);
                }
            }, cancellation);
            return result;
        }
        clear() {
            for (const key of this.data.keys()) {
                this.delete(key);
            }
        }
        /**
         * Same as listenOnKey but will immediately call the callback with the current value first
         */
        listenOnKeyAndRepeat(key, callback, cancellationToken) {
            callback({
                key,
                newValue: this.data.get(key),
                oldValue: undefined
            });
            return this.listenOnKey(key, callback, cancellationToken);
        }
        /**
         * Listen to changes of a single key of the object
         */
        listenOnKey(key, callback, cancellationToken) {
            if (!this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.set(key, new event_emitter_js_5.EventEmitter());
            }
            const event = this.updateEventOnKey.get(key);
            return event.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Returns all the keys of the object in the source
         */
        keys() {
            return this.data.keys();
        }
        /**
         * Returns all the values of the object in the source
         */
        values() {
            return this.data.values();
        }
        /**
         * get the current value of a key of the object
         * @param key
         */
        get(key) {
            return this.data.get(key);
        }
        /**
         * check if map has a key
         * @param key
         */
        has(key) {
            return this.data.has(key);
        }
        /**
         * delete a key from the object
         * @param key
         * @param value
         */
        delete(key) {
            if (!this.has(key)) {
                return;
            }
            const old = this.data.get(key);
            this.data.delete(key);
            this.updateEvent.fire({ oldValue: old, key, newValue: undefined, deleted: true });
            if (this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: undefined });
            }
        }
        /**
         * set the value for a key of the object
         * @param key
         * @param value
         */
        set(key, value) {
            if (this.data.get(key) === value) {
                return;
            }
            const old = this.data.get(key);
            this.data.set(key, value);
            this.updateEvent.fire({ oldValue: old, key, newValue: this.data.get(key) });
            if (this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: this.data.get(key) });
            }
        }
        /**
         * Merge the key value pairs of an object into this object non recursively
         * @param newData
         */
        assign(newData) {
            for (const key of newData.keys()) {
                this.set(key, newData.get(key));
            }
        }
        /**
         * Returns a shallow copy of the map
         */
        toMap() {
            return new Map(this.data.entries());
        }
    }
    exports.MapDataSource = MapDataSource;
    class SetDataSource {
        constructor(initialData) {
            if (Array.isArray(initialData)) {
                this.data = new Set(initialData);
            }
            else {
                this.data = initialData !== null && initialData !== void 0 ? initialData : new Set();
            }
            this.updateEvent = new event_emitter_js_5.EventEmitter();
            this.updateEventOnKey = new Map();
        }
        /**
         * Connects to an aurum-server exposed set datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
         * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server
         * @param  {AurumServerInfo} aurumServerInfo
         * @returns DataSource
         */
        static fromRemoteSource(aurumServerInfo, cancellation) {
            const result = new SetDataSource(undefined);
            (0, aurum_server_client_js_3.syncSetDataSource)(result, aurumServerInfo, cancellation);
            return result;
        }
        /**
         * Remove all listeners
         */
        cancelAll() {
            this.updateEvent.cancelAll();
        }
        applySetChange(change) {
            if (change.exists && !this.has(change.key)) {
                this.data.add(change.key);
            }
            else if (!change.exists && this.has(change.key)) {
                this.data.delete(change.key);
            }
        }
        clear() {
            for (const key of this.data.keys()) {
                this.delete(key);
            }
        }
        isSubsetOf(otherSet) {
            for (const key of this) {
                if (!otherSet.has(key)) {
                    return false;
                }
            }
            return true;
        }
        isSupersetOf(otherSet) {
            for (const key of otherSet) {
                if (!this.has(key)) {
                    return false;
                }
            }
            return true;
        }
        isDisjointWith(otherSet) {
            for (const key of otherSet) {
                if (this.has(key)) {
                    return false;
                }
            }
            return true;
        }
        get size() {
            return this.data.size;
        }
        isIdenticalTo(otherSet) {
            if (this.size !== otherSet.size) {
                return false;
            }
            for (const key of otherSet) {
                if (!this.has(key)) {
                    return false;
                }
            }
            return true;
        }
        static toSetDataSource(value) {
            if (value instanceof SetDataSource) {
                return value;
            }
            else {
                return new SetDataSource(value);
            }
        }
        [Symbol.iterator]() {
            return this.data.keys();
        }
        /**
         * Returns an iterable of [v,v] pairs for every value `v` in the set.
         */
        entries() {
            return this.data.entries();
        }
        /**
         * Returns an iterable of values in the set.
         */
        values() {
            return this.data.values();
        }
        difference(otherSet, cancellationToken) {
            const result = new SetDataSource();
            const otherSetKeys = new Set(otherSet.keys());
            this.listenAndRepeat((change) => {
                if (change.exists && !otherSetKeys.has(change.key)) {
                    result.add(change.key);
                }
                if (!change.exists) {
                    result.delete(change.key);
                }
            }, cancellationToken);
            otherSet.listenAndRepeat((change) => {
                if (change.exists) {
                    result.delete(change.key);
                }
                if (!change.exists && this.has(change.key)) {
                    result.add(change.key);
                }
            }, cancellationToken);
            return result;
        }
        union(otherSet, cancellationToken) {
            const result = new SetDataSource();
            this.listenAndRepeat((change) => {
                if (change.exists) {
                    result.add(change.key);
                }
                else if (!otherSet.has(change.key)) {
                    result.delete(change.key);
                }
            }, cancellationToken);
            otherSet.listenAndRepeat((change) => {
                if (change.exists) {
                    result.add(change.key);
                }
                else if (!this.has(change.key)) {
                    result.delete(change.key);
                }
            }, cancellationToken);
            return result;
        }
        intersection(otherSet, cancellationToken) {
            const result = new SetDataSource();
            this.listenAndRepeat((change) => {
                if (change.exists && otherSet.has(change.key)) {
                    result.add(change.key);
                }
                else {
                    result.delete(change.key);
                }
            }, cancellationToken);
            otherSet.listenAndRepeat((change) => {
                if (change.exists && this.has(change.key)) {
                    result.add(change.key);
                }
                else {
                    result.delete(change.key);
                }
            }, cancellationToken);
            return result;
        }
        symmetricDifference(otherSet, cancellationToken) {
            const result = new SetDataSource();
            this.listenAndRepeat((change) => {
                if (change.exists && !otherSet.has(change.key)) {
                    result.add(change.key);
                }
                else if (!change.exists && otherSet.has(change.key)) {
                    result.add(change.key);
                }
                else if (change.exists && otherSet.has(change.key)) {
                    result.delete(change.key);
                }
                else if (!change.exists && !otherSet.has(change.key)) {
                    result.delete(change.key);
                }
            }, cancellationToken);
            otherSet.listenAndRepeat((change) => {
                if (change.exists && !this.has(change.key)) {
                    result.add(change.key);
                }
                else if (!change.exists && this.has(change.key)) {
                    result.add(change.key);
                }
                else if (change.exists && this.has(change.key)) {
                    result.delete(change.key);
                }
                else if (!change.exists && !this.has(change.key)) {
                    result.delete(change.key);
                }
            }, cancellationToken);
            return result;
        }
        toString() {
            return this.data.toString();
        }
        /**
         * Creates a datasource for a single key of the object
         * @param key
         * @param cancellationToken
         */
        pick(key, cancellationToken) {
            const subDataSource = new DataSource(this.data.has(key));
            this.listenOnKey(key, (v) => {
                subDataSource.update(v);
            }, cancellationToken);
            return subDataSource;
        }
        /**
         * Listen to changes of the object
         */
        listen(callback, cancellationToken) {
            return this.updateEvent.subscribe(callback, cancellationToken).cancel;
        }
        /**
         * Same as listen but will immediately call the callback with the current value of each key
         */
        listenAndRepeat(callback, cancellationToken) {
            const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;
            for (const key of this.data.keys()) {
                callback({
                    key,
                    exists: true
                });
            }
            return c;
        }
        /**
         * Same as listenOnKey but will immediately call the callback with the current value first
         */
        listenOnKeyAndRepeat(key, callback, cancellationToken) {
            callback(this.has(key));
            return this.listenOnKey(key, callback, cancellationToken);
        }
        /**
         * Listen to changes of a single key of the object
         */
        listenOnKey(key, callback, cancellationToken) {
            if (!this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.set(key, new event_emitter_js_5.EventEmitter());
            }
            const event = this.updateEventOnKey.get(key);
            return event.subscribe(callback, cancellationToken).cancel;
        }
        toArrayDataSource(cancellationToken) {
            return this.map((key) => key, cancellationToken);
        }
        map(mapper, cancellationToken) {
            const stateMap = new Map();
            const result = new ArrayDataSource();
            this.listenAndRepeat((change) => {
                if (!change.exists && stateMap.has(change.key)) {
                    const item = stateMap.get(change.key);
                    result.remove(item);
                    stateMap.delete(change.key);
                }
                else if (!stateMap.has(change.key) && change.exists) {
                    const newItem = mapper(change.key);
                    result.push(newItem);
                    stateMap.set(change.key, newItem);
                }
            }, cancellationToken);
            return result;
        }
        /**
         * Returns all the keys of the object in the source
         */
        keys() {
            return this.data.keys();
        }
        /**
         * check if map has a key
         * @param key
         */
        has(key) {
            return this.data.has(key);
        }
        /**
         * delete a key from the object
         * @param key
         * @param value
         */
        delete(key) {
            if (this.has(key)) {
                this.data.delete(key);
                this.updateEvent.fire({ key, exists: false });
                if (this.updateEventOnKey.has(key)) {
                    this.updateEventOnKey.get(key).fire(false);
                }
            }
        }
        /**
         * set the value for a key of the object
         * @param key
         * @param value
         */
        add(key) {
            if (this.data.has(key)) {
                return;
            }
            this.data.add(key);
            this.updateEvent.fire({ key, exists: true });
            if (this.updateEventOnKey.has(key)) {
                this.updateEventOnKey.get(key).fire(true);
            }
        }
        /**
         * Merge the key value pairs of an object into this object non recursively
         * @param newData
         */
        assign(newData) {
            for (const key of newData.keys()) {
                this.add(key);
            }
        }
        /**
         * Returns a shallow copy of the set
         */
        toSet() {
            return new Set(this.data.keys());
        }
        toArray() {
            return Array.from(this.data.keys());
        }
    }
    exports.SetDataSource = SetDataSource;
});
define("src/utilities/common", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/utilities/classname", ["require", "exports", "src/stream/data_source", "src/stream/duplex_data_source"], function (require, exports, data_source_js_5, duplex_data_source_js_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineAttribute = exports.combineClass = exports.aurumClassName = void 0;
    function aurumClassName(data, cancellationToken) {
        const result = [];
        for (const key in data) {
            if (data[key]) {
                if (data[key] instanceof data_source_js_5.DataSource || data[key] instanceof duplex_data_source_js_3.DuplexDataSource) {
                    const source = data[key];
                    const mappedSource = new data_source_js_5.DataSource(source.value ? key : '');
                    source.listen((value) => {
                        mappedSource.update(value ? key : '');
                    }, cancellationToken);
                    result.push(mappedSource);
                }
                else {
                    result.push(key);
                }
            }
        }
        return result;
    }
    exports.aurumClassName = aurumClassName;
    function combineClass(cancellationToken, ...args) {
        args = args.filter((e) => !!e);
        if (args.length < 2) {
            return args[0];
        }
        const constants = [];
        const sources = [];
        resolveConstants(args);
        function resolveConstants(args) {
            for (const arg of args) {
                if (typeof arg === 'string') {
                    constants.push(arg);
                }
                if (Array.isArray(arg)) {
                    resolveConstants(arg);
                }
                if (arg instanceof data_source_js_5.DataSource || arg instanceof duplex_data_source_js_3.DuplexDataSource) {
                    sources.push(arg);
                }
            }
        }
        if (sources.length) {
            return sources[0].aggregate(sources.slice(1), (...data) => {
                if (constants.length) {
                    return data.flat().concat(constants);
                }
                else {
                    return data.flat();
                }
            }, cancellationToken);
        }
        else {
            return constants;
        }
    }
    exports.combineClass = combineClass;
    function combineAttribute(cancellationToken, ...args) {
        const constants = [];
        const sources = [];
        for (const attr of args) {
            if (typeof attr === 'string' || typeof attr === 'boolean') {
                constants.push(attr);
            }
            if (attr instanceof data_source_js_5.DataSource || attr instanceof duplex_data_source_js_3.DuplexDataSource) {
                sources.push(attr);
            }
        }
        if (sources.length) {
            return sources[0].aggregate(sources.slice(1), (...data) => {
                if (constants.length) {
                    return data.concat(constants).join(' ');
                }
                else {
                    return data.join(' ');
                }
            }, cancellationToken);
        }
        else {
            return constants.join(' ');
        }
    }
    exports.combineAttribute = combineAttribute;
});
define("src/rendering/aurum_element", ["require", "exports", "src/debug_mode", "src/stream/data_source", "src/stream/duplex_data_source", "src/utilities/cancellation_token", "src/utilities/event_emitter", "src/utilities/classname"], function (require, exports, debug_mode_js_2, data_source_js_6, duplex_data_source_js_4, cancellation_token_js_6, event_emitter_js_6, classname_js_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingularAurumElement = exports.ArrayAurumElement = exports.createAPI = exports.renderInternal = exports.AurumElement = exports.createLifeCycle = exports.nodeData = exports.aurumElementModelIdentitiy = exports.createRenderSession = void 0;
    function createRenderSession() {
        const session = {
            attachCalls: [],
            sessionToken: new cancellation_token_js_6.CancellationToken(() => {
                for (const token of session.tokens) {
                    token.cancel();
                }
            }),
            tokens: []
        };
        return session;
    }
    exports.createRenderSession = createRenderSession;
    exports.aurumElementModelIdentitiy = Symbol('AurumElementModel');
    exports.nodeData = new WeakMap();
    function createLifeCycle() {
        const lc = {
            attach: new event_emitter_js_6.EventEmitter(),
            detach: new event_emitter_js_6.EventEmitter(),
            onAttach() {
                lc.attach.fire();
            },
            onDetach() {
                lc.detach.fire();
            }
        };
        return lc;
    }
    exports.createLifeCycle = createLifeCycle;
    class AurumElement {
        constructor(dataSource, api) {
            this.disposed = false;
            this.children = [];
            this.api = api;
            this.api.onAttach(() => {
                if (this.hostNode === undefined) {
                    throw new Error('illegal state: Attach fired but not actually attached');
                }
                this.render(dataSource);
            });
        }
        dispose() {
            if (this.disposed) {
                return;
            }
            if (this.hostNode.isConnected) {
                this.clearContent();
                this.contentStartMarker.remove();
                this.contentEndMarker.remove();
            }
            this.disposed = true;
        }
        attachToDom(node, index) {
            if (this.hostNode) {
                throw new Error('Aurum Element is already attached');
            }
            const id = AurumElement.id++;
            this.hostNode = node;
            this.contentStartMarker = document.createComment('START Aurum Node ' + id);
            //@ts-ignore
            this.contentStartMarker.owner = this;
            this.contentEndMarker = document.createComment('END Aurum Node ' + id);
            if (index >= node.childNodes.length) {
                node.appendChild(this.contentStartMarker);
                node.appendChild(this.contentEndMarker);
            }
            else {
                node.insertBefore(this.contentStartMarker, node.childNodes[index]);
                node.insertBefore(this.contentEndMarker, node.childNodes[index + 1]);
            }
        }
        getStartIndex() {
            return this.getWorkIndex() - 1;
        }
        getWorkIndex() {
            if (this.lastStartIndex !== undefined && this.hostNode.childNodes[this.lastStartIndex] === this.contentStartMarker) {
                return this.lastStartIndex + 1;
            }
            for (let i = 0; i < this.hostNode.childNodes.length; i++) {
                if (this.hostNode.childNodes[i] === this.contentStartMarker) {
                    this.lastStartIndex = i;
                    return i + 1;
                }
            }
            return -1;
        }
        getLastIndex() {
            if (this.lastEndIndex !== undefined && this.hostNode.childNodes[this.lastEndIndex] === this.contentEndMarker) {
                return this.lastEndIndex;
            }
            for (let i = 0; i < this.hostNode.childNodes.length; i++) {
                if (this.hostNode.childNodes[i] === this.contentEndMarker) {
                    this.lastEndIndex = i;
                    return i;
                }
            }
            return -1;
        }
        clearContent() {
            if (this.hostNode === undefined) {
                throw new Error('illegal state: Aurum element was not attched to anything');
            }
            let workIndex = this.getWorkIndex();
            while (this.hostNode.childNodes[workIndex] !== this.contentEndMarker) {
                if (!(this.hostNode.childNodes[workIndex] instanceof Comment)) {
                    this.hostNode.removeChild(this.hostNode.childNodes[workIndex]);
                }
                else {
                    //@ts-ignore
                    if (this.hostNode.childNodes[workIndex].owner.disposed) {
                        break;
                    }
                    //@ts-ignore
                    this.hostNode.childNodes[workIndex].owner.dispose();
                }
            }
        }
        updateDom() {
            var _a;
            const workIndex = this.getWorkIndex();
            let i;
            let offset = 0;
            for (i = 0; i < this.children.length; i++) {
                const child = this.children[i];
                if (child === undefined || child === null) {
                    offset--;
                    continue;
                }
                if (child === this.hostNode.childNodes[i + workIndex + offset]) {
                    continue;
                }
                if (child instanceof AurumElement) {
                    if (!child.hostNode) {
                        child.attachToDom(this.hostNode, i + workIndex + offset);
                    }
                    if (child.getStartIndex() === i + workIndex + offset) {
                        offset += child.getLastIndex() - i - offset - workIndex;
                    }
                    else {
                        let start = child.getStartIndex();
                        let end = child.getLastIndex();
                        for (let ptr = start, swapIteration = 0; ptr <= end; ptr++, swapIteration++) {
                            const itemA = this.hostNode.childNodes[i + workIndex + offset + swapIteration];
                            const itemB = this.hostNode.childNodes[ptr];
                            const parentA = itemA.parentNode;
                            const siblingA = itemA.nextSibling === itemB ? itemB : itemA.nextSibling;
                            itemB.parentNode.insertBefore(itemA, itemB);
                            parentA.insertBefore(itemB, siblingA);
                        }
                        offset += child.getLastIndex() - i - offset - workIndex;
                    }
                    continue;
                }
                if (this.hostNode.childNodes[i + workIndex + offset] !== this.contentEndMarker &&
                    this.hostNode.childNodes[i + workIndex + offset] !== this.children[i] &&
                    this.hostNode.childNodes[i + workIndex + offset] !== ((_a = this.children[i + 1]) === null || _a === void 0 ? void 0 : _a.contentStartMarker)) {
                    if (child instanceof HTMLElement || child instanceof Text) {
                        this.hostNode.removeChild(this.hostNode.childNodes[i + workIndex + offset]);
                        if (this.hostNode.childNodes[i + workIndex + offset]) {
                            this.lastEndIndex++;
                            this.hostNode.insertBefore(child, this.hostNode.childNodes[i + workIndex + offset]);
                        }
                        else {
                            this.lastEndIndex++;
                            this.hostNode.appendChild(child);
                        }
                    }
                    else {
                        throw new Error('not implemented');
                    }
                }
                else {
                    if (child instanceof HTMLElement || child instanceof Text) {
                        if (this.hostNode.childNodes[i + workIndex + offset]) {
                            this.lastEndIndex++;
                            this.hostNode.insertBefore(child, this.hostNode.childNodes[i + workIndex + offset]);
                        }
                        else {
                            this.lastEndIndex++;
                            this.hostNode.appendChild(child);
                        }
                    }
                    else {
                        throw new Error('not implemented');
                    }
                }
            }
            while (this.hostNode.childNodes[i + workIndex + offset] !== this.contentEndMarker) {
                this.lastEndIndex--;
                this.hostNode.removeChild(this.hostNode.childNodes[i + workIndex + offset]);
            }
        }
    }
    exports.AurumElement = AurumElement;
    AurumElement.id = 1;
    /**
     * @internal
     */
    function renderInternal(element, session, prerendering = false) {
        var _a;
        if (element == undefined) {
            return undefined;
        }
        if (Array.isArray(element)) {
            const result = [];
            for (const item of element) {
                const rendered = renderInternal(item, session, prerendering);
                // Flatten the rendered content into a single array to avoid having to iterate over nested arrays later
                if (rendered !== undefined && rendered !== null) {
                    if (Array.isArray(rendered)) {
                        result.push(...rendered);
                    }
                    else {
                        result.push(rendered);
                    }
                }
            }
            return result;
        }
        if (!prerendering) {
            const type = typeof element;
            if (type === 'string') {
                return document.createTextNode(element);
            }
            else if (type === 'number' || type === 'bigint' || type === 'boolean') {
                return document.createTextNode(element.toString());
            }
            if (element instanceof Promise) {
                const ds = new data_source_js_6.DataSource();
                element.then((val) => {
                    ds.update(val);
                });
                const result = new SingularAurumElement(ds, createAPI(session));
                return result;
            }
            else if (element instanceof data_source_js_6.DataSource || element instanceof duplex_data_source_js_4.DuplexDataSource) {
                const result = new SingularAurumElement(element, createAPI(session));
                return result;
            }
            else if (element instanceof data_source_js_6.ArrayDataSource) {
                const result = new ArrayAurumElement(element, createAPI(session));
                return result;
            }
        }
        if (element[exports.aurumElementModelIdentitiy]) {
            const model = element;
            let api;
            //Optimization: skip creating API for no props basic html nodes because they are by far the most frequent and this can yield a noticable performance increase
            if (!model.isIntrinsic || model.props) {
                api = createAPI(session);
            }
            else {
                api = {
                    renderSession: session
                };
            }
            if (!model.isIntrinsic && debug_mode_js_2.diagnosticMode) {
                console.log(`Rendering ${model.name}`);
                api.onAttach(() => {
                    console.log(`Attaching ${model.name}`);
                });
                api.onDetach(() => {
                    console.log(`Detaching ${model.name}`);
                });
            }
            let componentResult;
            if (model.isIntrinsic) {
                componentResult = model.factory(model.props, model.children, api);
            }
            else {
                componentResult = model.factory((_a = model.props) !== null && _a !== void 0 ? _a : {}, model.children, api);
            }
            return renderInternal(componentResult, session, prerendering);
        }
        // Unsupported types are returned as is in hope that a transclusion component will transform it into something compatible
        return element;
    }
    exports.renderInternal = renderInternal;
    /**
     * @internal
     */
    function createAPI(session) {
        let token = undefined;
        const api = {
            renderSession: session,
            synchronizeLifeCycle(lifeCycle) {
                api.onAttach(() => lifeCycle.onAttach());
                api.onDetach(() => lifeCycle.onDetach());
            },
            onAttach: (cb) => {
                session.attachCalls.push(cb);
            },
            onDetach: (cb) => {
                if (!token) {
                    token = new cancellation_token_js_6.CancellationToken();
                    session.tokens.push(token);
                }
                token.addCancelable(cb);
            },
            get cancellationToken() {
                if (!token) {
                    token = new cancellation_token_js_6.CancellationToken();
                    session.tokens.push(token);
                }
                return token;
            },
            prerender(target, lifeCycle) {
                const lc = lifeCycle;
                const subSession = createRenderSession();
                const result = renderInternal(target, subSession, true);
                lc.attach.subscribeOnce(() => {
                    subSession.attachCalls.forEach((cb) => cb());
                });
                lc.detach.subscribeOnce(() => {
                    lc.attach.cancelAll();
                    subSession.sessionToken.cancel();
                });
                return result;
            },
            className(data) {
                return (0, classname_js_1.aurumClassName)(data, api.cancellationToken);
            }
        };
        return api;
    }
    exports.createAPI = createAPI;
    class ArrayAurumElement extends AurumElement {
        constructor(dataSource, api) {
            super(dataSource, api);
            this.renderSessions = new WeakMap();
            this.dataSource = dataSource;
        }
        dispose() {
            if (this.disposed) {
                return;
            }
            this.api.cancellationToken.cancel();
            super.dispose();
        }
        attachToDom(node, index) {
            super.attachToDom(node, index);
            //@ts-ignore
            this.contentStartMarker.dataSource = this.dataSource;
            //@ts-ignore
            this.contentEndMarker.dataSource = this.dataSource;
        }
        render(dataSource) {
            dataSource.listenAndRepeat((n) => {
                if (!this.disposed) {
                    this.handleNewContent(n);
                }
            }, this.api.cancellationToken);
        }
        spliceChildren(index, amount, ...newItems) {
            var _a;
            let removed;
            if (newItems) {
                removed = this.children.splice(index, amount, ...newItems);
            }
            else {
                removed = this.children.splice(index, amount);
            }
            for (const item of removed) {
                (_a = this.renderSessions.get(item)) === null || _a === void 0 ? void 0 : _a.sessionToken.cancel();
            }
        }
        handleNewContent(change) {
            if (this.hostNode === undefined) {
                throw new Error('illegal state: Aurum element was not attched to anything');
            }
            let optimized = false;
            const ac = [];
            switch (change.operationDetailed) {
                case 'merge':
                    const source = change.previousState.slice();
                    for (let i = 0; i < change.newState.length; i++) {
                        if (this.children.length <= i) {
                            const rendered = this.renderItem(change.newState[i], ac);
                            if (Array.isArray(rendered)) {
                                this.children.push(...rendered);
                            }
                            else {
                                this.children.push(rendered);
                            }
                            source.push(change.newState[i]);
                        }
                        else if (source[i] !== change.newState[i]) {
                            const index = source.indexOf(change.newState[i], i);
                            if (index !== -1) {
                                const a = this.children[i];
                                const b = this.children[index];
                                this.children[i] = b;
                                this.children[index] = a;
                                const c = source[i];
                                const d = source[index];
                                source[i] = d;
                                source[index] = c;
                            }
                            else {
                                const rendered = this.renderItem(change.newState[i], ac);
                                if (Array.isArray(rendered)) {
                                    this.spliceChildren(i, 0, ...rendered);
                                }
                                else {
                                    this.spliceChildren(i, 0, rendered);
                                }
                                source.splice(i, 0, change.newState[i]);
                            }
                        }
                    }
                    if (this.children.length > change.newState.length) {
                        this.spliceChildren(change.newState.length, this.children.length - change.newState.length);
                    }
                    break;
                case 'remove':
                case 'removeLeft':
                case 'removeRight':
                    this.spliceChildren(flattenIndex(change.newState, change.index), flattenIndex(change.items, change.items.length));
                    break;
                case 'append':
                    let targetIndex = this.getLastIndex();
                    optimized = true;
                    for (const item of change.items) {
                        const rendered = this.renderItem(item, ac);
                        if (Array.isArray(rendered)) {
                            this.children = this.children.concat(rendered);
                            for (let i = 0; i <= rendered.length; i++) {
                                if (rendered[i]) {
                                    if (rendered[i] instanceof AurumElement) {
                                        rendered[i].attachToDom(this.hostNode, targetIndex);
                                        this.lastEndIndex = this.getLastIndex();
                                        targetIndex = this.lastEndIndex;
                                    }
                                    else {
                                        this.hostNode.insertBefore(rendered[i], this.hostNode.childNodes[targetIndex]);
                                        this.lastEndIndex++;
                                        targetIndex++;
                                    }
                                }
                            }
                        }
                        else {
                            this.children.push(rendered);
                            if (rendered) {
                                if (rendered instanceof AurumElement) {
                                    rendered.attachToDom(this.hostNode, targetIndex);
                                    this.lastEndIndex = this.getLastIndex();
                                    targetIndex = this.lastEndIndex;
                                }
                                else {
                                    this.hostNode.insertBefore(rendered, this.hostNode.childNodes[targetIndex]);
                                    this.lastEndIndex++;
                                    targetIndex++;
                                }
                            }
                        }
                    }
                    break;
                case 'replace':
                    const rendered = this.renderItem(change.items[0], ac);
                    if (Array.isArray(rendered)) {
                        throw new Error('illegal state');
                    }
                    else {
                        this.children[change.index] = rendered;
                    }
                    break;
                case 'swap':
                    const itemA = this.children[change.index];
                    const itemB = this.children[change.index2];
                    if (itemA instanceof HTMLElement && itemB instanceof HTMLElement) {
                        optimized = true;
                        if (itemA.parentElement === itemB.parentElement) {
                            if (itemA.nextSibling === itemB) {
                                itemB.parentNode.insertBefore(itemB, itemA);
                                this.children[change.index2] = itemA;
                                this.children[change.index] = itemB;
                                break;
                            }
                            if (itemB.nextSibling === itemA) {
                                itemB.parentNode.insertBefore(itemA, itemB);
                                this.children[change.index2] = itemA;
                                this.children[change.index] = itemB;
                                break;
                            }
                        }
                        const parentA = itemA.parentNode;
                        const siblingA = itemA.nextSibling === itemB ? itemB : itemA.nextSibling;
                        itemB.parentNode.insertBefore(itemA, itemB);
                        parentA.insertBefore(itemB, siblingA);
                    }
                    this.children[change.index2] = itemA;
                    this.children[change.index] = itemB;
                    break;
                case 'prepend':
                    for (let i = change.items.length - 1; i >= 0; i--) {
                        const item = change.items[i];
                        const rendered = this.renderItem(item, ac);
                        if (Array.isArray(rendered)) {
                            throw new Error('illegal state');
                        }
                        else {
                            this.children.unshift(rendered);
                        }
                    }
                    break;
                case 'insert':
                    let index = change.index;
                    for (const item of change.items) {
                        const rendered = this.renderItem(item, ac);
                        if (Array.isArray(rendered)) {
                            throw new Error('illegal state');
                        }
                        else {
                            this.children.splice(index, 0, rendered);
                            index += 1;
                        }
                    }
                    break;
                case 'clear':
                    this.spliceChildren(0, this.children.length);
                    this.renderSessions = new WeakMap();
                    break;
                default:
                    throw new Error('not implemented');
            }
            if (!optimized) {
                this.updateDom();
            }
            for (const c of ac) {
                c();
            }
        }
        renderItem(item, attachCalls) {
            if (item === null || item === undefined) {
                return;
            }
            const s = createRenderSession();
            const rendered = renderInternal(item, s);
            if (rendered === undefined || rendered === null) {
                return;
            }
            if (rendered instanceof AurumElement) {
                s.sessionToken.addCancelable(() => rendered.dispose());
            }
            this.renderSessions.set(rendered, s);
            attachCalls.push(...s.attachCalls);
            return rendered;
        }
    }
    exports.ArrayAurumElement = ArrayAurumElement;
    function flattenIndex(source, index) {
        let flatIndex = 0;
        for (let i = 0; i < index; i++) {
            if (Array.isArray(source[i])) {
                flatIndex += flattenIndex(source[i], source[i].length);
            }
            else {
                flatIndex++;
            }
        }
        return flatIndex;
    }
    class SingularAurumElement extends AurumElement {
        constructor(dataSource, api) {
            super(dataSource, api);
            this.api.cancellationToken.addCancelable(() => { var _a; return (_a = this.renderSession) === null || _a === void 0 ? void 0 : _a.sessionToken.cancel(); });
            this.dataSource = dataSource;
        }
        dispose() {
            if (this.disposed) {
                return;
            }
            this.api.cancellationToken.cancel();
            super.dispose();
        }
        attachToDom(node, index) {
            super.attachToDom(node, index);
            //@ts-ignore
            this.contentStartMarker.dataSource = this.dataSource;
            //@ts-ignore
            this.contentEndMarker.dataSource = this.dataSource;
        }
        render(dataSource) {
            dataSource.listenAndRepeat((n) => {
                if (!this.disposed) {
                    this.handleNewContent(n);
                }
            }, this.api.cancellationToken);
        }
        handleNewContent(newValue) {
            if (this.lastValue === newValue) {
                return;
            }
            let optimized = false;
            if (this.children.length === 1 && this.children[0] instanceof Text) {
                const type = typeof newValue;
                if (type === 'string' || type === 'bigint' || type === 'number' || type === 'boolean') {
                    this.children[0].nodeValue = newValue;
                    optimized = true;
                }
            }
            if (!optimized) {
                this.fullRebuild(newValue);
                this.updateDom();
                for (const cb of this.renderSession.attachCalls) {
                    cb();
                }
            }
            this.lastValue = newValue;
        }
        fullRebuild(newValue) {
            this.clearContent();
            this.endSession();
            this.renderSession = createRenderSession();
            let rendered = renderInternal(newValue, this.renderSession);
            if (rendered === undefined) {
                this.children = [];
                return;
            }
            if (!Array.isArray(rendered)) {
                rendered = [rendered];
            }
            for (const item of rendered) {
                if (item instanceof AurumElement) {
                    this.renderSession.sessionToken.addCancelable(() => {
                        item.dispose();
                    });
                }
            }
            if (Array.isArray(rendered)) {
                this.children = rendered;
            }
        }
        endSession() {
            if (this.renderSession) {
                this.renderSession.sessionToken.cancel();
                this.renderSession = undefined;
            }
        }
    }
    exports.SingularAurumElement = SingularAurumElement;
});
define("src/builtin_components/dom_adapter", ["require", "exports", "src/stream/data_source", "src/stream/duplex_data_source", "src/rendering/aurum_element", "src/stream/data_source_operators"], function (require, exports, data_source_js_7, duplex_data_source_js_5, aurum_element_js_1, data_source_operators_js_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aurumToHTML = exports.createEventHandlers = exports.processHTMLNode = exports.DomNodeCreator = exports.defaultAttributes = exports.defaultEvents = void 0;
    /**
     * @internal
     */
    exports.defaultEvents = {
        drag: 'onDrag',
        dragstart: 'onDragStart',
        dragend: 'onDragEnd',
        dragexit: 'onDragExit',
        dragover: 'onDragOver',
        dragenter: 'onDragEnter',
        dragleave: 'onDragLeave',
        drop: 'onDrop',
        blur: 'onBlur',
        focus: 'onFocus',
        click: 'onClick',
        dblclick: 'onDblClick',
        keydown: 'onKeyDown',
        keyhit: 'onKeyHit',
        keyup: 'onKeyUp',
        contextmenu: 'onContextMenu',
        mousedown: 'onMouseDown',
        mouseup: 'onMouseUp',
        mousemove: 'onMouseMove',
        mouseenter: 'onMouseEnter',
        mouseleave: 'onMouseLeave',
        mousewheel: 'onMouseWheel',
        load: 'onLoad',
        error: 'onError'
    };
    /**
     * @internal
     */
    exports.defaultAttributes = ['id', 'name', 'draggable', 'tabindex', 'style', 'role', 'contenteditable', 'slot', 'title'];
    function DomNodeCreator(nodeName, extraAttributes, extraEvents, extraLogic) {
        return function (props, children, api) {
            const node = document.createElement(nodeName);
            if (props) {
                processHTMLNode(node, props, api.cancellationToken, extraAttributes, extraEvents);
            }
            //@ts-ignore
            const renderedChildren = (0, aurum_element_js_1.renderInternal)(children, api.renderSession);
            connectChildren(node, renderedChildren);
            if (props) {
                if (props.onAttach) {
                    api.onAttach(() => props.onAttach(node));
                }
                if (props.onDetach) {
                    api.onDetach(() => {
                        if (node.isConnected) {
                            node.parentElement.removeChild(node);
                        }
                        props.onDetach(node);
                    });
                }
            }
            extraLogic === null || extraLogic === void 0 ? void 0 : extraLogic(node, props, api.cancellationToken);
            return node;
        };
    }
    exports.DomNodeCreator = DomNodeCreator;
    function connectChildren(target, children) {
        if (children === undefined || children === null || children.length === 0) {
            return;
        }
        for (const child of children) {
            if (!child) {
                continue;
            }
            if (child instanceof Text || child instanceof HTMLElement) {
                target.appendChild(child);
            }
            else if (child instanceof aurum_element_js_1.AurumElement) {
                child.attachToDom(target, target.childNodes.length);
            }
            else {
                throw new Error(`Unexpected child type passed to DOM Node: ${children}`);
            }
        }
    }
    function processHTMLNode(node, props, cleanUp, extraAttributes, extraEvents) {
        createEventHandlers(node, exports.defaultEvents, props);
        if (extraEvents) {
            createEventHandlers(node, extraEvents, props);
        }
        const dataProps = Object.keys(props).filter((e) => e.includes('-'));
        bindProps(node, exports.defaultAttributes, props, cleanUp, dataProps);
        if (extraAttributes) {
            bindProps(node, extraAttributes, props, cleanUp);
        }
        if (props.class) {
            handleClass(node, props.class, cleanUp);
        }
    }
    exports.processHTMLNode = processHTMLNode;
    function createEventHandlers(node, events, props) {
        for (const key in events) {
            if (props[events[key]]) {
                if (props[events[key]] instanceof data_source_js_7.DataSource) {
                    //@ts-ignore
                    node.addEventListener(key, (e) => props[events[key]].update(e));
                }
                else if (props[events[key]] instanceof duplex_data_source_js_5.DuplexDataSource) {
                    //@ts-ignore
                    node.addEventListener(key, (e) => props[events[key]].updateDownstream(e));
                }
                else if (typeof props[events[key]] === 'function') {
                    //@ts-ignore
                    node.addEventListener(key, (e) => props[events[key]](e));
                }
            }
        }
    }
    exports.createEventHandlers = createEventHandlers;
    function bindProps(node, keys, props, cleanUp, dynamicProps) {
        for (const key of keys) {
            if (props[key]) {
                assignStringSourceToAttribute(node, props[key], key, cleanUp);
            }
        }
        if (dynamicProps) {
            for (const key of dynamicProps) {
                if (props[key]) {
                    assignStringSourceToAttribute(node, props[key], key, cleanUp);
                }
            }
        }
    }
    /**
     * Renders Aurum content synchronously in line.
     * @param content Content to render
     */
    function aurumToHTML(content) {
        const rs = (0, aurum_element_js_1.createRenderSession)();
        const renderedContent = (0, aurum_element_js_1.renderInternal)(content, rs);
        return {
            content: renderedContent,
            fireOnAttach: () => rs.attachCalls.forEach((c) => c()),
            dispose: () => rs.sessionToken.cancel()
        };
    }
    exports.aurumToHTML = aurumToHTML;
    function assignStringSourceToAttribute(node, data, key, cleanUp) {
        if (typeof data === 'string') {
            node.setAttribute(key, data);
        }
        else if (typeof data === 'boolean') {
            if (data) {
                node.setAttribute(key, '');
            }
        }
        else if (data instanceof data_source_js_7.DataSource || data instanceof duplex_data_source_js_5.DuplexDataSource) {
            if (typeof data.value === 'string') {
                node.setAttribute(key, data.value);
            }
            else if (typeof data.value === 'boolean') {
                if (data.value) {
                    node.setAttribute(key, '');
                }
            }
            data.transform((0, data_source_operators_js_3.dsUnique)(), cleanUp).listen((v) => {
                if (typeof v === 'string') {
                    node.setAttribute(key, v);
                }
                else if (typeof v === 'boolean') {
                    if (v) {
                        node.setAttribute(key, '');
                    }
                    else {
                        node.removeAttribute(key);
                    }
                }
            });
        }
        else {
            throw new Error('Attributes only support types boolean, string, number and data sources');
        }
    }
    function handleClass(node, data, cleanUp) {
        if (typeof data === 'string') {
            node.className = data;
        }
        else if (data instanceof data_source_js_7.DataSource || data instanceof duplex_data_source_js_5.DuplexDataSource) {
            data.transform((0, data_source_operators_js_3.dsUnique)(), cleanUp)
                .withInitial(data.value)
                .listenAndRepeat((v) => {
                if (Array.isArray(v)) {
                    node.className = v.join(' ');
                }
                else {
                    node.className = v;
                }
            });
        }
        else {
            const value = data.reduce((p, c) => {
                if (!c) {
                    return p;
                }
                if (typeof c === 'string') {
                    return `${p} ${c}`;
                }
                else {
                    if (c.value) {
                        return `${p} ${c.value}`;
                    }
                    else {
                        return p;
                    }
                }
            }, '');
            node.className = value;
            for (const i of data) {
                if (i instanceof data_source_js_7.DataSource) {
                    i.transform((0, data_source_operators_js_3.dsUnique)(), cleanUp).listen((v) => {
                        const value = data.reduce((p, c) => {
                            if (typeof c === 'string') {
                                return `${p} ${c}`;
                            }
                            else {
                                if (c.value) {
                                    return `${p} ${c.value}`;
                                }
                                else {
                                    return p;
                                }
                            }
                        }, '');
                        node.className = value;
                    });
                }
            }
        }
    }
});
define("src/nodes/input", ["require", "exports", "src/builtin_components/dom_adapter", "src/stream/data_source", "src/stream/duplex_data_source"], function (require, exports, dom_adapter_js_1, data_source_js_8, duplex_data_source_js_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Input = void 0;
    /**
     * @internal
     */
    const inputEvents = { input: 'onInput', change: 'onChange' };
    /**
     * @internal
     */
    const inputProps = [
        'placeholder',
        'readonly',
        'disabled',
        'accept',
        'alt',
        'autocomplete',
        'autofocus',
        'checked',
        'defaultChecked',
        'formAction',
        'formEnctype',
        'formMethod',
        'formNoValidate',
        'formTarget',
        'max',
        'maxLength',
        'min',
        'minLength',
        'pattern',
        'multiple',
        'required',
        'type',
        'step',
        'list'
    ];
    /**
     * @internal
     */
    exports.Input = (0, dom_adapter_js_1.DomNodeCreator)('input', inputProps, inputEvents, (node, props, cleanUp) => {
        const input = node;
        if (props.value) {
            if (props.value instanceof data_source_js_8.DataSource) {
                props.value.listenAndRepeat((v) => {
                    input.value = v !== null && v !== void 0 ? v : '';
                }, cleanUp);
                input.addEventListener('input', () => {
                    props.value.update(input.value);
                });
            }
            else if (props.value instanceof duplex_data_source_js_6.DuplexDataSource) {
                props.value.listenAndRepeat((v) => {
                    input.value = v !== null && v !== void 0 ? v : '';
                }, cleanUp);
                input.addEventListener('input', () => {
                    props.value.updateUpstream(input.value);
                });
            }
            else {
                input.value = props.value;
            }
        }
        if (props.checked) {
            if (props.checked instanceof data_source_js_8.DataSource) {
                props.checked.listenAndRepeat((v) => {
                    input.checked = v !== null && v !== void 0 ? v : false;
                }, cleanUp);
                input.addEventListener('change', () => {
                    props.checked.update(input.checked);
                });
            }
            else if (props.checked instanceof duplex_data_source_js_6.DuplexDataSource) {
                props.checked.listenAndRepeat((v) => {
                    input.checked = v !== null && v !== void 0 ? v : false;
                }, cleanUp);
                input.addEventListener('change', () => {
                    props.checked.updateUpstream(input.checked);
                });
            }
            else {
                input.checked = props.checked;
            }
        }
    });
});
define("src/nodes/select", ["require", "exports", "src/stream/data_source", "src/stream/duplex_data_source", "src/builtin_components/dom_adapter"], function (require, exports, data_source_js_9, duplex_data_source_js_7, dom_adapter_js_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Select = void 0;
    /**
     * @internal
     */
    const selectEvents = { change: 'onChange' };
    /**
     * @internal
     */
    exports.Select = (0, dom_adapter_js_2.DomNodeCreator)('select', undefined, selectEvents, (node, props, cleanUp) => {
        const select = node;
        if ((props === null || props === void 0 ? void 0 : props.value) || (props === null || props === void 0 ? void 0 : props.selectedIndex)) {
            // In case props.value is a data source we need to reapply the value when the children change because the children may be unstable/be removed and re-added which would falsify the state.
            if (props.value instanceof data_source_js_9.DataSource || props.value instanceof duplex_data_source_js_7.DuplexDataSource) {
                const mo = new MutationObserver(() => {
                    select.value = props.value.value;
                });
                mo.observe(select, {
                    childList: true
                });
                cleanUp.addCancelable(() => {
                    mo.disconnect();
                });
            }
            if (props.selectedIndex instanceof data_source_js_9.DataSource || props.selectedIndex instanceof duplex_data_source_js_7.DuplexDataSource) {
                const mo = new MutationObserver(() => {
                    select.selectedIndex = props.selectedIndex.value;
                });
                mo.observe(select, {
                    childList: true
                });
                cleanUp.addCancelable(() => {
                    mo.disconnect();
                });
            }
            if (props.value instanceof data_source_js_9.DataSource) {
                props.value.listenAndRepeat((v) => {
                    select.value = v;
                }, cleanUp);
                select.addEventListener('change', () => {
                    props.value.update(select.value);
                });
            }
            else if (props.value instanceof duplex_data_source_js_7.DuplexDataSource) {
                props.value.listenAndRepeat((v) => {
                    select.value = v;
                }, cleanUp);
                select.addEventListener('change', () => {
                    props.value.updateUpstream(select.value);
                });
            }
            else {
                select.value = props.value;
            }
            if (props === null || props === void 0 ? void 0 : props.selectedIndex) {
                if (props.selectedIndex instanceof data_source_js_9.DataSource) {
                    props.selectedIndex.listenAndRepeat((v) => {
                        select.selectedIndex = v;
                    }, cleanUp);
                    select.addEventListener('change', () => {
                        props.selectedIndex.update(select.selectedIndex);
                    });
                }
                else if (props.selectedIndex instanceof duplex_data_source_js_7.DuplexDataSource) {
                    props.selectedIndex.listenAndRepeat((v) => {
                        select.selectedIndex = v;
                    }, cleanUp);
                    select.addEventListener('change', () => {
                        props.selectedIndex.updateUpstream(select.selectedIndex);
                    });
                }
                else {
                    select.selectedIndex = props.selectedIndex;
                }
            }
        }
    });
});
define("src/nodes/simple_dom_nodes", ["require", "exports", "src/builtin_components/dom_adapter"], function (require, exports, dom_adapter_js_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Object = exports.Output = exports.Picture = exports.Wbr = exports.Var = exports.Kbd = exports.Samp = exports.Strong = exports.Slot = exports.OptGroup = exports.Option = exports.Progress = exports.Svg = exports.Script = exports.Param = exports.Track = exports.Source = exports.Style = exports.Time = exports.Th = exports.Td = exports.Tr = exports.Caption = exports.Colgroup = exports.Col = exports.TFoot = exports.TBody = exports.Table = exports.Sup = exports.Sub = exports.Nav = exports.Link = exports.Label = exports.Img = exports.IFrame = exports.I = exports.Heading = exports.Header = exports.Head = exports.Html = exports.Meta = exports.Form = exports.Footer = exports.Em = exports.Details = exports.Data = exports.Canvas = exports.Button = exports.Br = exports.Audio = exports.Hr = exports.P = exports.Pre = exports.Q = exports.Template = exports.THead = exports.Summary = exports.Title = exports.Body = exports.B = exports.Li = exports.Ol = exports.Ul = exports.Video = exports.NoScript = exports.Span = exports.Aside = exports.Article = exports.Area = exports.H6 = exports.H5 = exports.H4 = exports.H3 = exports.H2 = exports.H1 = exports.Address = exports.Abbr = exports.A = exports.Div = exports.Code = void 0;
    /**
     * @internal
     */
    exports.Code = (0, dom_adapter_js_3.DomNodeCreator)('code');
    /**
     * @internal
     */
    exports.Div = (0, dom_adapter_js_3.DomNodeCreator)('div');
    /**
     * @internal
     */
    exports.A = (0, dom_adapter_js_3.DomNodeCreator)('a', ['href', 'target', 'hreflang', 'media', 'download', 'ping', 'referrerpolicy', 'rel', 'type']);
    /**
     * @internal
     */
    exports.Abbr = (0, dom_adapter_js_3.DomNodeCreator)('abbr');
    /**
     * @internal
     */
    exports.Address = (0, dom_adapter_js_3.DomNodeCreator)('address');
    /**
     * @internal
     */
    exports.H1 = (0, dom_adapter_js_3.DomNodeCreator)('h1');
    /**
     * @internal
     */
    exports.H2 = (0, dom_adapter_js_3.DomNodeCreator)('h2');
    /**
     * @internal
     */
    exports.H3 = (0, dom_adapter_js_3.DomNodeCreator)('h3');
    /**
     * @internal
     */
    exports.H4 = (0, dom_adapter_js_3.DomNodeCreator)('h4');
    /**
     * @internal
     */
    exports.H5 = (0, dom_adapter_js_3.DomNodeCreator)('h5');
    /**
     * @internal
     */
    exports.H6 = (0, dom_adapter_js_3.DomNodeCreator)('h6');
    /**
     * @internal
     */
    exports.Area = (0, dom_adapter_js_3.DomNodeCreator)('area', [
        'alt',
        'coors',
        'download',
        'href',
        'hreflang',
        'media',
        'rel',
        'shape',
        'target',
        'type',
        'ping',
        'referrerpolicy'
    ]);
    /**
     * @internal
     */
    exports.Article = (0, dom_adapter_js_3.DomNodeCreator)('article');
    /**
     * @internal
     */
    exports.Aside = (0, dom_adapter_js_3.DomNodeCreator)('aside');
    /**
     * @internal
     */
    exports.Span = (0, dom_adapter_js_3.DomNodeCreator)('span');
    /**
     * @internal
     */
    exports.NoScript = (0, dom_adapter_js_3.DomNodeCreator)('noscript');
    /**
     * @internal
     */
    exports.Video = (0, dom_adapter_js_3.DomNodeCreator)('video', [
        'controls',
        'autoplay',
        'loop',
        'muted',
        'preload',
        'src',
        'poster',
        'width',
        'height',
        'autopictureinpicture',
        'controlslist',
        'crossorigin',
        'disablepictureinpicture',
        'disableremoteplayback',
        'playsinline'
    ], {
        canPlay: 'onCanPlay',
        canplaythrough: 'onCanPlayThrough',
        complete: 'onComplete',
        durationchange: 'onDurationChange',
        emptied: 'onEmptied',
        ended: 'onEnded',
        loadeddata: 'onLoadedData',
        loadedmetadata: 'onLoadedMetadata',
        pause: 'onPause',
        play: 'onPlay',
        playing: 'onPlaying',
        progress: 'onProgress',
        ratechange: 'onRateChange',
        seeked: 'onSeeked',
        seeking: 'onSeeking',
        stalled: 'onStalled',
        suspend: 'onSuspend',
        timeupdate: 'onTimeUpdate',
        volumechange: 'onVolumeChange',
        waiting: 'onWaiting'
    });
    /**
     * @internal
     */
    exports.Ul = (0, dom_adapter_js_3.DomNodeCreator)('ul');
    /**
     * @internal
     */
    exports.Ol = (0, dom_adapter_js_3.DomNodeCreator)('ol');
    /**
     * @internal
     */
    exports.Li = (0, dom_adapter_js_3.DomNodeCreator)('li');
    /**
     * @internal
     */
    exports.B = (0, dom_adapter_js_3.DomNodeCreator)('b');
    /**
     * @internal
     */
    exports.Body = (0, dom_adapter_js_3.DomNodeCreator)('body');
    /**
     * @internal
     */
    exports.Title = (0, dom_adapter_js_3.DomNodeCreator)('title');
    /**
     * @internal
     */
    exports.Summary = (0, dom_adapter_js_3.DomNodeCreator)('summary');
    /**
     * @internal
     */
    exports.THead = (0, dom_adapter_js_3.DomNodeCreator)('thead');
    /**
     * @internal
     */
    exports.Template = (0, dom_adapter_js_3.DomNodeCreator)('template');
    /**
     * @internal
     */
    exports.Q = (0, dom_adapter_js_3.DomNodeCreator)('q');
    /**
     * @internal
     */
    exports.Pre = (0, dom_adapter_js_3.DomNodeCreator)('pre');
    /**
     * @internal
     */
    exports.P = (0, dom_adapter_js_3.DomNodeCreator)('p');
    /**
     * @internal
     */
    exports.Hr = (0, dom_adapter_js_3.DomNodeCreator)('hr');
    /**
     * @internal
     */
    exports.Audio = (0, dom_adapter_js_3.DomNodeCreator)('audio', ['controls', 'autoplay', 'loop', 'muted', 'preload', 'src', 'crossorigin'], {
        audioprocess: 'onAudioProcess',
        canplay: 'onCanPlay',
        canplaythrough: 'onCanPlayThrough',
        complete: 'onComplete',
        durationchange: 'onDurationChange',
        emptied: 'onEmptied',
        ended: 'onEnded',
        loadeddata: 'onLoadedData',
        loadedmetadata: 'onLoadedMetadata',
        pause: 'onPause',
        play: 'onPlay',
        playing: 'onPlaying',
        ratechange: 'onRateChange',
        seeked: 'onSeeked',
        seeking: 'onSeeking',
        stalled: 'onStalled',
        suspend: 'onSuspend',
        timeupdate: 'onTimeUpdate',
        volumechange: 'onVolumeChange',
        waiting: 'onWaiting'
    });
    /**
     * @internal
     */
    exports.Br = (0, dom_adapter_js_3.DomNodeCreator)('br');
    /**
     * @internal
     */
    exports.Button = (0, dom_adapter_js_3.DomNodeCreator)('button', [
        'disabled',
        'autofocus',
        'form',
        'formaction',
        'formenctype',
        'formmethod',
        'formnovalidate',
        'formtarget',
        'type'
    ]);
    /**
     * @internal
     */
    exports.Canvas = (0, dom_adapter_js_3.DomNodeCreator)('canvas', ['width', 'height']);
    /**
     * @internal
     */
    exports.Data = (0, dom_adapter_js_3.DomNodeCreator)('data', ['value']);
    /**
     * @internal
     */
    exports.Details = (0, dom_adapter_js_3.DomNodeCreator)('details');
    /**
     * @internal
     */
    exports.Em = (0, dom_adapter_js_3.DomNodeCreator)('em');
    /**
     * @internal
     */
    exports.Footer = (0, dom_adapter_js_3.DomNodeCreator)('footer');
    /**
     * @internal
     */
    exports.Form = (0, dom_adapter_js_3.DomNodeCreator)('form', ['action', 'method', 'rel', 'enctype', 'novalidate', 'target', 'accept-charset', 'autocomplete']);
    /**
     * @internal
     */
    exports.Meta = (0, dom_adapter_js_3.DomNodeCreator)('meta', ['http-equiv', 'charset', 'content']);
    /**
     * @internal
     */
    exports.Html = (0, dom_adapter_js_3.DomNodeCreator)('html', ['lang', 'xmlns']);
    /**
     * @internal
     */
    exports.Head = (0, dom_adapter_js_3.DomNodeCreator)('head');
    /**
     * @internal
     */
    exports.Header = (0, dom_adapter_js_3.DomNodeCreator)('header');
    /**
     * @internal
     */
    exports.Heading = (0, dom_adapter_js_3.DomNodeCreator)('heading');
    /**
     * @internal
     */
    exports.I = (0, dom_adapter_js_3.DomNodeCreator)('i');
    /**
     * @internal
     */
    exports.IFrame = (0, dom_adapter_js_3.DomNodeCreator)('iframe', [
        'src',
        'srcdoc',
        'width',
        'height',
        'allow',
        'allowfullscreen',
        'allowpaymentrequest',
        'loading',
        'sandbox',
        'frameborder',
        'csp',
        'referrerpolicy'
    ]);
    /**
     * @internal
     */
    exports.Img = (0, dom_adapter_js_3.DomNodeCreator)('img', [
        'src',
        'alt',
        'width',
        'height',
        'referrerpolicy',
        'sizes',
        'srcset',
        'usemap',
        'crossorigin',
        'decoding',
        'ismap',
        'loading'
    ]);
    /**
     * @internal
     */
    exports.Label = (0, dom_adapter_js_3.DomNodeCreator)('label', ['for']);
    /**
     * @internal
     */
    exports.Link = (0, dom_adapter_js_3.DomNodeCreator)('link', [
        'href',
        'rel',
        'media',
        'as',
        'disabled',
        'type',
        'crossorigin',
        'hreflang',
        'referrerpolicy',
        'sizes',
        'integrity',
        'imagesizes',
        'prefetch'
    ]);
    /**
     * @internal
     */
    exports.Nav = (0, dom_adapter_js_3.DomNodeCreator)('nav');
    /**
     * @internal
     */
    exports.Sub = (0, dom_adapter_js_3.DomNodeCreator)('sub');
    /**
     * @internal
     */
    exports.Sup = (0, dom_adapter_js_3.DomNodeCreator)('sup');
    /**
     * @internal
     */
    exports.Table = (0, dom_adapter_js_3.DomNodeCreator)('table');
    /**
     * @internal
     */
    exports.TBody = (0, dom_adapter_js_3.DomNodeCreator)('tbody');
    /**
     * @internal
     */
    exports.TFoot = (0, dom_adapter_js_3.DomNodeCreator)('tfoot');
    /**
     * @internal
     */
    exports.Col = (0, dom_adapter_js_3.DomNodeCreator)('col', ['span']);
    /**
     * @internal
     */
    exports.Colgroup = (0, dom_adapter_js_3.DomNodeCreator)('colgroup', ['span']);
    /**
     * @internal
     */
    exports.Caption = (0, dom_adapter_js_3.DomNodeCreator)('caption');
    /**
     * @internal
     */
    exports.Tr = (0, dom_adapter_js_3.DomNodeCreator)('tr');
    /**
     * @internal
     */
    exports.Td = (0, dom_adapter_js_3.DomNodeCreator)('td', ['colspan', 'headers', 'rowspan']);
    /**
     * @internal
     */
    exports.Th = (0, dom_adapter_js_3.DomNodeCreator)('th', ['scope', 'abbr', 'colspan', 'headers', 'rowspan']);
    /**
     * @internal
     */
    exports.Time = (0, dom_adapter_js_3.DomNodeCreator)('time', ['datetime']);
    /**
     * @internal
     */
    exports.Style = (0, dom_adapter_js_3.DomNodeCreator)('style', ['media', 'type', 'nonce']);
    /**
     * @internal
     */
    exports.Source = (0, dom_adapter_js_3.DomNodeCreator)('source', ['src', 'srcset', 'media', 'sizes', 'type']);
    /**
     * @internal
     */
    exports.Track = (0, dom_adapter_js_3.DomNodeCreator)('track', ['src', 'srclang', 'label', 'kind', 'default']);
    /**
     * @internal
     */
    exports.Param = (0, dom_adapter_js_3.DomNodeCreator)('param', ['value']);
    /**
     * @internal
     */
    exports.Script = (0, dom_adapter_js_3.DomNodeCreator)('script', [
        'src',
        'async',
        'defer',
        'integrity',
        'nomodule',
        'type',
        'crossorigin',
        'referrerpolicy',
        'text',
        'nonce'
    ]);
    /**
     * @internal
     */
    exports.Svg = (0, dom_adapter_js_3.DomNodeCreator)('svg', ['width', 'height']);
    /**
     * @internal
     */
    exports.Progress = (0, dom_adapter_js_3.DomNodeCreator)('progress', ['max', 'value']);
    /**
     * @internal
     */
    exports.Option = (0, dom_adapter_js_3.DomNodeCreator)('option', ['value', 'label', 'disabled', 'selected']);
    /**
     * @internal
     */
    exports.OptGroup = (0, dom_adapter_js_3.DomNodeCreator)('optgroup', ['label', 'disabled']);
    /**
     * @internal
     */
    exports.Slot = (0, dom_adapter_js_3.DomNodeCreator)('slot');
    /**
     * @internal
     */
    exports.Strong = (0, dom_adapter_js_3.DomNodeCreator)('strong');
    /**
     * @internal
     */
    exports.Samp = (0, dom_adapter_js_3.DomNodeCreator)('samp');
    /**
     * @internal
     */
    exports.Kbd = (0, dom_adapter_js_3.DomNodeCreator)('kbd');
    /**
     * @internal
     */
    exports.Var = (0, dom_adapter_js_3.DomNodeCreator)('var');
    /**
     * @internal
     */
    exports.Wbr = (0, dom_adapter_js_3.DomNodeCreator)('wbr');
    /**
     * @internal
     */
    exports.Picture = (0, dom_adapter_js_3.DomNodeCreator)('picture');
    /**
     * @internal
     */
    exports.Output = (0, dom_adapter_js_3.DomNodeCreator)('output', ['for', 'form']);
    /**
     * @internal
     */
    exports.Object = (0, dom_adapter_js_3.DomNodeCreator)('object', ['data', 'width', 'height', 'form', 'type', 'usemap']);
});
define("src/nodes/textarea", ["require", "exports", "src/stream/data_source", "src/stream/duplex_data_source", "src/builtin_components/dom_adapter"], function (require, exports, data_source_js_10, duplex_data_source_js_8, dom_adapter_js_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextArea = void 0;
    /**
     * @internal
     */
    const textAreaEvents = { input: 'onInput', change: 'onChange' };
    /**
     * @internal
     */
    const textAreaProps = [
        'placeholder',
        'readonly',
        'disabled',
        'form',
        'cols',
        'rows',
        'wrap',
        'autocomplete',
        'autofocus',
        'max',
        'maxLength',
        'min',
        'spellcheck',
        'minLength',
        'required',
        'type'
    ];
    /**
     * @internal
     */
    exports.TextArea = (0, dom_adapter_js_4.DomNodeCreator)('textArea', textAreaProps, textAreaEvents, (node, props, cleanUp) => {
        const textArea = node;
        if (props.value) {
            if (props.value instanceof data_source_js_10.DataSource) {
                props.value.listenAndRepeat((v) => {
                    textArea.value = v;
                }, cleanUp);
                textArea.addEventListener('input', () => {
                    props.value.update(textArea.value);
                });
            }
            else if (props.value instanceof duplex_data_source_js_8.DuplexDataSource) {
                props.value.listenAndRepeat((v) => {
                    textArea.value = v;
                }, cleanUp);
                textArea.addEventListener('input', () => {
                    props.value.updateUpstream(textArea.value);
                });
            }
            else {
                textArea.value = props.value;
            }
        }
    });
});
define("src/utilities/aurum", ["require", "exports", "src/nodes/input", "src/nodes/select", "src/nodes/simple_dom_nodes", "src/nodes/textarea", "src/rendering/aurum_element", "src/stream/data_source"], function (require, exports, input_js_1, select_js_1, simple_dom_nodes_js_1, textarea_js_1, aurum_element_js_2, data_source_js_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Aurum = void 0;
    const nodeMap = {
        address: simple_dom_nodes_js_1.Address,
        kbd: simple_dom_nodes_js_1.Kbd,
        samp: simple_dom_nodes_js_1.Samp,
        object: simple_dom_nodes_js_1.Object,
        optgroup: simple_dom_nodes_js_1.OptGroup,
        picture: simple_dom_nodes_js_1.Picture,
        output: simple_dom_nodes_js_1.Output,
        param: simple_dom_nodes_js_1.Param,
        strong: simple_dom_nodes_js_1.Strong,
        track: simple_dom_nodes_js_1.Track,
        var: simple_dom_nodes_js_1.Var,
        wbr: simple_dom_nodes_js_1.Wbr,
        button: simple_dom_nodes_js_1.Button,
        code: simple_dom_nodes_js_1.Code,
        hr: simple_dom_nodes_js_1.Hr,
        div: simple_dom_nodes_js_1.Div,
        input: input_js_1.Input,
        li: simple_dom_nodes_js_1.Li,
        span: simple_dom_nodes_js_1.Span,
        style: simple_dom_nodes_js_1.Style,
        ul: simple_dom_nodes_js_1.Ul,
        p: simple_dom_nodes_js_1.P,
        img: simple_dom_nodes_js_1.Img,
        link: simple_dom_nodes_js_1.Link,
        canvas: simple_dom_nodes_js_1.Canvas,
        a: simple_dom_nodes_js_1.A,
        article: simple_dom_nodes_js_1.Article,
        br: simple_dom_nodes_js_1.Br,
        form: simple_dom_nodes_js_1.Form,
        label: simple_dom_nodes_js_1.Label,
        ol: simple_dom_nodes_js_1.Ol,
        pre: simple_dom_nodes_js_1.Pre,
        progress: simple_dom_nodes_js_1.Progress,
        table: simple_dom_nodes_js_1.Table,
        td: simple_dom_nodes_js_1.Td,
        tr: simple_dom_nodes_js_1.Tr,
        th: simple_dom_nodes_js_1.Th,
        textarea: textarea_js_1.TextArea,
        h1: simple_dom_nodes_js_1.H1,
        h2: simple_dom_nodes_js_1.H2,
        h3: simple_dom_nodes_js_1.H3,
        h4: simple_dom_nodes_js_1.H4,
        h5: simple_dom_nodes_js_1.H5,
        h6: simple_dom_nodes_js_1.H6,
        html: simple_dom_nodes_js_1.Html,
        head: simple_dom_nodes_js_1.Head,
        header: simple_dom_nodes_js_1.Header,
        footer: simple_dom_nodes_js_1.Footer,
        nav: simple_dom_nodes_js_1.Nav,
        b: simple_dom_nodes_js_1.B,
        i: simple_dom_nodes_js_1.I,
        script: simple_dom_nodes_js_1.Script,
        abbr: simple_dom_nodes_js_1.Abbr,
        area: simple_dom_nodes_js_1.Area,
        aside: simple_dom_nodes_js_1.Aside,
        audio: simple_dom_nodes_js_1.Audio,
        em: simple_dom_nodes_js_1.Em,
        heading: simple_dom_nodes_js_1.Heading,
        iframe: simple_dom_nodes_js_1.IFrame,
        noscript: simple_dom_nodes_js_1.NoScript,
        option: simple_dom_nodes_js_1.Option,
        q: simple_dom_nodes_js_1.Q,
        select: select_js_1.Select,
        source: simple_dom_nodes_js_1.Source,
        title: simple_dom_nodes_js_1.Title,
        video: simple_dom_nodes_js_1.Video,
        tbody: simple_dom_nodes_js_1.TBody,
        tfoot: simple_dom_nodes_js_1.TFoot,
        meta: simple_dom_nodes_js_1.Meta,
        body: simple_dom_nodes_js_1.Body,
        thead: simple_dom_nodes_js_1.THead,
        summary: simple_dom_nodes_js_1.Summary,
        details: simple_dom_nodes_js_1.Details,
        sub: simple_dom_nodes_js_1.Sub,
        sup: simple_dom_nodes_js_1.Sup,
        svg: simple_dom_nodes_js_1.Svg,
        data: simple_dom_nodes_js_1.Data,
        time: simple_dom_nodes_js_1.Time,
        template: simple_dom_nodes_js_1.Template,
        slot: simple_dom_nodes_js_1.Slot,
        col: simple_dom_nodes_js_1.Col,
        colgroup: simple_dom_nodes_js_1.Colgroup,
        caption: simple_dom_nodes_js_1.Caption
    };
    class Aurum {
        static rehydrate(aurumRenderable, dom) {
            const target = dom.parentElement;
            dom.remove();
            return Aurum.attach(aurumRenderable, target);
        }
        static attach(aurumRenderable, dom) {
            const session = (0, aurum_element_js_2.createRenderSession)();
            const content = (0, aurum_element_js_2.renderInternal)(aurumRenderable, session);
            if (content instanceof aurum_element_js_2.AurumElement) {
                content.attachToDom(dom, dom.childNodes.length);
                session.sessionToken.addCancelable(() => content.dispose());
            }
            else if (Array.isArray(content)) {
                const root = new aurum_element_js_2.ArrayAurumElement(new data_source_js_11.ArrayDataSource(content), (0, aurum_element_js_2.createAPI)(session));
                session.sessionToken.addCancelable(() => root.dispose());
                root.attachToDom(dom, dom.childNodes.length);
            }
            else {
                dom.appendChild(content);
                session.sessionToken.addCancelable(() => {
                    if (content.isConnected) {
                        dom.removeChild(content);
                    }
                });
            }
            for (let i = session.attachCalls.length - 1; i >= 0; i--) {
                session.attachCalls[i]();
            }
            return session.sessionToken;
        }
        static fragment() { }
        static factory(node, args, ...innerNodes) {
            //@ts-ignore
            if (node === Aurum.fragment) {
                return innerNodes;
            }
            let name;
            let intrinsic = false;
            if (typeof node === 'string') {
                intrinsic = true;
                name = node;
                const type = node;
                node = nodeMap[node];
                if (node === undefined) {
                    throw new Error(`Node ${type} does not exist or is not supported`);
                }
            }
            else {
                name = node.name;
            }
            return {
                [aurum_element_js_2.aurumElementModelIdentitiy]: true,
                name,
                isIntrinsic: intrinsic,
                factory: node,
                props: args,
                children: innerNodes
            };
        }
    }
    exports.Aurum = Aurum;
});
define("src/rendering/webcomponent", ["require", "exports", "src/utilities/aurum", "src/rendering/aurum_element", "src/stream/data_source", "src/builtin_components/dom_adapter"], function (require, exports, aurum_js_1, aurum_element_js_3, data_source_js_12, dom_adapter_js_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Webcomponent = void 0;
    /**
     * Wrapper around native web components allows using aurum style component structure to create native components.
     */
    function Webcomponent(config, logic) {
        customElements.define(config.name, class extends HTMLElement {
            constructor() {
                super();
                if (config.observedAttributes === undefined) {
                    config.observedAttributes = [];
                }
                this.props = {};
                for (const attr of config.observedAttributes) {
                    this.props[attr] = new data_source_js_12.DataSource();
                }
            }
            static get observedAttributes() {
                return config.observedAttributes;
            }
            attributeChangedCallback(name, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.props[name].update(newValue);
                }
            }
            connectedCallback() {
                var _a;
                const template = document.createDocumentFragment();
                this.session = (0, aurum_element_js_3.createRenderSession)();
                this.api = (0, aurum_element_js_3.createAPI)(this.session);
                const content = logic(this.props, this.api);
                for (const cb of this.session.attachCalls) {
                    cb();
                }
                aurum_js_1.Aurum.attach(content, template);
                this.attachShadow({
                    mode: (_a = config.shadowRootMode) !== null && _a !== void 0 ? _a : 'open',
                    delegatesFocus: config.shadowRootDelegatesFocus
                }).appendChild(template);
            }
            disconnectedCallback() {
                this.session.sessionToken.cancel();
            }
        });
        return (0, dom_adapter_js_5.DomNodeCreator)(config.name, config.observedAttributes, undefined, (node, props) => {
            for (const key in props) {
                //@ts-ignore
                if (!(key in node.props)) {
                    //@ts-ignore
                    node.props[key] = props[key];
                }
            }
        });
    }
    exports.Webcomponent = Webcomponent;
});
define("src/rendering/aurum_style", ["require", "exports", "src/stream/data_source", "src/stream/duplex_data_source", "src/stream/stream", "src/utilities/aurum", "src/utilities/cancellation_token"], function (require, exports, data_source_js_13, duplex_data_source_js_9, stream_js_3, aurum_js_2, cancellation_token_js_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.css = void 0;
    /**
     * Generates a style tag with the provided style as content, supports data sources, duplex data sources and streams instead of strings in the template.
     * Updates style content if any of the datasources used updates.
     */
    function css(fragments, ...input) {
        const result = new data_source_js_13.DataSource();
        const token = new cancellation_token_js_7.CancellationToken();
        for (const ins of input) {
            if (ins instanceof data_source_js_13.DataSource || ins instanceof duplex_data_source_js_9.DuplexDataSource || ins instanceof stream_js_3.Stream) {
                ins.listen(() => result.update(recompute(fragments, input)), token);
            }
        }
        result.update(recompute(fragments, input));
        return aurum_js_2.Aurum.factory('style', {
            onDetach: () => token.cancel()
        }, result);
    }
    exports.css = css;
    function recompute(fragments, input) {
        let result = '';
        for (let i = 0; i < fragments.length; i++) {
            result += fragments[i];
            if (input[i]) {
                if (input[i] instanceof data_source_js_13.DataSource || input[i] instanceof duplex_data_source_js_9.DuplexDataSource || input[i] instanceof stream_js_3.Stream) {
                    result += input[i].value;
                }
                else {
                    result += input[i];
                }
            }
        }
        return result;
    }
});
define("src/builtin_components/router", ["require", "exports", "src/aurumjs", "src/stream/data_source", "src/stream/data_source_operators"], function (require, exports, aurumjs_js_2, data_source_js_14, data_source_operators_js_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultRoute = exports.Route = exports.AurumRouter = void 0;
    function AurumRouter(props, children, api) {
        const resolvedChildren = (0, aurumjs_js_2.resolveChildren)(children, api.cancellationToken, (c) => {
            if (c.factory !== Route && c.factory !== DefaultRoute) {
                throw new Error('Aurum Router only accepts Route and DefaultRoute instances as children');
            }
        }).filter(Boolean);
        resolvedChildren
            .reduce((acc, c) => {
            if (c.factory === DefaultRoute) {
                return acc + 1;
            }
            else {
                return acc;
            }
        }, 0, api.cancellationToken)
            .listenAndRepeat((count) => {
            if (count > 1) {
                throw new Error(`Too many default routes only 0 or 1 allowed. Found ${count}`);
            }
        });
        const urlDataSource = new data_source_js_14.DataSource();
        if (typeof window !== 'undefined') {
            (0, aurumjs_js_2.urlHashEmitter)(urlDataSource, true, api.cancellationToken);
        }
        const activeRoute = new data_source_js_14.DataSource();
        activeRoute.transform((0, data_source_operators_js_4.dsUnique)(), (0, data_source_operators_js_4.dsDiff)(), (0, data_source_operators_js_4.dsTap)(({ newValue, oldValue }) => {
            var _a, _b, _c, _d;
            if (oldValue) {
                (_b = (_a = oldValue.props) === null || _a === void 0 ? void 0 : _a.onNavigateFrom) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
            if (newValue) {
                (_d = (_c = newValue.props) === null || _c === void 0 ? void 0 : _c.onNavigateTo) === null || _d === void 0 ? void 0 : _d.call(_c);
            }
        }));
        return urlDataSource
            .transform((0, data_source_operators_js_4.dsUnique)(), api.cancellationToken)
            .withInitial(urlDataSource.value)
            .transform((0, data_source_operators_js_4.dsMap)((p) => selectRoute(p, resolvedChildren, activeRoute)));
    }
    exports.AurumRouter = AurumRouter;
    function selectRoute(url, routes, activeRoute) {
        let selected;
        if (url === undefined || url === null) {
            selected = routes.find((r) => r.factory === DefaultRoute);
        }
        else {
            if (routes.find((r) => { var _a; return ((_a = r.props) === null || _a === void 0 ? void 0 : _a.href) === url; })) {
                selected = routes.find((r) => { var _a; return ((_a = r.props) === null || _a === void 0 ? void 0 : _a.href) === url; });
            }
            else {
                const segments = url.split('/');
                segments.pop();
                while (segments.length) {
                    const path = segments.join('/');
                    if (routes.find((r) => { var _a; return ((_a = r.props) === null || _a === void 0 ? void 0 : _a.href) === path; })) {
                        selected = routes.find((r) => { var _a; return ((_a = r.props) === null || _a === void 0 ? void 0 : _a.href) === path; });
                        break;
                    }
                    segments.pop();
                }
                if (!selected) {
                    selected = routes.find((r) => r.factory === DefaultRoute);
                }
            }
        }
        if (selected) {
            activeRoute.update(selected);
            return selected.children;
        }
        else {
            activeRoute.update(undefined);
            return undefined;
        }
    }
    function Route(props, children) {
        return undefined;
    }
    exports.Route = Route;
    function DefaultRoute(props, children) {
        return undefined;
    }
    exports.DefaultRoute = DefaultRoute;
});
define("src/builtin_components/suspense", ["require", "exports", "src/aurumjs"], function (require, exports, aurumjs_js_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Suspense = void 0;
    function Suspense(props, children, api) {
        return (aurumjs_js_3.Aurum.factory(aurumjs_js_3.ErrorBoundary, { suspenseFallback: props === null || props === void 0 ? void 0 : props.fallback, errorFallback: (error) => {
                throw error;
            } }, children));
    }
    exports.Suspense = Suspense;
});
define("src/builtin_components/error_boundary", ["require", "exports", "src/rendering/aurum_element", "src/stream/data_source"], function (require, exports, aurum_element_js_4, data_source_js_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorBoundary = void 0;
    function ErrorBoundary(props, children, api) {
        const data = new data_source_js_15.DataSource(props === null || props === void 0 ? void 0 : props.suspenseFallback);
        const renderFallbackError = typeof (props === null || props === void 0 ? void 0 : props.errorFallback) === 'function' ? props.errorFallback : (error) => props === null || props === void 0 ? void 0 : props.errorFallback;
        const lc = (0, aurum_element_js_4.createLifeCycle)();
        api.onDetach(() => lc.onDetach());
        function onDone(res) {
            if (!api.cancellationToken.isCanceled) {
                data.update(res);
                lc.onAttach();
            }
        }
        function onError(error) {
            console.error(error);
            if (!api.cancellationToken.isCanceled) {
                data.update(renderFallbackError(error));
            }
        }
        async function handleRenderedChildren(res) {
            if (res instanceof Promise) {
                res.then(handleRenderedChildren, onError);
            }
            else {
                const nestedRendered = api.prerender(res, lc);
                if (nestedRendered.some((s) => s instanceof Promise)) {
                    await Promise.all(nestedRendered).then(handleRenderedChildren, onError);
                }
                else {
                    onDone(nestedRendered);
                }
            }
        }
        async function renderChildren() {
            try {
                const rendered = api.prerender(children, lc);
                await handleRenderedChildren(rendered);
            }
            catch (error) {
                onError(error);
            }
        }
        renderChildren();
        return data;
    }
    exports.ErrorBoundary = ErrorBoundary;
});
define("src/builtin_components/switch", ["require", "exports", "src/rendering/aurum_element", "src/stream/data_source_operators", "src/utilities/cancellation_token"], function (require, exports, aurum_element_js_5, data_source_operators_js_5, cancellation_token_js_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultSwitchCase = exports.SwitchCase = exports.Switch = void 0;
    function Switch(props, children, api) {
        children = [].concat.apply([], children.filter((c) => !!c));
        if (children.some((c) => !c[aurum_element_js_5.aurumElementModelIdentitiy] ||
            !(c.factory === SwitchCase || c.factory === DefaultSwitchCase))) {
            throw new Error('Switch only accepts SwitchCase as children');
        }
        if (children.filter((c) => c.factory === DefaultSwitchCase).length > 1) {
            throw new Error('Too many default switch cases only 0 or 1 allowed');
        }
        const cleanUp = new cancellation_token_js_8.CancellationToken();
        api.onDetach(() => {
            cleanUp.cancel();
        });
        const u = props.state.transform((0, data_source_operators_js_5.dsUnique)(), cleanUp);
        return u.withInitial(props.state.value).transform((0, data_source_operators_js_5.dsMap)((state) => selectCase(state, children)));
    }
    exports.Switch = Switch;
    function selectCase(state, children) {
        var _a, _b, _c;
        return (_b = (_a = children.find((c) => { var _a; return ((_a = c.props) === null || _a === void 0 ? void 0 : _a.when) === state; })) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : (_c = children.find((p) => p.factory === DefaultSwitchCase)) === null || _c === void 0 ? void 0 : _c.children;
    }
    function SwitchCase(props, children) {
        return undefined;
    }
    exports.SwitchCase = SwitchCase;
    function DefaultSwitchCase(props, children) {
        return undefined;
    }
    exports.DefaultSwitchCase = DefaultSwitchCase;
});
define("src/utilities/sources", ["require", "exports", "src/aurumjs", "src/stream/data_source", "src/stream/duplex_data_source", "src/stream/stream"], function (require, exports, aurumjs_js_4, data_source_js_16, duplex_data_source_js_10, stream_js_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwrapObjectRecursive = exports.getValueOf = void 0;
    function getValueOf(sourceOrPrimitive) {
        if (sourceOrPrimitive instanceof data_source_js_16.DataSource || sourceOrPrimitive instanceof duplex_data_source_js_10.DuplexDataSource || sourceOrPrimitive instanceof stream_js_4.Stream) {
            return sourceOrPrimitive.value;
        }
        if (sourceOrPrimitive instanceof data_source_js_16.ArrayDataSource) {
            return sourceOrPrimitive.getData();
        }
        return sourceOrPrimitive;
    }
    exports.getValueOf = getValueOf;
    function unwrapObjectRecursive(object) {
        if (object instanceof data_source_js_16.DataSource || object instanceof duplex_data_source_js_10.DuplexDataSource || object instanceof stream_js_4.Stream) {
            //@ts-ignore
            return unwrapObjectRecursive(object.value);
        }
        if (object instanceof data_source_js_16.ArrayDataSource) {
            //@ts-ignore
            return unwrapObjectRecursive(object.toArray());
        }
        if (object instanceof aurumjs_js_4.ObjectDataSource) {
            //@ts-ignore
            return unwrapObjectRecursive(object.getData());
        }
        if (object instanceof duplex_data_source_js_10.DuplexDataSource) {
            //@ts-ignore
            return unwrapObjectRecursive(object.value);
        }
        if (object instanceof stream_js_4.Stream) {
            //@ts-ignore
            return unwrapObjectRecursive(object.value);
        }
        if (Array.isArray(object)) {
            //@ts-ignore
            return object.map(unwrapObjectRecursive);
        }
        if (object instanceof Object) {
            const result = {};
            for (const key in object) {
                result[key] = unwrapObjectRecursive(object[key]);
            }
            return result;
        }
        //@ts-ignore
        return object;
    }
    exports.unwrapObjectRecursive = unwrapObjectRecursive;
});
define("src/stream/tree_data_source", ["require", "exports", "src/utilities/cancellation_token", "src/utilities/event_emitter", "src/utilities/sources", "src/stream/data_source"], function (require, exports, cancellation_token_js_9, event_emitter_js_7, sources_js_1, data_source_js_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeDataSource = void 0;
    class TreeDataSource {
        constructor(childrenKey, roots) {
            this.watchCount = 0;
            this.childrenKey = childrenKey;
            this.roots = data_source_js_17.ArrayDataSource.toArrayDataSource(roots);
            this.updateEvent = new event_emitter_js_7.EventEmitter();
        }
        watch(cancellationToken) {
            this.watchCount++;
            cancellationToken.addCancelable(() => {
                this.watchCount--;
                if (this.watchCount === 0) {
                    this.watchToken.cancel();
                    this.watchToken = undefined;
                }
            });
            if (!this.watchToken) {
                this.watchToken = new cancellation_token_js_9.CancellationToken();
                const watchMap = new Map();
                if (this.roots instanceof data_source_js_17.ArrayDataSource) {
                    this.roots.listen((change) => {
                        this.watchHandleChange(change, undefined, watchMap);
                    }, this.watchToken);
                }
                for (const root of this.roots) {
                    for (const { node } of this.iterateLevelWithMetaData(root, this.roots.length.value)) {
                        if (node[this.childrenKey] instanceof data_source_js_17.ArrayDataSource) {
                            watchMap.set(node, new cancellation_token_js_9.CancellationToken());
                            this.watchToken.chain(watchMap.get(node));
                            node[this.childrenKey].listenAndRepeat((change) => {
                                this.watchHandleChange(change, node, watchMap);
                            }, watchMap.get(node));
                        }
                    }
                }
            }
        }
        watchHandleChange(change, parent, watchMap) {
            var _a;
            switch (change.operation) {
                case 'add':
                    let i = 0;
                    for (const item of change.items) {
                        this.updateEvent.fire({
                            changedNode: item,
                            index: change.index + i++,
                            parentNode: parent,
                            operation: 'added'
                        });
                        if (item[this.childrenKey] instanceof data_source_js_17.ArrayDataSource) {
                            watchMap.set(item, new cancellation_token_js_9.CancellationToken());
                            this.watchToken.chain(watchMap.get(item));
                            item[this.childrenKey].listenAndRepeat((change) => {
                                this.watchHandleChange(change, item, watchMap);
                            }, watchMap.get(item));
                        }
                    }
                    break;
                case 'remove':
                    let j = 0;
                    for (const item of change.items) {
                        (_a = watchMap.get(item)) === null || _a === void 0 ? void 0 : _a.cancel();
                        this.updateEvent.fire({
                            changedNode: item,
                            index: change.index + j++,
                            parentNode: parent,
                            operation: 'deleted'
                        });
                    }
                    break;
                case 'merge':
                    throw new Error('Not implemented');
                case 'replace':
                    this.updateEvent.fire({
                        changedNode: change.target,
                        index: change.index,
                        parentNode: parent,
                        operation: 'deleted'
                    });
                    this.updateEvent.fire({
                        changedNode: change.items[0],
                        index: change.index,
                        parentNode: parent,
                        operation: 'added'
                    });
                    break;
            }
        }
        listen(callback, cancellationToken) {
            this.watch(cancellationToken);
            return this.updateEvent.subscribe(callback, cancellationToken).cancel;
        }
        listenAndRepeat(callback, cancellationToken) {
            for (const { parent, node, index } of this.iterateLevelWithMetaData(this.roots, 0)) {
                callback({
                    changedNode: node,
                    index,
                    parentNode: parent,
                    operation: 'added'
                });
            }
            return this.listen(callback, cancellationToken);
        }
        adaptNodeList(nodes, token, nodeList = new data_source_js_17.ArrayDataSource()) {
            const adaptMap = new Map();
            nodes.listenAndRepeat((change) => {
                switch (change.operation) {
                    case 'add':
                        for (const item of change.items) {
                            this.addItem(adaptMap, token, item, nodeList);
                        }
                        break;
                    case 'remove':
                        for (const item of change.items) {
                            this.removeItem(nodeList, adaptMap, item);
                        }
                        break;
                    case 'merge':
                        throw new Error('Not implemented');
                    case 'replace':
                        this.removeItem(nodeList, adaptMap, change.target);
                        this.addItem(adaptMap, token, change.items[0], nodeList);
                        break;
                }
            }, token);
            return nodeList;
        }
        adaptNodeTree(parent, nodes, mapper, newKey, token) {
            nodes = data_source_js_17.ArrayDataSource.toArrayDataSource(nodes);
            const newRoots = nodes.map(mapper);
            if (parent) {
                parent[newKey] = newRoots;
            }
            nodes.listenAndRepeat((change) => {
                switch (change.operation) {
                    case 'add':
                        let i = change.index;
                        for (const item of change.items) {
                            this.adaptNodeTree(newRoots.get(i++), item[newKey], mapper, newKey, token);
                        }
                        break;
                    case 'merge':
                        throw new Error('Not implemented');
                    case 'replace':
                        this.adaptNodeTree(newRoots[change.index], change.items[0][newKey], mapper, newKey, token);
                        break;
                }
            }, token);
            return newRoots;
        }
        map(mapper, newKey = this.childrenKey, cancellationToken) {
            return new TreeDataSource(newKey, this.adaptNodeTree(undefined, this.roots, mapper, newKey, cancellationToken));
        }
        addItem(adaptMap, parentToken, item, nodeList) {
            nodeList.push(item);
            adaptMap.set(item, new cancellation_token_js_9.CancellationToken());
            parentToken.chain(adaptMap.get(item));
            const list = data_source_js_17.ArrayDataSource.toArrayDataSource(item[this.childrenKey]);
            this.adaptNodeList(list, adaptMap.get(item), nodeList);
        }
        removeItem(nodeList, adaptMap, item) {
            adaptMap.get(item).cancel();
            nodeList.remove(item);
        }
        createArrayDataSourceOfNodes(cancellationToken) {
            return this.adaptNodeList(this.roots, cancellationToken);
        }
        *[Symbol.iterator]() {
            for (const root of this.roots) {
                yield* this.iterateLevel(root);
            }
            return;
        }
        *iterateWithMetaData() {
            let i = 0;
            for (const root of this.roots) {
                yield* this.iterateLevelWithMetaData(root, this.roots.length.value, undefined, i);
            }
            return;
        }
        *iterateLevelWithMetaData(node, lastIndex, parent, index = 0, level = 0) {
            yield { node: node, parent, index, level, lastIndex };
            let i = 0;
            for (const child of node[this.childrenKey]) {
                yield* this.iterateLevelWithMetaData(child, (0, sources_js_1.getValueOf)(node[this.childrenKey].length), node, i++, level + 1);
            }
        }
        *iterateLevel(level) {
            yield level;
            for (const child of level[this.childrenKey]) {
                yield* this.iterateLevel(child);
            }
        }
    }
    exports.TreeDataSource = TreeDataSource;
});
define("src/stream/emitters", ["require", "exports", "src/stream/data_source", "src/stream/stream", "src/stream/duplex_data_source", "src/utilities/cancellation_token", "src/stream/data_source_operators"], function (require, exports, data_source_js_18, stream_js_5, duplex_data_source_js_11, cancellation_token_js_10, data_source_operators_js_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tweenEmitter = exports.animate = exports.windowSizeEmitter = exports.urlHashEmitter = exports.intervalEmitter = void 0;
    /**
     * Convenience function to update a stream at fixed intervals
     */
    function intervalEmitter(target, interval, value, cancellationToken) {
        (cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_10.CancellationToken()).setInterval(() => {
            updateSource(target, value);
        }, interval);
    }
    exports.intervalEmitter = intervalEmitter;
    function updateSource(target, value) {
        if (target instanceof data_source_js_18.ArrayDataSource) {
            target.push(value);
        }
        else if (target instanceof duplex_data_source_js_11.DuplexDataSource) {
            target.updateDownstream(value);
        }
        else {
            target.update(value);
        }
    }
    function urlHashEmitter(target, stripInHashParameters = false, cancellationToken) {
        updateSource(target, stripInHashParameters ? getUrlHash() : location.hash);
        (cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : new cancellation_token_js_10.CancellationToken()).registerDomEvent(window, 'hashchange', () => {
            updateSource(target, stripInHashParameters ? getUrlHash() : location.hash);
        });
    }
    exports.urlHashEmitter = urlHashEmitter;
    function getUrlHash() {
        const hash = location.hash.substring(1);
        if (hash.includes('?')) {
            return hash.substring(0, hash.indexOf('?'));
        }
        else if (hash.includes('#')) {
            return hash.substring(0, hash.indexOf('#'));
        }
        else {
            return hash;
        }
    }
    /**
     * Convenience function to stream the window size to a data source
     */
    function windowSizeEmitter(target, debounce = 100, cancellationToken) {
        cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : (cancellationToken = new cancellation_token_js_10.CancellationToken());
        const updateStream = new data_source_js_18.DataSource();
        cancellationToken.registerDomEvent(window, 'resize', () => {
            updateStream.update();
        });
        target.assign({
            width: window.innerWidth,
            height: window.innerHeight
        });
        updateStream.transform((0, data_source_operators_js_6.dsDebounce)(debounce), (0, data_source_operators_js_6.dsTap)(() => target.assign({
            width: window.innerWidth,
            height: window.innerHeight
        })));
    }
    exports.windowSizeEmitter = windowSizeEmitter;
    /**
     * Calls the callback every animation frame with a number from 0 to 1 indicating how far along in the animation timeline it is.
     *
     */
    function animate(cb, time, cancellationToken) {
        return new Promise((resolve) => {
            const animationToken = new cancellation_token_js_10.CancellationToken();
            if (cancellationToken) {
                cancellationToken.chain(animationToken);
            }
            animationToken.addCancelable(resolve);
            let start = Date.now();
            (0, cancellation_token_js_10.registerAnimationLoop)(() => {
                const progress = Math.min(1, (Date.now() - start) / time);
                cb(progress);
                if (progress === 1) {
                    animationToken.cancel();
                }
            }, animationToken);
        });
    }
    exports.animate = animate;
    /**
     * Convenience function to stream animate to a datasource
     */
    function tweenEmitter(target, duration, startValue, endValue, interpolation, cancellationToken) {
        if (target instanceof data_source_js_18.DataSource || target instanceof duplex_data_source_js_11.DuplexDataSource || target instanceof stream_js_5.Stream) {
            if (startValue === endValue) {
                return new Promise((res) => setTimeout(res, duration));
            }
        }
        return animate((progress) => {
            if (interpolation) {
                progress = interpolation(progress);
            }
            const value = startValue + (endValue - startValue) * progress;
            if (target instanceof data_source_js_18.ArrayDataSource) {
                target.push(value);
            }
            else if (target instanceof duplex_data_source_js_11.DuplexDataSource) {
                target.updateDownstream(value);
            }
            else {
                target.update(value);
            }
        }, duration, cancellationToken);
    }
    exports.tweenEmitter = tweenEmitter;
});
define("src/nodes/string_adapter", ["require", "exports", "src/rendering/aurum_element", "src/stream/data_source", "src/stream/duplex_data_source", "src/utilities/cancellation_token"], function (require, exports, aurum_element_js_6, data_source_js_19, duplex_data_source_js_12, cancellation_token_js_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aurumToString = void 0;
    async function aurumToString(content, config = {}) {
        if (content === undefined || content === null) {
            return '';
        }
        if (Array.isArray(content)) {
            const result = [];
            for (const item of content) {
                result.push(await aurumToString(item));
            }
            return result.join('');
        }
        if (content instanceof Promise) {
            return aurumToString(await content);
        }
        if (['number', 'string', 'bigint', 'boolean'].includes(typeof content)) {
            return content.toString();
        }
        else if (content instanceof data_source_js_19.DataSource) {
            return aurumToString(content.value);
        }
        else if (content instanceof duplex_data_source_js_12.DuplexDataSource) {
            return aurumToString(content.value);
        }
        else if (content instanceof data_source_js_19.ArrayDataSource) {
            return aurumToString(content.getData());
        }
        else {
            const item = content;
            if (!item.isIntrinsic) {
                return aurumToString(item.factory(item.props, item.children, (0, aurum_element_js_6.createAPI)({
                    attachCalls: [],
                    sessionToken: new cancellation_token_js_11.CancellationToken(),
                    tokens: []
                })));
            }
            if (config.tagBlacklist && config.tagBlacklist.includes(item.name)) {
                return '';
            }
            if (config.tagWhitelist && !config.tagWhitelist.includes(item.name)) {
                return '';
            }
            let propString = ' ';
            let children = '';
            if (item.children) {
                children = await aurumToString(item.children);
            }
            for (const prop in item.props) {
                if (config.attributeBlacklist && config.attributeBlacklist.includes(prop)) {
                    continue;
                }
                if (config.attributeWhitelist && !config.attributeWhitelist.includes(prop)) {
                    continue;
                }
                if (item.props[prop] != undefined) {
                    propString += `${prop}="${item.props[prop].toString()}" `;
                }
            }
            return `<${item.name}${propString.trimRight()}>${children}</${item.name}>`;
        }
    }
    exports.aurumToString = aurumToString;
});
define("src/utilities/transclusion", ["require", "exports", "src/stream/data_source"], function (require, exports, data_source_js_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveChildren = void 0;
    function resolveChildren(children, cancellationToken, validation) {
        const chunks = process(children);
        const result = data_source_js_20.ArrayDataSource.fromMultipleSources(chunks, cancellationToken);
        if (validation) {
            result.listen((c) => {
                switch (c.operation) {
                    case 'add':
                    case 'replace':
                    case 'merge':
                        for (const item of c.items) {
                            validation(item);
                        }
                        break;
                }
            }, cancellationToken);
        }
        return result;
    }
    exports.resolveChildren = resolveChildren;
    function process(children) {
        const chunks = [];
        let currentChunk = [];
        for (const child of children) {
            if (child instanceof data_source_js_20.ArrayDataSource) {
                if (currentChunk.length) {
                    chunks.push(currentChunk);
                    currentChunk.length = 0;
                }
                chunks.push(child);
            }
            else if (child instanceof data_source_js_20.DataSource) {
                currentChunk.push(child);
            }
            else if (child instanceof data_source_js_20.DataSource) {
                currentChunk.push(child);
            }
            else if (child instanceof data_source_js_20.DataSource) {
                currentChunk.push(child);
            }
            else if (Array.isArray(child)) {
                chunks.push(...process(child));
            }
            else {
                currentChunk.push(child);
            }
        }
        if (currentChunk.length) {
            chunks.push(currentChunk);
        }
        return chunks;
    }
});
define("src/aurumjs", ["require", "exports", "src/rendering/webcomponent", "src/rendering/aurum_element", "src/rendering/aurum_style", "src/builtin_components/router", "src/builtin_components/suspense", "src/builtin_components/error_boundary", "src/builtin_components/switch", "src/stream/data_source", "src/stream/duplex_data_source", "src/stream/object_data_source", "src/stream/tree_data_source", "src/stream/data_source_operators", "src/stream/duplex_data_source_operators", "src/stream/operator_model", "src/stream/stream", "src/utilities/aurum", "src/utilities/cancellation_token", "src/utilities/event_emitter", "src/utilities/classname", "src/utilities/sources", "src/stream/emitters", "src/nodes/string_adapter", "src/utilities/transclusion", "src/builtin_components/dom_adapter", "src/debug_mode", "src/aurum_server/aurum_server_client"], function (require, exports, webcomponent_js_1, aurum_element_js_7, aurum_style_js_1, router_js_1, suspense_js_1, error_boundary_js_1, switch_js_1, data_source_js_21, duplex_data_source_js_13, object_data_source_js_1, tree_data_source_js_1, data_source_operators_js_7, duplex_data_source_operators_js_2, operator_model_js_5, stream_js_6, aurum_js_3, cancellation_token_js_12, event_emitter_js_8, classname_js_2, sources_js_2, emitters_js_1, string_adapter_js_1, transclusion_js_1, dom_adapter_js_6, debug_mode_js_3, aurum_server_client_js_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRemoteFunction = exports.RemoteProtocol = exports.enableDiagnosticMode = exports.enableDebugMode = exports.debugMode = exports.aurumToHTML = exports.aurumElementModelIdentitiy = exports.AurumElement = exports.createRenderSession = exports.createLifeCycle = exports.createAPI = exports.ArrayAurumElement = exports.SingularAurumElement = void 0;
    __exportStar(webcomponent_js_1, exports);
    Object.defineProperty(exports, "SingularAurumElement", { enumerable: true, get: function () { return aurum_element_js_7.SingularAurumElement; } });
    Object.defineProperty(exports, "ArrayAurumElement", { enumerable: true, get: function () { return aurum_element_js_7.ArrayAurumElement; } });
    Object.defineProperty(exports, "createAPI", { enumerable: true, get: function () { return aurum_element_js_7.createAPI; } });
    Object.defineProperty(exports, "createLifeCycle", { enumerable: true, get: function () { return aurum_element_js_7.createLifeCycle; } });
    Object.defineProperty(exports, "createRenderSession", { enumerable: true, get: function () { return aurum_element_js_7.createRenderSession; } });
    Object.defineProperty(exports, "AurumElement", { enumerable: true, get: function () { return aurum_element_js_7.AurumElement; } });
    Object.defineProperty(exports, "aurumElementModelIdentitiy", { enumerable: true, get: function () { return aurum_element_js_7.aurumElementModelIdentitiy; } });
    __exportStar(aurum_style_js_1, exports);
    __exportStar(router_js_1, exports);
    __exportStar(suspense_js_1, exports);
    __exportStar(error_boundary_js_1, exports);
    __exportStar(switch_js_1, exports);
    __exportStar(data_source_js_21, exports);
    __exportStar(duplex_data_source_js_13, exports);
    __exportStar(object_data_source_js_1, exports);
    __exportStar(tree_data_source_js_1, exports);
    __exportStar(data_source_operators_js_7, exports);
    __exportStar(duplex_data_source_operators_js_2, exports);
    __exportStar(operator_model_js_5, exports);
    __exportStar(stream_js_6, exports);
    __exportStar(aurum_js_3, exports);
    __exportStar(cancellation_token_js_12, exports);
    __exportStar(event_emitter_js_8, exports);
    __exportStar(classname_js_2, exports);
    __exportStar(sources_js_2, exports);
    __exportStar(emitters_js_1, exports);
    __exportStar(string_adapter_js_1, exports);
    __exportStar(transclusion_js_1, exports);
    Object.defineProperty(exports, "aurumToHTML", { enumerable: true, get: function () { return dom_adapter_js_6.aurumToHTML; } });
    Object.defineProperty(exports, "debugMode", { enumerable: true, get: function () { return debug_mode_js_3.debugMode; } });
    Object.defineProperty(exports, "enableDebugMode", { enumerable: true, get: function () { return debug_mode_js_3.enableDebugMode; } });
    Object.defineProperty(exports, "enableDiagnosticMode", { enumerable: true, get: function () { return debug_mode_js_3.enableDiagnosticMode; } });
    Object.defineProperty(exports, "RemoteProtocol", { enumerable: true, get: function () { return aurum_server_client_js_4.RemoteProtocol; } });
    Object.defineProperty(exports, "getRemoteFunction", { enumerable: true, get: function () { return aurum_server_client_js_4.getRemoteFunction; } });
});
define("test/cancellation_token.test", ["require", "exports", "chai", "sinon", "src/aurumjs"], function (require, exports, chai_1, sinon, aurumjs_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('cancellation token', () => {
        let clock;
        beforeEach(() => {
            clock = sinon.useFakeTimers();
        });
        afterEach(() => {
            clock.uninstall();
        });
        it('setTimeout should not fire if cancel occurs first', () => {
            const token = new aurumjs_1.CancellationToken();
            token.setTimeout(() => {
                (0, chai_1.assert)(false);
            });
            token.cancel();
            clock.tick(100);
        });
        it('setTimeout should fire if cancel occurs after', () => {
            return new Promise((resolve) => {
                const token = new aurumjs_1.CancellationToken();
                token.setTimeout(() => {
                    resolve();
                });
                clock.tick(100);
                token.cancel();
            });
        });
        it('setTimeout should be removed from list of cancellables once fired', () => {
            const token = new aurumjs_1.CancellationToken();
            token.setTimeout(() => { });
            chai_1.assert.equal(token['cancelables'].length, 1);
            token.setTimeout(() => { });
            chai_1.assert.equal(token['cancelables'].length, 2);
            token.setTimeout(() => { });
            chai_1.assert.equal(token['cancelables'].length, 3);
            clock.tick(100);
            chai_1.assert.equal(token['cancelables'].length, 0);
            token.cancel();
        });
    });
});
define("test/test_utils", ["require", "exports", "src/aurumjs"], function (require, exports, aurumjs_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attachToTestRoot = exports.getTestRoot = exports.sleep = void 0;
    function sleep(time) {
        return new Promise((r) => {
            setTimeout(r, time);
        });
    }
    exports.sleep = sleep;
    function getTestRoot() {
        return document.getElementById('target');
    }
    exports.getTestRoot = getTestRoot;
    function attachToTestRoot(component) {
        return aurumjs_2.Aurum.attach(component, document.getElementById('target'));
    }
    exports.attachToTestRoot = attachToTestRoot;
});
define("test/data_sources/utils", ["require", "exports", "chai", "src/aurumjs", "src/stream/data_source"], function (require, exports, chai_2, aurumjs_3, data_source_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Data source utils', () => {
        it('should unwrap recursively', () => {
            const wrapped = {
                a: {
                    b: new data_source_1.DataSource(1),
                    c: new data_source_1.ArrayDataSource([2, 3])
                },
                d: new data_source_1.DataSource(3),
                e: new data_source_1.ArrayDataSource([new data_source_1.DataSource(1), new data_source_1.DataSource(2)]),
                f: new aurumjs_3.ObjectDataSource({
                    g: new data_source_1.DataSource(1),
                    h: new data_source_1.ArrayDataSource([2, 3]),
                    i: 3
                })
            };
            chai_2.assert.deepEqual((0, aurumjs_3.unwrapObjectRecursive)(wrapped), {
                a: {
                    b: 1,
                    c: [2, 3]
                },
                d: 3,
                e: [1, 2],
                f: {
                    g: 1,
                    h: [2, 3],
                    i: 3
                }
            });
        });
    });
});
define("test/data_sources/array_data_source.test", ["require", "exports", "chai", "src/aurumjs"], function (require, exports, chai_3, aurumjs_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('ArrayDatasource', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('should render the array data source value', () => {
            const ads = new aurumjs_4.ArrayDataSource();
            attachToken = aurumjs_4.Aurum.attach(aurumjs_4.Aurum.factory("div", null, ads), document.getElementById('target'));
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ads.push(1, 2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12');
            ads.push(7);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '127');
            ads.removeAt(1);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '17');
        });
        it('should render the array data source value 2', () => {
            const ads = new aurumjs_4.ArrayDataSource();
            attachToken = aurumjs_4.Aurum.attach(aurumjs_4.Aurum.factory("div", null, ads), document.getElementById('target'));
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ads.push([1, 2]);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12');
            ads.push([5, 6, 7]);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12567');
            ads.push(['a', 'b', 'c']);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12567abc');
            ads.removeAt(1);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12abc');
            ads.push(['y', new aurumjs_4.ArrayDataSource([1, 2, 3, 4]), 'z']);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12abcy1234z');
        });
        it('should sync dom when swapping', () => {
            const ads = new aurumjs_4.ArrayDataSource();
            attachToken = aurumjs_4.Aurum.attach(aurumjs_4.Aurum.factory("div", null, ads.map((e) => (aurumjs_4.Aurum.factory("li", null, e)))), document.getElementById('target'));
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ads.appendArray([1, 2]);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12');
            ads.swap(0, 1);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '21');
            ads.swap(1, 0);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12');
            ads.appendArray([3, 4]);
            ads.swap(1, 3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1432');
            ads.appendArray([5, 6, 7]);
            ads.swap(4, 1);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1532467');
            ads.swap(1, 1);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1532467');
            ads.swap(1, 2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1352467');
            ads.swap(2, 3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1325467');
            ads.swap(2, 3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1352467');
        });
        it('should store values', () => {
            let ds = new aurumjs_4.ArrayDataSource([1, 2, 3]);
            chai_3.assert.deepEqual(ds.toArray(), [1, 2, 3]);
        });
        it('should be iterable', () => {
            let ds = new aurumjs_4.ArrayDataSource([1, 2, 3]);
            const test = [new Error('Should not get here'), 3, 2, 1];
            for (const v of ds) {
                chai_3.assert.deepEqual(v, test.pop());
            }
        });
        it('push', () => {
            let ds = new aurumjs_4.ArrayDataSource([1, 2, 3]);
            ds.push(4, 5);
            chai_3.assert.deepEqual(ds.toArray(), [1, 2, 3, 4, 5]);
        });
        it('splice', () => {
            let ds = new aurumjs_4.ArrayDataSource([1, 2, 3, 4, 5, 6]);
            let control = [1, 2, 3, 4, 5, 6];
            ds.splice(2, 2);
            control.splice(2, 2);
            chai_3.assert.deepEqual(ds.toArray(), control);
            ds = new aurumjs_4.ArrayDataSource([1, 2, 3, 4, 5, 6]);
            control = [1, 2, 3, 4, 5, 6];
            ds.splice(3, 0, 1, 2);
            control.splice(3, 0, 1, 2);
            chai_3.assert.deepEqual(ds.toArray(), control);
            ds = new aurumjs_4.ArrayDataSource([1, 2, 3, 4, 5, 6]);
            control = [1, 2, 3, 4, 5, 6];
            ds.splice(4, 1, 4, 5);
            control.splice(4, 1, 4, 5);
            chai_3.assert.deepEqual(ds.toArray(), control);
        });
        it('from multiple', () => {
            const ds1 = new aurumjs_4.ArrayDataSource();
            const ds2 = new aurumjs_4.ArrayDataSource();
            const ds3 = new aurumjs_4.ArrayDataSource();
            const ds4 = new aurumjs_4.ArrayDataSource();
            let ds = aurumjs_4.ArrayDataSource.fromMultipleSources([ds1, ds2, [1, 2, 3], ds3, ds4, [1, 2]]);
            chai_3.assert.deepEqual(ds.toArray(), [1, 2, 3, 1, 2]);
            ds3.push(9, 8);
            chai_3.assert.deepEqual(ds.toArray(), [1, 2, 3, 9, 8, 1, 2]);
            ds1.push(1, 2, 3, 4);
            chai_3.assert.deepEqual(ds.toArray(), [1, 2, 3, 4, 1, 2, 3, 9, 8, 1, 2]);
            ds1.removeLeft(2);
            chai_3.assert.deepEqual(ds.toArray(), [3, 4, 1, 2, 3, 9, 8, 1, 2]);
            ds3.clear();
            chai_3.assert.deepEqual(ds.toArray(), [3, 4, 1, 2, 3, 1, 2]);
            ds4.push(4, 4, 4);
            chai_3.assert.deepEqual(ds.toArray(), [3, 4, 1, 2, 3, 4, 4, 4, 1, 2]);
            ds2.push(3, 3, 3);
            chai_3.assert.deepEqual(ds.toArray(), [3, 4, 3, 3, 3, 1, 2, 3, 4, 4, 4, 1, 2]);
            ds2.insertAt(2, 5);
            chai_3.assert.deepEqual(ds.toArray(), [3, 4, 3, 3, 5, 3, 1, 2, 3, 4, 4, 4, 1, 2]);
        });
        it('from multiple 2', () => {
            const ds1 = new aurumjs_4.ArrayDataSource();
            const ds2 = new aurumjs_4.ArrayDataSource();
            const ds3 = new aurumjs_4.ArrayDataSource();
            const ds4 = new aurumjs_4.ArrayDataSource();
            const ds = new aurumjs_4.DataSource();
            const dds = new aurumjs_4.DuplexDataSource();
            let ads = aurumjs_4.ArrayDataSource.fromMultipleSources([ds1, ds, ds2, [1, 2, 3], ds3, ds4, [1, 2], dds]);
            chai_3.assert.deepEqual(ads.toArray(), [1, 2, 3, 1, 2]);
            ds.update(10);
            chai_3.assert.deepEqual(ads.toArray(), [10, 1, 2, 3, 1, 2]);
            ds.update(20);
            chai_3.assert.deepEqual(ads.toArray(), [20, 1, 2, 3, 1, 2]);
            ds.update(undefined);
            chai_3.assert.deepEqual(ads.toArray(), [1, 2, 3, 1, 2]);
            ds.update([10, 20]);
            chai_3.assert.deepEqual(ads.toArray(), [10, 20, 1, 2, 3, 1, 2]);
            ds1.push(9);
            ds2.push(8);
            ds.update(10);
            chai_3.assert.deepEqual(ads.toArray(), [9, 10, 8, 1, 2, 3, 1, 2]);
            ds.update(20);
            chai_3.assert.deepEqual(ads.toArray(), [9, 20, 8, 1, 2, 3, 1, 2]);
            ds.update(undefined);
            chai_3.assert.deepEqual(ads.toArray(), [9, 8, 1, 2, 3, 1, 2]);
            ds.update([10, 20]);
            chai_3.assert.deepEqual(ads.toArray(), [9, 10, 20, 8, 1, 2, 3, 1, 2]);
            dds.updateDownstream(100);
            chai_3.assert.deepEqual(ads.toArray(), [9, 10, 20, 8, 1, 2, 3, 1, 2, 100]);
            ds1.push(7);
            chai_3.assert.deepEqual(ads.toArray(), [9, 7, 10, 20, 8, 1, 2, 3, 1, 2, 100]);
            dds.updateDownstream(200);
            chai_3.assert.deepEqual(ads.toArray(), [9, 7, 10, 20, 8, 1, 2, 3, 1, 2, 200]);
            ds.update([4, 4, 4]);
            chai_3.assert.deepEqual(ads.toArray(), [9, 7, 4, 4, 4, 8, 1, 2, 3, 1, 2, 200]);
            ds2.push(5);
            chai_3.assert.deepEqual(ads.toArray(), [9, 7, 4, 4, 4, 8, 5, 1, 2, 3, 1, 2, 200]);
            ds.update(undefined);
            chai_3.assert.deepEqual(ads.toArray(), [9, 7, 8, 5, 1, 2, 3, 1, 2, 200]);
        });
        it('dynamic to non dynamic 1', () => {
            const dyn = new aurumjs_4.ArrayDataSource([new aurumjs_4.DataSource(1), new aurumjs_4.DataSource(2), new aurumjs_4.DataSource(3)]);
            const nonDyn = aurumjs_4.ArrayDataSource.DynamicArrayDataSourceToArrayDataSource(dyn, new aurumjs_4.CancellationToken());
            chai_3.assert.deepEqual(nonDyn.toArray(), [1, 2, 3]);
            dyn.push(new aurumjs_4.DataSource(4));
            chai_3.assert.deepEqual(nonDyn.toArray(), [1, 2, 3, 4]);
            dyn.get(2).update(5);
            chai_3.assert.deepEqual(nonDyn.toArray(), [1, 2, 5, 4]);
            dyn.removeAt(1);
            chai_3.assert.deepEqual(nonDyn.toArray(), [1, 5, 4]);
        });
        it('dynamic to non dynamic 2', () => {
            const options = ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta'];
            const allOptions = new aurumjs_4.SetDataSource(options);
            const usedOptions = new aurumjs_4.ArrayDataSource();
            usedOptions.push(new aurumjs_4.DataSource('alpha'));
            usedOptions.push(new aurumjs_4.DataSource('beta'));
            const unusedOptions = allOptions.difference(aurumjs_4.ArrayDataSource.DynamicArrayDataSourceToArrayDataSource(usedOptions, new aurumjs_4.CancellationToken()).toSetDataSource(new aurumjs_4.CancellationToken()), new aurumjs_4.CancellationToken());
            const result = unusedOptions.toArrayDataSource().sort();
            chai_3.assert.deepEqual(result.toArray(), ['delta', 'epsilon', 'gamma', 'zeta']);
            usedOptions.push(new aurumjs_4.DataSource('gamma'));
            chai_3.assert.deepEqual(result.toArray(), ['delta', 'epsilon', 'zeta']);
            usedOptions.get(1).update('delta');
            chai_3.assert.deepEqual(result.toArray(), ['beta', 'epsilon', 'zeta']);
        });
        it('from multiple 3', () => {
            const ads1 = new aurumjs_4.ArrayDataSource([1, 2]);
            const ds = new aurumjs_4.DataSource(3);
            let ads = aurumjs_4.ArrayDataSource.fromMultipleSources([ads1, ds]);
            chai_3.assert.deepEqual(ads.toArray(), [1, 2, 3]);
            ads1.push(4);
            chai_3.assert.deepEqual(ads.toArray(), [1, 2, 4, 3]);
            ds.update(10);
            chai_3.assert.deepEqual(ads.toArray(), [1, 2, 4, 10]);
        });
        it('flat', () => {
            const ds = new aurumjs_4.ArrayDataSource([[11, [12], 13], [21, 22, 23, 24], [31], [41, 42], [51, 52, 53, 54, 55], [61]]);
            const flat = ds.flat();
            const flat2 = ds.flat().flat();
            chai_3.assert.deepEqual(flat.toArray(), [11, [12], 13, 21, 22, 23, 24, 31, 41, 42, 51, 52, 53, 54, 55, 61]);
            chai_3.assert.deepEqual(flat2.toArray(), [11, 12, 13, 21, 22, 23, 24, 31, 41, 42, 51, 52, 53, 54, 55, 61]);
            ds.push([7]);
            chai_3.assert.deepEqual(flat.toArray(), [11, [12], 13, 21, 22, 23, 24, 31, 41, 42, 51, 52, 53, 54, 55, 61, 7]);
            chai_3.assert.deepEqual(flat2.toArray(), [11, 12, 13, 21, 22, 23, 24, 31, 41, 42, 51, 52, 53, 54, 55, 61, 7]);
            ds.push([81, 82], [91, 92, [93]]);
            chai_3.assert.deepEqual(flat.toArray(), [11, [12], 13, 21, 22, 23, 24, 31, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, [93]]);
            chai_3.assert.deepEqual(flat2.toArray(), [11, 12, 13, 21, 22, 23, 24, 31, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, 93]);
            ds.insertAt(3, [0]);
            chai_3.assert.deepEqual(flat.toArray(), [11, [12], 13, 21, 22, 23, 24, 31, 0, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, [93]]);
            chai_3.assert.deepEqual(flat2.toArray(), [11, 12, 13, 21, 22, 23, 24, 31, 0, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, 93]);
            ds.removeAt(2);
            chai_3.assert.deepEqual(flat.toArray(), [11, [12], 13, 21, 22, 23, 24, 0, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, [93]]);
            chai_3.assert.deepEqual(flat2.toArray(), [11, 12, 13, 21, 22, 23, 24, 0, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, 93]);
            ds.removeLeft(2);
            chai_3.assert.deepEqual(flat.toArray(), [0, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, [93]]);
            chai_3.assert.deepEqual(flat2.toArray(), [0, 41, 42, 51, 52, 53, 54, 55, 61, 7, 81, 82, 91, 92, 93]);
            ds.removeRight(2);
            chai_3.assert.deepEqual(flat.toArray(), [0, 41, 42, 51, 52, 53, 54, 55, 61, 7]);
            chai_3.assert.deepEqual(flat2.toArray(), [0, 41, 42, 51, 52, 53, 54, 55, 61, 7]);
        });
        it('flat ds', () => {
            const ds = new aurumjs_4.ArrayDataSource([new aurumjs_4.ArrayDataSource([1, 2]), new aurumjs_4.ArrayDataSource([3, 4]), new aurumjs_4.ArrayDataSource([5])]);
            const flat = ds.flat();
            chai_3.assert.deepEqual(flat.toArray(), [1, 2, 3, 4, 5]);
            ds.push(new aurumjs_4.ArrayDataSource([7]));
            chai_3.assert.deepEqual(flat.toArray(), [1, 2, 3, 4, 5, 7]);
            ds.get(0).push(8);
            chai_3.assert.deepEqual(flat.toArray(), [1, 2, 8, 3, 4, 5, 7]);
        });
        it('reverse', () => {
            const ds = new aurumjs_4.ArrayDataSource([1, 2, 3, 4, 5, 6]);
            const reverse = ds.reverse();
            chai_3.assert.deepEqual(reverse.toArray(), [6, 5, 4, 3, 2, 1]);
            ds.push(7);
            chai_3.assert.deepEqual(reverse.toArray(), [7, 6, 5, 4, 3, 2, 1]);
            ds.push(8, 9);
            chai_3.assert.deepEqual(reverse.toArray(), [9, 8, 7, 6, 5, 4, 3, 2, 1]);
            ds.insertAt(3, 0);
            chai_3.assert.deepEqual(reverse.toArray(), [9, 8, 7, 6, 5, 4, 0, 3, 2, 1]);
            ds.removeAt(2);
            chai_3.assert.deepEqual(reverse.toArray(), [9, 8, 7, 6, 5, 4, 0, 2, 1]);
            ds.removeLeft(2);
            chai_3.assert.deepEqual(reverse.toArray(), [9, 8, 7, 6, 5, 4, 0]);
            ds.removeRight(2);
            chai_3.assert.deepEqual(reverse.toArray(), [7, 6, 5, 4, 0]);
        });
        it('unique', () => {
            const ds = new aurumjs_4.ArrayDataSource([1, 2, 3, 4, 5, 6]);
            const unique = ds.unique();
            chai_3.assert.deepEqual(unique.toArray(), [1, 2, 3, 4, 5, 6]);
            ds.push(6);
            chai_3.assert.deepEqual(unique.toArray(), [1, 2, 3, 4, 5, 6]);
            ds.insertAt(2, 1);
            chai_3.assert.deepEqual(unique.toArray(), [1, 2, 3, 4, 5, 6]);
            ds.removeAt(0);
            chai_3.assert.deepEqual(unique.toArray(), [1, 2, 3, 4, 5, 6]);
        });
        it('slice', () => {
            const ds = new aurumjs_4.ArrayDataSource([1, 2, 3, 4, 5, 6]);
            const dsE = new aurumjs_4.DataSource(3);
            const sliced = ds.slice(1, dsE);
            chai_3.assert.deepEqual(sliced.toArray(), [2, 3]);
            ds.push(6);
            chai_3.assert.deepEqual(sliced.toArray(), [2, 3]);
            ds.insertAt(2, 1);
            chai_3.assert.deepEqual(sliced.toArray(), [2, 1]);
            ds.removeAt(0);
            chai_3.assert.deepEqual(sliced.toArray(), [1, 3]);
            dsE.update(4);
            chai_3.assert.deepEqual(sliced.toArray(), [1, 3, 4]);
        });
        it('merge', () => {
            let ds = new aurumjs_4.ArrayDataSource([1, 2, 3]);
            ds.merge([6, 7]);
            chai_3.assert.deepEqual(ds.toArray(), [6, 7]);
            ds.merge([6, 7, 8]);
            chai_3.assert.deepEqual(ds.toArray(), [6, 7, 8]);
            ds.merge([6, 8, 7]);
            chai_3.assert.deepEqual(ds.toArray(), [6, 8, 7]);
            ds.merge([5, 6, 8, 7]);
            chai_3.assert.deepEqual(ds.toArray(), [5, 6, 8, 7]);
            ds.merge([4, 5, 8, 7, 6]);
            chai_3.assert.deepEqual(ds.toArray(), [4, 5, 8, 7, 6]);
            ds.merge([5, 8, 7, 6, 1]);
            chai_3.assert.deepEqual(ds.toArray(), [5, 8, 7, 6, 1]);
            ds.merge([2, 4, 6, 8]);
            chai_3.assert.deepEqual(ds.toArray(), [2, 4, 6, 8]);
            ds.merge([3, 6, 9]);
            chai_3.assert.deepEqual(ds.toArray(), [3, 6, 9]);
        });
        it('filter + sort', () => {
            const ds = new aurumjs_4.ArrayDataSource([4, 5, 7, 3, 8, 6, 9, 1, 2]);
            const key = new aurumjs_4.DataSource(2);
            const reverse = new aurumjs_4.DataSource(false);
            const sorted = ds.filter((v) => v % key.value === 0, [key]).sort((a, b) => (reverse.value ? b - a : a - b), [reverse]);
            chai_3.assert.deepEqual(sorted.toArray(), [2, 4, 6, 8]);
            key.update(3);
            chai_3.assert.deepEqual(sorted.toArray(), [3, 6, 9]);
            reverse.update(true);
            chai_3.assert.deepEqual(sorted.toArray(), [9, 6, 3]);
            key.update(2);
            chai_3.assert.deepEqual(sorted.toArray(), [8, 6, 4, 2]);
        });
        it('filter + sort + map', () => {
            const ds = new aurumjs_4.ArrayDataSource([4, 5, 7, 3, 8, 6, 9, 1, 2]);
            const key = new aurumjs_4.DataSource(2);
            const reverse = new aurumjs_4.DataSource(false);
            const mapped = ds
                .filter((v) => v % key.value === 0, [key])
                .sort((a, b) => (reverse.value ? b - a : a - b), [reverse])
                .map((v) => 'val:' + v);
            chai_3.assert.deepEqual(mapped.toArray(), ['val:2', 'val:4', 'val:6', 'val:8']);
            key.update(3);
            chai_3.assert.deepEqual(mapped.toArray(), ['val:3', 'val:6', 'val:9']);
            reverse.update(true);
            chai_3.assert.deepEqual(mapped.toArray(), ['val:9', 'val:6', 'val:3']);
            key.update(2);
            chai_3.assert.deepEqual(mapped.toArray(), ['val:8', 'val:6', 'val:4', 'val:2']);
        });
        it('filter + map length', () => {
            const ds = new aurumjs_4.ArrayDataSource([4, 5, 7, 3, 8, 6, 9, 1, 2]);
            const key = new aurumjs_4.DataSource(2);
            const mapped = ds.filter((v) => v % key.value === 0, [key]).map((v) => 'val:' + v);
            chai_3.assert.deepEqual(mapped.length.value, mapped.getData().length);
            key.update(3);
            chai_3.assert.deepEqual(mapped.length.value, mapped.getData().length);
            key.update(2);
            chai_3.assert.deepEqual(mapped.length.value, mapped.getData().length);
            key.update(1);
            chai_3.assert.deepEqual(mapped.length.value, mapped.getData().length);
        });
        it('filter + sort + map + render', () => {
            const ds = new aurumjs_4.ArrayDataSource([4, 5, 7, 3, 8, 6, 9, 1, 2]);
            const key = new aurumjs_4.DataSource(2);
            const reverse = new aurumjs_4.DataSource(false);
            const mapped = ds
                .filter((v) => v % key.value === 0, [key])
                .sort((a, b) => (reverse.value ? b - a : a - b), [reverse])
                .map((v) => aurumjs_4.Aurum.factory("div", null, v));
            const token = aurumjs_4.Aurum.attach(aurumjs_4.Aurum.factory("div", null, mapped), document.getElementById('target'));
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '2468');
            key.update(3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '369');
            reverse.update(true);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '963');
            key.update(2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '8642');
            token.cancel();
        });
        it('filter + sort + map + datasource', () => {
            const ds = new aurumjs_4.ArrayDataSource([4, 5, 7, 3, 8, 6, 9, 1, 2]);
            const key = new aurumjs_4.DataSource(2);
            const reverse = new aurumjs_4.DataSource(false);
            const mapped = ds
                .filter((v) => v % key.value === 0, [key])
                .sort((a, b) => (reverse.value ? b - a : a - b), [reverse])
                .map((v) => new aurumjs_4.DataSource(v));
            const token = aurumjs_4.Aurum.attach(aurumjs_4.Aurum.factory("div", null, mapped), document.getElementById('target'));
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '2468');
            key.update(3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '369');
            reverse.update(true);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '963');
            key.update(2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '8642');
            token.cancel();
        });
        it('render all types', () => {
            const ads = new aurumjs_4.ArrayDataSource([4, 5, 7]);
            const ds = new aurumjs_4.DataSource(2);
            const ads2 = new aurumjs_4.ArrayDataSource([1, 2, 3]);
            const token = aurumjs_4.Aurum.attach(aurumjs_4.Aurum.factory("div", null, ads), document.getElementById('target'));
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '457');
            ads.merge([1, 2, 3]);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '123');
            ads.merge(['0', '0']);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '00');
            ads.merge([1, '0', 2, 3, '0']);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '10230');
            ads.merge(['0', '0']);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '00');
            ads.clear();
            ads.push('0', '0');
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '00');
            ads.push(undefined);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '00');
            ads.push(3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '003');
            ads.push(null);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '003');
            ads.push(4);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '0034');
            ads.set(2, 'test');
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '00test34');
            ads.clear();
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ads.push(ds);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '2');
            ds.update(3);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '3');
            ads.push(ads2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '3123');
            ads2.push(4);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '31234');
            ds.update(1);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '11234');
            ads2.removeLeft(2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '134');
            ads.remove(ds);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '34');
            ads.remove(ads2);
            chai_3.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            token.cancel();
        });
    });
});
define("test/data_sources/datasource.test", ["require", "exports", "chai", "src/aurumjs", "src/stream/duplex_data_source", "src/stream/duplex_data_source_operators"], function (require, exports, chai_4, aurumjs_5, duplex_data_source_1, duplex_data_source_operators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Datasource', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('should render the data source value', () => {
            const ds = new aurumjs_5.DataSource(12);
            const ds2 = new aurumjs_5.DataSource();
            const ds3 = new aurumjs_5.ArrayDataSource([]);
            attachToken = aurumjs_5.Aurum.attach(aurumjs_5.Aurum.factory("div", null,
                aurumjs_5.Aurum.factory("div", null, ds)), document.getElementById('target'));
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '12');
            ds.update(99);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '99');
            ds.update([]);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ds.update('test');
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, 'test');
            ds.update([1, 2, 3]);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '123');
            ds.update([1, 'test', '8']);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '1test8');
            ds.update([1, [2, [3, [4], 5]], 6]);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '123456');
            ds.update(undefined);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ds.update(1);
            ds.update(null);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ds2.update(5);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '');
            ds.update(ds2);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '5');
            ds.update(ds3);
            ds3.push('2', 3, 4);
            chai_4.assert.deepEqual(document.getElementById('target').firstChild.textContent, '234');
        });
        it('should allow omitting initial value', () => {
            let ds = new aurumjs_5.DataSource();
            (0, chai_4.assert)(ds.value === undefined);
        });
        it('should take initial value', () => {
            let ds = new aurumjs_5.DataSource(123);
            (0, chai_4.assert)(ds.value === 123);
        });
        it('should update value', () => {
            let ds = new aurumjs_5.DataSource(123);
            chai_4.assert.equal(ds.value, 123);
            ds.update(321);
            chai_4.assert.equal(ds.value, 321);
        });
        it('should fire events', () => {
            return new Promise((resolve) => {
                let ds = new aurumjs_5.DataSource(123);
                (0, chai_4.assert)(ds.value === 123);
                ds.listen((value) => {
                    (0, chai_4.assert)(value === 321);
                    resolve();
                });
                ds.update(321);
                chai_4.assert.equal(ds.value, 321);
            });
        });
        it('should cancel events', () => {
            let ds = new aurumjs_5.DataSource(123);
            (0, chai_4.assert)(ds.value === 123);
            ds.listen((value) => {
                throw new Error('should have been canceled');
            });
            ds.cancelAll();
            ds.update(321);
        });
        it('should filter updates', () => {
            let ds = new aurumjs_5.DataSource(123);
            let filtered = ds.transform((0, aurumjs_5.dsFilter)((v) => v > 200));
            (0, chai_4.assert)(filtered.value === undefined);
            ds.update(100);
            (0, chai_4.assert)(filtered.value === undefined);
            ds.update(200);
            (0, chai_4.assert)(filtered.value === undefined);
            ds.update(300);
            (0, chai_4.assert)(filtered.value === 300);
        });
        it('should pipe updates', () => {
            let ds = new aurumjs_5.DataSource(123);
            let ds2 = new aurumjs_5.DataSource(10);
            ds.pipe(ds2);
            chai_4.assert.equal(ds2.value, 10);
            ds.update(100);
            chai_4.assert.equal(ds2.value, 100);
            ds.update(200);
            chai_4.assert.equal(ds2.value, 200);
            ds.update(300);
            chai_4.assert.equal(ds2.value, 300);
        });
        it('should map updates', () => {
            let ds = new aurumjs_5.DataSource(123);
            let mapped = ds.transform((0, aurumjs_5.dsMap)((v) => v + 10));
            chai_4.assert.equal(mapped.value, 133);
            ds.update(100);
            chai_4.assert.equal(mapped.value, 110);
            ds.update(200);
            chai_4.assert.equal(mapped.value, 210);
            ds.update(300);
            chai_4.assert.equal(mapped.value, 310);
        });
        it('should reduce updates', () => {
            let ds = new aurumjs_5.DataSource();
            let reduced = ds.transform((0, aurumjs_5.dsReduce)((p, c) => p + c, 0));
            ds.update(123);
            chai_4.assert.equal(reduced.value, 123);
            ds.update(100);
            chai_4.assert.equal(reduced.value, 223);
            ds.update(200);
            chai_4.assert.equal(reduced.value, 423);
            ds.update(300);
            chai_4.assert.equal(reduced.value, 723);
        });
        it('should aggregate updates', () => {
            let ds = new aurumjs_5.DataSource(1);
            let ds2 = new aurumjs_5.DataSource(1);
            let aggregated = ds.aggregate([ds2], (valueA, valueB) => valueA + valueB);
            chai_4.assert.equal(aggregated.value, 2);
            ds.update(100);
            chai_4.assert.equal(aggregated.value, 101);
            ds2.update(200);
            chai_4.assert.equal(aggregated.value, 300);
            ds.update(5);
            chai_4.assert.equal(aggregated.value, 205);
        });
        it('should aggregate many sources', () => {
            let ds = new aurumjs_5.DataSource(1);
            let ds2 = new aurumjs_5.DataSource(1);
            let ds3 = new aurumjs_5.DataSource(1);
            let ds4 = new aurumjs_5.DataSource(1);
            let ds5 = new aurumjs_5.DataSource(1);
            let ds6 = new aurumjs_5.DataSource(1);
            let aggregated = ds.aggregate([ds2, ds3, ds4, ds5, ds6], (valueA, valueB, valueC, valueD, valueE, valueF) => valueA + valueB + valueC + valueD + valueE + valueF);
            chai_4.assert.equal(aggregated.value, 6);
            ds.update(100);
            chai_4.assert.equal(aggregated.value, 105);
            ds2.update(200);
            chai_4.assert.equal(aggregated.value, 304);
            ds3.update(5);
            chai_4.assert.equal(aggregated.value, 308);
            ds6.update(-7);
            chai_4.assert.equal(aggregated.value, 300);
        });
        it('should combine updates', () => {
            let ds = new aurumjs_5.DataSource(1);
            let ds2 = new aurumjs_5.DataSource(1);
            let combined = ds.combine([ds2]);
            chai_4.assert.equal(combined.value, 1);
            ds.update(100);
            chai_4.assert.equal(combined.value, 100);
            ds2.update(200);
            chai_4.assert.equal(combined.value, 200);
            ds.update(5);
            chai_4.assert.equal(combined.value, 5);
        });
        it('should pick keys from object updates', () => {
            let ds = new aurumjs_5.DataSource({ someKey: 123 });
            let pick = ds.transform((0, aurumjs_5.dsPick)('someKey'));
            chai_4.assert.equal(pick.value, 123);
            ds.update({ someKey: 100 });
            chai_4.assert.equal(pick.value, 100);
            ds.update({ someKey: undefined });
            (0, chai_4.assert)(pick.value === undefined);
            ds.update(null);
            (0, chai_4.assert)(pick.value === null);
            ds = new aurumjs_5.DataSource();
            pick = ds.transform((0, aurumjs_5.dsPick)('someKey'));
            (0, chai_4.assert)(pick.value === undefined);
        });
        it('should fire unique events', () => {
            return new Promise((resolve) => {
                let i = 0;
                let asserts = [4, 0, 100, 200];
                let ds = new aurumjs_5.DataSource(0);
                ds.transform((0, aurumjs_5.dsUnique)()).listen((value) => {
                    (0, chai_4.assert)(value === asserts[i++]);
                    if (i === asserts.length) {
                        resolve();
                    }
                });
                ds.update(0);
                ds.update(4);
                ds.update(4);
                ds.update(0);
                ds.update(0);
                ds.update(100);
                ds.update(100);
                ds.update(200);
            });
        });
        it('should fire unique events both ways', () => {
            return new Promise((resolve) => {
                let i = 0;
                let asserts = [200, 4, 0, 100, 200];
                let ds = new duplex_data_source_1.DuplexDataSource(0);
                let validated = true;
                const ud = ds.transformDuplex((0, duplex_data_source_operators_1.ddsUnique)());
                const token = new aurumjs_5.CancellationToken();
                ud.listen((value) => {
                    (0, chai_4.assert)(value === asserts[i++]);
                    if (i === asserts.length) {
                        validated = true;
                    }
                }, token);
                token.cancel();
                ds.updateDownstream(0);
                ds.updateDownstream(4);
                ds.updateDownstream(0);
                ds.updateDownstream(100);
                ds.updateDownstream(200);
                (0, chai_4.assert)(validated);
                i = 0;
                ds.listen((value) => {
                    (0, chai_4.assert)(value === asserts[i++]);
                    if (i === asserts.length) {
                        resolve();
                    }
                });
                ud.updateUpstream(200);
                ud.updateUpstream(4);
                ud.updateUpstream(4);
                ud.updateUpstream(0);
                ud.updateUpstream(0);
                ud.updateUpstream(100);
                ud.updateUpstream(100);
                ud.updateUpstream(200);
            });
        });
        it('should map updates both ways', () => {
            let ds = new duplex_data_source_1.DuplexDataSource(123);
            let mapped = ds.transformDuplex((0, duplex_data_source_operators_1.ddsMap)((v) => v + 10, (v) => v - 10));
            (0, chai_4.assert)(mapped.value === 133);
            ds.updateDownstream(100);
            chai_4.assert.equal(mapped.value, 110);
            ds.updateDownstream(200);
            chai_4.assert.equal(mapped.value, 210);
            ds.updateDownstream(300);
            chai_4.assert.equal(mapped.value, 310);
            mapped.updateUpstream(100);
            (0, chai_4.assert)(ds.value === 90);
            mapped.updateUpstream(200);
            chai_4.assert.equal(ds.value, 190);
            mapped.updateUpstream(300);
            chai_4.assert.equal(ds.value, 290);
        });
        it('should filter updates both ways', () => {
            let ds = new duplex_data_source_1.DuplexDataSource(123);
            let filtered = ds.transformDuplex((0, duplex_data_source_operators_1.ddsFilter)((v) => v > 200, (v) => v > 200));
            (0, chai_4.assert)(filtered.value === undefined);
            ds.updateDownstream(100);
            (0, chai_4.assert)(filtered.value === undefined);
            ds.updateDownstream(200);
            (0, chai_4.assert)(filtered.value === undefined);
            ds.updateDownstream(300);
            (0, chai_4.assert)(filtered.value === 300);
            filtered.updateUpstream(100);
            (0, chai_4.assert)(ds.value === 300);
            filtered.updateUpstream(200);
            (0, chai_4.assert)(ds.value === 300);
            filtered.updateUpstream(350);
            chai_4.assert.equal(ds.value, 350);
        });
    });
});
define("test/data_sources/object_data_source.test", ["require", "exports", "chai", "src/stream/object_data_source"], function (require, exports, chai_5, object_data_source_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('object data source', () => {
        let testObject;
        beforeEach(() => {
            testObject = {
                a: 1,
                b: '2',
                c: true,
                d: null,
                e: undefined,
                f: [1, 2, 3],
                g: {
                    a: 1,
                    b: '2',
                    c: true,
                    d: null,
                    e: undefined,
                    f: [1, 2, 3],
                    g: {
                        a: 1,
                        b: '2'
                    }
                }
            };
        });
        it('wrap', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            chai_5.assert.equal(wrapper.get('a'), 1);
            chai_5.assert.equal(wrapper.get('b'), '2');
            wrapper.set('a', 2);
            chai_5.assert.equal(wrapper.get('a'), 2);
        });
        it('create synchronized datasource from property', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            const datasource = wrapper.pick('a');
            chai_5.assert.equal(datasource.value, 1);
            wrapper.set('a', 2);
            chai_5.assert.equal(datasource.value, 2);
            datasource.update(3);
            chai_5.assert.equal(wrapper.get('a'), 3);
        });
        it('create synchronized duplex datasource from property', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            const datasource = wrapper.pickDuplex('a');
            chai_5.assert.equal(datasource.value, 1);
            wrapper.set('a', 2);
            chai_5.assert.equal(datasource.value, 2);
            datasource.updateDownstream(3);
            chai_5.assert.equal(wrapper.get('a'), 2);
            datasource.updateUpstream(3);
            chai_5.assert.equal(wrapper.get('a'), 3);
        });
        it('toDataSource', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            const datasource = wrapper.toDataSource();
            let i = 0;
            datasource.listenAndRepeat((c) => {
                switch (i++) {
                    case 0:
                    case 1:
                        chai_5.assert.equal(c, testObject);
                        break;
                    default:
                        throw new Error('unexpected');
                }
            });
            chai_5.assert.equal(datasource.value, testObject);
            wrapper.set('a', 2);
            chai_5.assert.equal(datasource.value, testObject);
        });
        it('create synchronized arraydatasource from property', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            const datasource = wrapper.pickArray('f');
            chai_5.assert.deepEqual(datasource.getData(), [1, 2, 3]);
            wrapper.set('f', [4, 5, 6]);
            chai_5.assert.deepEqual(datasource.getData(), [4, 5, 6]);
            datasource.push(7);
            chai_5.assert.deepEqual(wrapper.get('f'), [4, 5, 6, 7]);
        });
        it('create synchronized objectdatasource from property', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            const datasource = wrapper.pickObject('g');
            chai_5.assert.deepEqual(datasource.getData(), {
                a: 1,
                b: '2',
                c: true,
                d: null,
                e: undefined,
                f: [1, 2, 3],
                g: {
                    a: 1,
                    b: '2'
                }
            });
            wrapper.set('g', {
                a: 4,
                b: '5',
                c: false,
                d: null,
                e: undefined,
                f: [4, 5, 6]
            });
            chai_5.assert.deepEqual(datasource.getData(), {
                a: 4,
                b: '5',
                c: false,
                d: null,
                e: undefined,
                f: [4, 5, 6]
            });
            datasource.set('a', 7);
            chai_5.assert.deepEqual(wrapper.get('g'), {
                a: 7,
                b: '5',
                c: false,
                d: null,
                e: undefined,
                f: [4, 5, 6]
            });
        });
        it('create nested datasource', () => {
            const wrapper = new object_data_source_1.ObjectDataSource(testObject);
            const wrapper2 = wrapper.pickObject('g');
            const datasource = wrapper2.pick('a');
            chai_5.assert.equal(datasource.value, 1);
            wrapper2.set('a', 2);
            chai_5.assert.equal(datasource.value, 2);
        });
    });
});
define("test/data_sources/tree_data_source.test", ["require", "exports", "chai", "src/aurumjs"], function (require, exports, chai_6, aurumjs_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('TreeDatasource', () => {
        let attachToken;
        const dynamicNode = new aurumjs_6.ArrayDataSource([
            {
                id: '4',
                children: []
            }
        ]);
        const tree = [
            {
                id: '1',
                children: [
                    {
                        id: '1.1',
                        children: [
                            {
                                id: '3',
                                children: [
                                    {
                                        id: '5',
                                        children: []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: '2',
                        children: dynamicNode
                    }
                ]
            }
        ];
        beforeEach(() => {
            attachToken = new aurumjs_6.CancellationToken();
        });
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('should list all nodes', () => {
            const a = new aurumjs_6.TreeDataSource('children', tree);
            chai_6.assert.deepEqual(a
                .createArrayDataSourceOfNodes(attachToken)
                .toArray()
                .map((e) => e.id), ['1', '1.1', '3', '5', '2', '4']);
        });
        it('iterate nodes', () => {
            const a = new aurumjs_6.TreeDataSource('children', tree);
            chai_6.assert.deepEqual(Array.from(a).map((e) => e.id), ['1', '1.1', '3', '5', '2', '4']);
        });
        it('map nodes', () => {
            const a = new aurumjs_6.TreeDataSource('children', tree);
            const mapped = a.map((i) => ({ n: i.id, children: i.children }));
            chai_6.assert.deepEqual(Array.from(mapped).map((e) => e.n), ['1', '1.1', '3', '5', '2', '4']);
            dynamicNode.push({
                id: '6',
                children: []
            });
            chai_6.assert.deepEqual(Array.from(mapped).map((e) => e.n), ['1', '1.1', '3', '5', '2', '4', '6']);
        });
        it('should allow listening to changes', () => {
            const a = new aurumjs_6.TreeDataSource('children', tree);
            const changes = [];
            a.listen((e) => changes.push({
                operation: e.operation,
                id: e.changedNode.id
            }), attachToken);
            const dynamicNode2 = new aurumjs_6.ArrayDataSource([]);
            const dynamicNode3 = new aurumjs_6.ArrayDataSource([]);
            dynamicNode.push({
                id: '7',
                children: []
            });
            dynamicNode.push({
                id: '8',
                children: dynamicNode2
            });
            dynamicNode.removeAt(1);
            dynamicNode2.push({
                id: '9',
                children: dynamicNode3
            });
            dynamicNode3.push({
                id: '10',
                children: []
            });
            dynamicNode2.clear();
            dynamicNode3.push({
                id: '11',
                children: []
            });
            chai_6.assert.deepEqual(changes, [
                { operation: 'added', id: '7' },
                { operation: 'added', id: '8' },
                { operation: 'deleted', id: '6' },
                { operation: 'added', id: '9' },
                { operation: 'added', id: '10' },
                { operation: 'deleted', id: '9' }
            ]);
        });
    });
});
define("test/internal_components/suspense.test", ["require", "exports", "chai", "sinon", "src/builtin_components/suspense", "test/test_utils", "src/utilities/aurum"], function (require, exports, chai_7, sinon, suspense_1, test_utils_1, aurum_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateSuspenseTests = void 0;
    function generateSuspenseTests(renderSuspense) {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('Should not add anything to the DOM', () => {
            attachToken = (0, test_utils_1.attachToTestRoot)(renderSuspense());
            (0, chai_7.assert)(Array.from((0, test_utils_1.getTestRoot)().firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
        it('Should not suspend if content is not a promise', () => {
            attachToken = (0, test_utils_1.attachToTestRoot)(renderSuspense('1', '2'));
            (0, chai_7.assert)((0, test_utils_1.getTestRoot)().firstChild.textContent === '2');
        });
        it('Should suspend if content is a promise', () => {
            attachToken = (0, test_utils_1.attachToTestRoot)(renderSuspense('1', new Promise(() => void 0)));
            (0, chai_7.assert)((0, test_utils_1.getTestRoot)().firstChild.textContent === '1');
        });
        it('Should remove suspense after promise resolves', async () => {
            attachToken = (0, test_utils_1.attachToTestRoot)(renderSuspense('1', new Promise((r) => r('2'))));
            (0, chai_7.assert)((0, test_utils_1.getTestRoot)().firstChild.textContent === '1');
            await (0, test_utils_1.sleep)(0);
            (0, chai_7.assert)((0, test_utils_1.getTestRoot)().firstChild.textContent === '2');
        });
        it('Should call onAttach and onDetach of child in correct order', async () => {
            const attachCallback = sinon.spy();
            const detachCallback = sinon.spy();
            attachToken = (0, test_utils_1.attachToTestRoot)(renderSuspense('1', new Promise((r) => r(aurum_1.Aurum.factory("div", { onAttach: () => attachCallback(), onDetach: () => detachCallback() })))));
            await (0, test_utils_1.sleep)(0);
            attachToken.cancel();
            (0, chai_7.assert)(attachCallback.calledOnce, 'onAttach should get called once');
            (0, chai_7.assert)(detachCallback.calledOnce, 'onDetach should get called once');
            (0, chai_7.assert)(attachCallback.calledBefore(detachCallback), 'onAttach should get called before onDetach');
        });
    }
    exports.generateSuspenseTests = generateSuspenseTests;
    describe('Suspense', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        generateSuspenseTests((fallback, children) => (aurum_1.Aurum.factory("div", null,
            aurum_1.Aurum.factory(suspense_1.Suspense, { fallback: fallback }, children))));
    });
});
define("test/internal_components/error_boundary.test", ["require", "exports", "chai", "src/aurumjs", "test/test_utils", "test/internal_components/suspense.test"], function (require, exports, chai_8, aurumjs_7, test_utils_2, suspense_test_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const errorMessage = "I'm an error";
    describe('ErrorBoundary', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        (0, suspense_test_1.generateSuspenseTests)((fallback, children) => (aurumjs_7.Aurum.factory("div", null,
            aurumjs_7.Aurum.factory(aurumjs_7.ErrorBoundary, { suspenseFallback: fallback }, children))));
        it('Should show error fallback when promise rejects', async () => {
            attachToken = (0, test_utils_2.attachToTestRoot)(aurumjs_7.Aurum.factory("div", null,
                aurumjs_7.Aurum.factory(aurumjs_7.ErrorBoundary, { errorFallback: "1" }, new Promise((resolve, reject) => {
                    reject('2');
                }))));
            await (0, test_utils_2.sleep)(0);
            (0, chai_8.assert)((0, test_utils_2.getTestRoot)().firstChild.textContent === '1');
        });
        it('Should show error fallback when a child throws', async () => {
            attachToken = (0, test_utils_2.attachToTestRoot)(aurumjs_7.Aurum.factory("div", null,
                aurumjs_7.Aurum.factory(aurumjs_7.ErrorBoundary, { errorFallback: (error) => error.message },
                    aurumjs_7.Aurum.factory(ThrowComponent, null))));
            (0, chai_8.assert)((0, test_utils_2.getTestRoot)().firstChild.textContent === errorMessage);
        });
        it('Should show error fallback when a nested component throws', async () => {
            attachToken = (0, test_utils_2.attachToTestRoot)(aurumjs_7.Aurum.factory("div", null,
                aurumjs_7.Aurum.factory(aurumjs_7.ErrorBoundary, { errorFallback: (error) => error.message },
                    aurumjs_7.Aurum.factory(WrappedThrowComponent, null))));
            (0, chai_8.assert)((0, test_utils_2.getTestRoot)().firstChild.textContent === errorMessage);
        });
    });
    function ThrowComponent() {
        throw new Error(errorMessage);
    }
    function WrappedThrowComponent() {
        return (aurumjs_7.Aurum.factory("div", null,
            aurumjs_7.Aurum.factory(ThrowComponent, null)));
    }
});
define("test/internal_components/node.test", ["require", "exports", "src/aurumjs", "chai"], function (require, exports, aurumjs_8, chai_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Nodes', () => {
        [
            'Address',
            'Kbd',
            'Samp',
            'Object',
            'OptGroup',
            'Picture',
            'Output',
            'Param',
            'Strong',
            'Track',
            'Var',
            'Wbr',
            'Button',
            'Code',
            'Hr',
            'Div',
            'Input',
            'Li',
            'Span',
            'Style',
            'Ul',
            'P',
            'Img',
            'Link',
            'Canvas',
            'A',
            'Article',
            'Br',
            'Form',
            'Label',
            'Ol',
            'Pre',
            'Progress',
            'Table',
            'Td',
            'Tr',
            'Th',
            'TextArea',
            'H1',
            'H2',
            'H3',
            'H4',
            'H5',
            'H6',
            'Html',
            'Head',
            'Header',
            'Footer',
            'Nav',
            'B',
            'I',
            'Script',
            'Abbr',
            'Area',
            'Aside',
            'Audio',
            'Em',
            'Heading',
            'IFrame',
            'NoScript',
            'Option',
            'Q',
            'Select',
            'Source',
            'Title',
            'Video',
            'TBody',
            'TFoot',
            'Meta',
            'Body',
            'THead',
            'Summary',
            'Details',
            'Sub',
            'Sup',
            'Svg',
            'Data',
            'Time',
            'Template',
            'Slot',
            'Col',
            'Colgroup',
            'Caption'
        ].forEach((n) => {
            it('should render node ' + n, () => {
                let attachToken = aurumjs_8.Aurum.attach(aurumjs_8.Aurum.factory(n.toLowerCase(), {}, null), document.getElementById('target'));
                try {
                    (0, chai_9.assert)(document.getElementById('target').firstChild.nodeName.toLowerCase() === n.toLowerCase());
                }
                finally {
                    attachToken.cancel();
                }
            });
        });
        it('should bind array data source ', () => {
            const repeatModel = new aurumjs_8.ArrayDataSource([1, 2, 3, 4]);
            let attachToken = aurumjs_8.Aurum.attach(aurumjs_8.Aurum.factory("div", null, repeatModel.map((i) => (aurumjs_8.Aurum.factory("div", null, i)))), document.getElementById('target'));
            try {
                (0, chai_9.assert)(document.getElementById('target').firstChild.childElementCount === repeatModel.length.value);
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '1234');
            }
            finally {
                attachToken.cancel();
            }
        });
        it('repeat should sync with changes ', () => {
            const repeatModel = new aurumjs_8.ArrayDataSource([1, 2, 3, 4]);
            let attachToken = aurumjs_8.Aurum.attach(aurumjs_8.Aurum.factory("div", null, repeatModel.map((i) => (aurumjs_8.Aurum.factory("div", null, i)))), document.getElementById('target'));
            try {
                (0, chai_9.assert)(document.getElementById('target').firstChild.childElementCount === repeatModel.length.value);
                repeatModel.push(5);
                (0, chai_9.assert)(document.getElementById('target').firstChild.childElementCount === repeatModel.length.value);
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '12345');
                repeatModel.swap(0, 2);
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '32145');
                repeatModel.unshift(7);
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '732145');
                repeatModel.removeRight(1);
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '73214');
                repeatModel.removeLeft(2);
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '214');
                repeatModel.clear();
                (0, chai_9.assert)(document.getElementById('target').firstChild.textContent === '');
            }
            finally {
                attachToken.cancel();
            }
        });
    });
});
define("test/internal_components/router.test", ["require", "exports", "chai", "src/aurumjs"], function (require, exports, chai_10, aurumjs_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Router', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('Should not break with undefined routes', () => {
            attachToken = aurumjs_9.Aurum.attach(aurumjs_9.Aurum.factory("div", null,
                aurumjs_9.Aurum.factory(aurumjs_9.AurumRouter, null,
                    aurumjs_9.Aurum.factory(aurumjs_9.Route, { href: '/' }),
                    undefined)), document.getElementById('target'));
            (0, chai_10.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
    });
});
define("test/internal_components/select.test", ["require", "exports", "chai", "sinon", "src/aurumjs"], function (require, exports, chai_11, sinon, aurumjs_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Select', () => {
        let attachToken;
        let clock;
        beforeEach(() => {
            clock = sinon.useFakeTimers();
        });
        afterEach(() => {
            clock.uninstall();
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('Should apply initial selection', () => {
            attachToken = aurumjs_10.Aurum.attach(aurumjs_10.Aurum.factory("select", { selectedIndex: 1 },
                aurumjs_10.Aurum.factory("option", null, "1"),
                aurumjs_10.Aurum.factory("option", null, "2")), document.getElementById('target'));
            (0, chai_11.assert)(document.getElementById('target').firstChild.selectedIndex === 1);
        });
        it('Should apply selection source', () => {
            const source = new aurumjs_10.DataSource(1);
            attachToken = aurumjs_10.Aurum.attach(aurumjs_10.Aurum.factory("select", { selectedIndex: source },
                aurumjs_10.Aurum.factory("option", null, "1"),
                aurumjs_10.Aurum.factory("option", null, "2"),
                aurumjs_10.Aurum.factory("option", null, "3")), document.getElementById('target'));
            (0, chai_11.assert)(document.getElementById('target').firstChild.selectedIndex === 1);
            source.update(2);
            clock.tick(100);
            (0, chai_11.assert)(document.getElementById('target').firstChild.selectedIndex === 2);
        });
    });
});
define("test/internal_components/switch.test", ["require", "exports", "chai", "src/aurumjs"], function (require, exports, chai_12, aurumjs_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Switch', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('Should not add anything to the DOM', () => {
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: new aurumjs_11.DataSource() })), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
        it('Should not add anything to the DOM with empty cases', () => {
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: new aurumjs_11.DataSource() },
                    aurumjs_11.Aurum.factory(aurumjs_11.DefaultSwitchCase, null))), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
        it('Should pick none if no match', () => {
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: new aurumjs_11.DataSource() },
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: 'whatever' },
                        aurumjs_11.Aurum.factory("div", null, "hello")))), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
        it('Should pick default', () => {
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: new aurumjs_11.DataSource() },
                    aurumjs_11.Aurum.factory(aurumjs_11.DefaultSwitchCase, null,
                        aurumjs_11.Aurum.factory("div", null, "hello")))), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.childNodes[1].textContent === 'hello');
        });
        it('Should pick correct', () => {
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: new aurumjs_11.DataSource('yes') },
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "no" },
                        aurumjs_11.Aurum.factory("div", null, "hello")),
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "yes" },
                        aurumjs_11.Aurum.factory("div", null, "world")))), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.childNodes[1].textContent === 'world');
        });
        it('Should update', () => {
            const data = new aurumjs_11.DataSource('one');
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: data },
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "one" },
                        aurumjs_11.Aurum.factory("div", null, "hello")),
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "two" },
                        aurumjs_11.Aurum.factory("div", null, "world")))), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.childNodes[1].textContent === 'hello');
            data.update('two');
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.childNodes[1].textContent === 'world');
            data.update('three');
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
        it('Nested switches should work', () => {
            const data = new aurumjs_11.DataSource('one');
            const data2 = new aurumjs_11.DataSource('one');
            attachToken = aurumjs_11.Aurum.attach(aurumjs_11.Aurum.factory("div", null,
                aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: data },
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "one" },
                        aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: data2 },
                            aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "one" },
                                aurumjs_11.Aurum.factory("div", null, "sub one")),
                            aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "two" },
                                aurumjs_11.Aurum.factory("div", null, "sub two")))),
                    aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "two" },
                        aurumjs_11.Aurum.factory(aurumjs_11.Switch, { state: data2 },
                            aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "one" },
                                aurumjs_11.Aurum.factory("div", null, "sub hello")),
                            aurumjs_11.Aurum.factory(aurumjs_11.SwitchCase, { when: "two" },
                                aurumjs_11.Aurum.factory("div", null, "sub world")))))), document.getElementById('target'));
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.textContent === 'sub one');
            data2.update('two');
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.textContent === 'sub two');
            data2.update('one');
            data.update('two');
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.textContent === 'sub hello');
            data2.update('two');
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 1);
            (0, chai_12.assert)(document.getElementById('target').firstChild.textContent === 'sub world');
            data.update('three');
            (0, chai_12.assert)(Array.from(document.getElementById('target').firstChild.childNodes).filter((e) => !(e instanceof Comment)).length === 0);
        });
    });
});
define("test/rendering/aurum.test", ["require", "exports", "chai", "sinon", "src/aurumjs"], function (require, exports, chai_13, sinon, aurumjs_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Aurum', () => {
        let clock;
        beforeEach(() => {
            clock = sinon.useFakeTimers();
        });
        let attachToken;
        afterEach(() => {
            clock.uninstall();
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('should attach dom node', () => {
            (0, chai_13.assert)(document.getElementById('target').firstChild === null);
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null), document.getElementById('target'));
            (0, chai_13.assert)(document.getElementById('target').firstChild !== null);
        });
        it('Should set inner text', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null, "Hello World"), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.textContent === 'Hello World');
        });
        it('Should fire onAttach when connected to dom', () => {
            return new Promise((resolve) => {
                attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", { onAttach: (ele) => {
                        (0, chai_13.assert)(ele.isConnected);
                        resolve();
                    } }, "Hello World"), document.getElementById('target'));
                clock.tick(100);
            });
        });
        it('Should fire onDetach when disconnected from dom', () => {
            return new Promise((resolve) => {
                attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", { onDetach: (ele) => {
                        (0, chai_13.assert)(!ele.isConnected);
                        resolve();
                    } }, "Hello World"), document.getElementById('target'));
                clock.tick(100);
                attachToken.cancel();
                attachToken = undefined;
            });
        });
        it('Should support fragments', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null, "Hello World")), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.childNodes.length === 1);
            (0, chai_13.assert)(document.getElementById('target').firstChild.innerHTML === 'Hello World');
        });
        it('Should support nested fragments', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                    aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null, "Hello World"))), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.childNodes.length === 1);
            (0, chai_13.assert)(document.getElementById('target').firstChild.innerHTML === 'Hello World');
        });
        it('Should support components in fragments', () => {
            function TestComponent() {
                return 'Hello World';
            }
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                    aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                        aurumjs_12.Aurum.factory(TestComponent, null)))), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.childNodes.length === 1);
            (0, chai_13.assert)(document.getElementById('target').firstChild.innerHTML === 'Hello World');
        });
        it('Should support fragments in transclusion', () => {
            function TestComponent(_, c) {
                return c;
            }
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                    aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                        aurumjs_12.Aurum.factory(TestComponent, null,
                            aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null, "Test1"),
                                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null, "Test2")))))), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.childNodes.length === 2);
            (0, chai_13.assert)(document.getElementById('target').firstChild.innerHTML === 'Test1Test2');
        });
        it('Should support datasources in fragments in transclusion', () => {
            const ds = new aurumjs_12.DataSource('State1');
            function TestComponent(_, c) {
                return c;
            }
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                    aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                        aurumjs_12.Aurum.factory(TestComponent, null,
                            aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null,
                                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null, ds),
                                aurumjs_12.Aurum.factory(aurumjs_12.Aurum.fragment, null, "Test2")))))), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.childNodes.length === 4);
            (0, chai_13.assert)(document.getElementById('target').firstChild.innerText === 'State1Test2');
            ds.update('State2');
            (0, chai_13.assert)(document.getElementById('target').firstChild.innerText === 'State2Test2');
        });
        it('Should set child node', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", null, "Hello World")), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild instanceof HTMLParagraphElement);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.textContent === 'Hello World');
        });
        it('should accept booleans for attributes 1', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", { id: false }, "Hello World")), document.getElementById('target'));
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild instanceof HTMLParagraphElement);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === false);
        });
        it('should accept booleans for attributes 2', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", { id: true }, "Hello World")), document.getElementById('target'));
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild instanceof HTMLParagraphElement);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === true);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.getAttribute('id') === '');
        });
        it('should accept booleans datasources for attributes', () => {
            const ds = new aurumjs_12.DataSource(false);
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", { id: ds }, "Hello World")), document.getElementById('target'));
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild instanceof HTMLParagraphElement);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === false);
            ds.update(true);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === true);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.getAttribute('id') === '');
            ds.update(false);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === false);
        });
        it('should accept text for attributes', () => {
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", { id: "test" }, "Hello World")), document.getElementById('target'));
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild instanceof HTMLParagraphElement);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === true);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.getAttribute('id') === 'test');
        });
        it('should accept string datasources for attributes', () => {
            const ds = new aurumjs_12.DataSource('');
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", { id: ds }, "Hello World")), document.getElementById('target'));
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild instanceof HTMLParagraphElement);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === true);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.getAttribute('id') === '');
            ds.update('test');
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.hasAttribute('id') === true);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.getAttribute('id') === 'test');
        });
        it('Should accept data sources', () => {
            const ds = new aurumjs_12.DataSource('123');
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory("div", null,
                aurumjs_12.Aurum.factory("p", null, ds)), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.firstChild.textContent === '123');
        });
        it('Should accept functional components', () => {
            const FuncComp = () => aurumjs_12.Aurum.factory("div", null, "Functional");
            attachToken = aurumjs_12.Aurum.attach(aurumjs_12.Aurum.factory(FuncComp, null), document.getElementById('target'));
            clock.tick(100);
            (0, chai_13.assert)(document.getElementById('target').firstChild.textContent === 'Functional');
        });
    });
});
define("test/rendering/aurum_element.test", ["require", "exports", "chai", "sinon", "src/stream/data_source", "src/utilities/aurum", "src/builtin_components/switch"], function (require, exports, chai_14, sinon, data_source_2, aurum_2, switch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Aurum Element', () => {
        let attachToken;
        let clock;
        beforeEach(() => {
            clock = sinon.useFakeTimers();
        });
        afterEach(() => {
            clock.uninstall();
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('Should be in DOM at onAttach', () => {
            return new Promise((resolve) => {
                attachToken = aurum_2.Aurum.attach(aurum_2.Aurum.factory("div", { onAttach: (div) => {
                        (0, chai_14.assert)(div.isConnected);
                        resolve();
                    } }), document.getElementById('target'));
            });
        });
        it('Should be in DOM at onAttach nested', () => {
            return new Promise((resolve) => {
                attachToken = aurum_2.Aurum.attach(aurum_2.Aurum.factory("div", null,
                    aurum_2.Aurum.factory("div", { onAttach: (div) => {
                            (0, chai_14.assert)(div.isConnected);
                            resolve();
                        } })), document.getElementById('target'));
            });
        });
        it('Should not be in DOM at onDetach', () => {
            return new Promise((resolve) => {
                attachToken = aurum_2.Aurum.attach(aurum_2.Aurum.factory("div", { onDetach: (div) => {
                        (0, chai_14.assert)(!div.isConnected);
                        resolve();
                    } }), document.getElementById('target'));
                attachToken.cancel();
                attachToken = undefined;
            });
        });
        it('Should detach on removal', () => {
            const ds = new data_source_2.DataSource(true);
            return new Promise((resolve) => {
                attachToken = aurum_2.Aurum.attach(aurum_2.Aurum.factory("div", null,
                    aurum_2.Aurum.factory(switch_1.Switch, { state: ds },
                        aurum_2.Aurum.factory(switch_1.SwitchCase, { when: true },
                            aurum_2.Aurum.factory("div", { onDetach: () => {
                                    resolve();
                                } })),
                        aurum_2.Aurum.factory(switch_1.SwitchCase, { when: false }))), document.getElementById('target'));
                ds.update(false);
            });
        });
    });
});
define("test/rendering/aurum_to_html.test", ["require", "exports", "chai", "src/aurumjs", "src/utilities/aurum"], function (require, exports, chai_15, aurumjs_13, aurum_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Aurum To HTML', () => {
        it('Should render HTML in place', () => {
            const { content } = (0, aurumjs_13.aurumToHTML)(aurum_3.Aurum.factory("a", { class: "abc", id: "bcd", href: "test" }));
            (0, chai_15.assert)(content.tagName === 'A');
            (0, chai_15.assert)(content.className === 'abc');
            (0, chai_15.assert)(content.id === 'bcd');
            (0, chai_15.assert)(content.getAttribute('href') === 'test');
        });
    });
});
define("test/rendering/components.test", ["require", "exports", "chai", "src/aurumjs", "src/utilities/aurum"], function (require, exports, chai_16, aurumjs_14, aurum_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function TestComponent(props, children, api) {
        return aurum_4.Aurum.factory("span", null, children);
    }
    describe('Components', () => {
        let attachToken;
        afterEach(() => {
            attachToken === null || attachToken === void 0 ? void 0 : attachToken.cancel();
            attachToken = undefined;
        });
        it('Should attach component', () => {
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null,
                aurum_4.Aurum.factory(TestComponent, null)), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML === '<div><span></span></div>');
        });
        it('Should attach component with primitive transclusion', () => {
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null,
                aurum_4.Aurum.factory(TestComponent, null, "1234")), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML === '<div><span>1234</span></div>');
        });
        it('Should attach component with dom node transclusion', () => {
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null,
                aurum_4.Aurum.factory(TestComponent, null,
                    aurum_4.Aurum.factory("li", null))), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML === '<div><span><li></li></span></div>');
        });
        it('Should attach component with component transclusion', () => {
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null,
                aurum_4.Aurum.factory(TestComponent, null,
                    aurum_4.Aurum.factory(TestComponent, null))), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML === '<div><span><span></span></span></div>');
        });
        it('Should attach component with nested component transclusion', () => {
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null,
                aurum_4.Aurum.factory(TestComponent, null,
                    aurum_4.Aurum.factory(TestComponent, null,
                        aurum_4.Aurum.factory(TestComponent, null,
                            aurum_4.Aurum.factory(TestComponent, null))))), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML === '<div><span><span><span><span></span></span></span></span></div>');
        });
        const htmlComments = /<!--(.*?)-->/gm;
        it('Dynamic attaching and detaching', () => {
            const ds = new aurumjs_14.DataSource();
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null, ds), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML.replace(htmlComments, '') === '<div></div>');
            ds.update(aurum_4.Aurum.factory(TestComponent, null));
            (0, chai_16.assert)(document.getElementById('target').innerHTML.replace(htmlComments, '') === '<div><span></span></div>');
            ds.update(undefined);
            (0, chai_16.assert)(document.getElementById('target').innerHTML.replace(htmlComments, '') === '<div></div>');
        });
        it('Dynamic nested attaching and detaching', () => {
            const ds = new aurumjs_14.DataSource();
            attachToken = aurum_4.Aurum.attach(aurum_4.Aurum.factory("div", null, ds.transform((0, aurumjs_14.dsMap)((v) => (v ? aurum_4.Aurum.factory("div", null, v) : undefined)))), document.getElementById('target'));
            (0, chai_16.assert)(document.getElementById('target').innerHTML.replace(htmlComments, '') === '<div></div>');
            ds.update(aurum_4.Aurum.factory(TestComponent, null));
            (0, chai_16.assert)(document.getElementById('target').innerHTML.replace(htmlComments, '') === '<div><div><span></span></div></div>');
            ds.update(undefined);
            (0, chai_16.assert)(document.getElementById('target').innerHTML.replace(htmlComments, '') === '<div></div>');
        });
    });
});
//# sourceMappingURL=aurumjs.js.map