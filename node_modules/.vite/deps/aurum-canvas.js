import {
  ArrayDataSource,
  Aurum,
  CancellationToken,
  DataSource,
  DuplexDataSource,
  EventEmitter,
  aurumElementModelIdentitiy,
  createLifeCycle,
  dsMap,
  dsUnique
} from "./chunk-TFLE55A7.js";
import "./chunk-2B2CG5KL.js";

// node_modules/aurum-canvas/prebuilt/esnext/components/component_model.js
var ComponentType;
(function(ComponentType2) {
  ComponentType2[ComponentType2["RECTANGLE"] = 0] = "RECTANGLE";
  ComponentType2[ComponentType2["ELIPSE"] = 1] = "ELIPSE";
  ComponentType2[ComponentType2["LINE"] = 2] = "LINE";
  ComponentType2[ComponentType2["TEXT"] = 3] = "TEXT";
  ComponentType2[ComponentType2["IMAGE"] = 4] = "IMAGE";
  ComponentType2[ComponentType2["GROUP"] = 5] = "GROUP";
  ComponentType2[ComponentType2["STATE"] = 6] = "STATE";
  ComponentType2[ComponentType2["PATH"] = 7] = "PATH";
  ComponentType2[ComponentType2["QUADRATIC_CURVE"] = 8] = "QUADRATIC_CURVE";
  ComponentType2[ComponentType2["BEZIER_CURVE"] = 9] = "BEZIER_CURVE";
  ComponentType2[ComponentType2["REGULAR_POLYGON"] = 10] = "REGULAR_POLYGON";
})(ComponentType || (ComponentType = {}));

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/state.js
var stateSymbol = Symbol("state");
function State(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  const components = api.prerender(children, lc);
  return {
    [stateSymbol]: true,
    x: void 0,
    y: void 0,
    ...props,
    renderedState: void 0,
    animations: [],
    children: components,
    type: ComponentType.STATE
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/utilities.js
function deref(source) {
  if (source instanceof DataSource) {
    return source.value;
  } else {
    return source;
  }
}

// node_modules/aurum-canvas/prebuilt/esnext/components/rendering.js
var regularPolygonKeys = ["x", "y", "opacity", "strokeColor", "fillColor", "path", "sides", "radius", "originX", "originY"];
var pathKeys = ["x", "y", "opacity", "strokeColor", "fillColor", "path", "lineWidth", "originX", "originY"];
var elipseKeys = ["x", "y", "opacity", "strokeColor", "fillColor", "rotation", "rx", "ry", "startAngle", "endAngle", "originX", "originY"];
var lineKeys = ["x", "y", "opacity", "strokeColor", "fillColor", "tx", "ty", "lineWidth", "originX", "originY"];
var quadraticCurveKeys = ["x", "y", "opacity", "strokeColor", "fillColor", "tx", "ty", "cx", "cy", "lineWidth", "originX", "originY"];
var bezierCurveKeys = ["x", "y", "opacity", "strokeColor", "fillColor", "tx", "ty", "cx", "cy", "c2x", "c2y", "lineWidth", "originX", "originY"];
var textKeys = [
  "x",
  "y",
  "realWidth",
  "width",
  "font",
  "fontSize",
  "opacity",
  "strokeColor",
  "fillColor",
  "text",
  "fontWeight",
  "wrapWidth",
  "lineHeight",
  "textBaseline",
  "originX",
  "originY"
];
var rectangleKeys = ["x", "y", "width", "height", "opacity", "strokeColor", "fillColor", "originX", "originY"];
function renderElipse(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, elipseKeys, offsetX, offsetY);
  const { x, y, idle, fillColor, strokeColor, opacity, rx, ry, rotation, startAngle, endAngle } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  context.globalAlpha = opacity;
  const path2d = new Path2D();
  if ((fillColor || strokeColor) && rx > 0.01 && ry > 0.01 && (startAngle ?? 0 !== endAngle)) {
    path2d.ellipse(x, y, rx, ry, rotation ?? 0, startAngle ?? 0, endAngle ?? Math.PI * 2);
    child.renderedState.path = path2d;
  } else {
    child.renderedState.path = void 0;
  }
  drawCanvasPath(child, context, path2d, fillColor, strokeColor);
  return idle;
}
function renderLine(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, lineKeys, offsetX, offsetY);
  const { x, y, idle, fillColor, strokeColor, opacity, tx, ty, lineWidth } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  const path2d = new Path2D();
  context.globalAlpha = opacity;
  if (fillColor || strokeColor) {
    path2d.moveTo(x, y);
    path2d.lineTo(tx, ty);
    context.lineWidth = lineWidth;
    child.renderedState.path = path2d;
  } else {
    child.renderedState.path = void 0;
  }
  drawCanvasPath(child, context, path2d, fillColor, strokeColor);
  return idle;
}
function renderQuadraticCurve(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, quadraticCurveKeys, offsetX, offsetY);
  const { x, y, cx, cy, idle, fillColor, strokeColor, opacity, tx, ty, lineWidth } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  context.globalAlpha = opacity;
  const path2d = new Path2D();
  if (fillColor || strokeColor) {
    path2d.moveTo(x, y);
    path2d.quadraticCurveTo(cx, cy, tx, ty);
    context.lineWidth = lineWidth;
    child.renderedState.path = path2d;
  } else {
    child.renderedState.path = void 0;
  }
  drawCanvasPath(child, context, path2d, fillColor, strokeColor);
  return idle;
}
function renderBezierCurve(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, bezierCurveKeys, offsetX, offsetY);
  const { x, y, cx, cy, c2x, c2y, idle, fillColor, strokeColor, opacity, tx, ty, lineWidth } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  context.globalAlpha = opacity;
  const path2d = new Path2D();
  if (fillColor || strokeColor) {
    path2d.moveTo(x, y);
    path2d.bezierCurveTo(cx, cy, c2x, c2y, tx, ty);
    context.lineWidth = lineWidth;
    child.renderedState.path = path2d;
  } else {
    child.renderedState.path = void 0;
  }
  drawCanvasPath(child, context, path2d, fillColor, strokeColor);
  return idle;
}
function drawCanvasPath(child, context, path2d, fillColor, strokeColor) {
  if (child.fillColor) {
    context.fillStyle = fillColor;
    context.fill(path2d);
  }
  if (child.strokeColor) {
    context.strokeStyle = strokeColor;
    context.stroke(path2d);
  }
  if (child.clip) {
    context.clip(path2d);
  }
}
function renderPath(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, pathKeys, offsetX, offsetY);
  const { x, y, idle, fillColor, strokeColor, opacity, path, lineWidth } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  let path2d;
  context.globalAlpha = opacity;
  if (fillColor || strokeColor) {
    context.lineWidth = lineWidth;
    path2d = new Path2D(path);
    child.renderedState.path = path2d;
  } else {
    child.renderedState.path = void 0;
  }
  if (child.fillColor) {
    context.translate(x, y);
    context.fillStyle = fillColor;
    context.fill(path2d);
    context.translate(-x, -y);
  }
  if (child.strokeColor) {
    context.translate(x, y);
    context.strokeStyle = strokeColor;
    context.stroke(path2d);
    context.translate(-x, -y);
  }
  if (child.clip) {
    context.translate(x, y);
    context.clip(path2d);
    context.translate(-x, -y);
  }
  return idle;
}
function renderRegularPolygon(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, regularPolygonKeys, offsetX, offsetY);
  const { x, y, idle, fillColor, strokeColor, opacity, sides, radius } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  context.globalAlpha = opacity;
  if (renderedState.sides < 3) {
    return idle;
  }
  const path2d = new Path2D();
  if (fillColor || strokeColor) {
    let angle = 0;
    for (let i = 0; i < sides; i++) {
      angle += Math.PI / (sides / 2);
      const targetX = radius * Math.cos(angle);
      const targetY = radius * Math.sin(angle);
      if (i === 0) {
        path2d.moveTo(targetX + radius + x, targetY + radius + y);
      } else {
        path2d.lineTo(targetX + radius + x, targetY + radius + y);
      }
    }
    child.renderedState.path = path2d;
  } else {
    child.renderedState.path = void 0;
  }
  drawCanvasPath(child, context, path2d, fillColor, strokeColor);
  return idle;
}
function renderText(context, child, offsetX, offsetY) {
  var _a, _b, _c, _d;
  const renderedState = resolveValues(child, textKeys, offsetX, offsetY, false);
  let { x, y, idle, fontSize = 16, textBaseline, font, fillColor, strokeColor, opacity, text, fontWeight, width, wrapWidth, lineHeight, originX } = renderedState;
  if (((_a = child.renderedState) == null ? void 0 : _a.width) && !renderedState.width) {
    renderedState.width = child.renderedState.width;
  }
  if (((_b = child.renderedState) == null ? void 0 : _b.realWidth) && !renderedState.realWidth) {
    renderedState.realWidth = child.renderedState.realWidth;
  }
  renderedState.lines = (_c = child.renderedState) == null ? void 0 : _c.lines;
  child.renderedState = renderedState;
  child.renderedState.lines = child.renderedState.lines ?? [];
  let lines = child.renderedState.lines;
  if (textBaseline) {
    context.textBaseline = textBaseline;
  }
  context.font = `${fontWeight ? fontWeight + " " : ""}${fontSize}px ${font ?? "Arial"}`;
  renderedState.height = fontSize;
  if (lines.length === 0) {
    if (wrapWidth) {
      child.renderedState.realWidth = 0;
      const pieces = text.split(" ");
      let line = pieces.shift();
      while (pieces.length) {
        const measuredWidth = context.measureText(line + " " + pieces[0]);
        if (measuredWidth.width > child.renderedState.realWidth) {
          child.renderedState.realWidth = measuredWidth.width;
        }
        if (measuredWidth <= wrapWidth) {
          line += " " + pieces.shift();
        } else {
          lines.push(line);
          line = pieces.shift();
        }
      }
      lines.push(line);
    } else {
      if (!width) {
        child.renderedState.realWidth = child.renderedState.width = context.measureText(text).width;
      } else {
        child.renderedState.realWidth = context.measureText(text).width;
      }
      lines.push(text);
    }
  }
  (_d = child.onPreDraw) == null ? void 0 : _d.call(child, child.renderedState);
  context.globalAlpha = opacity;
  if (originX) {
    x -= Math.min(child.renderedState.realWidth, child.renderedState.width) * originX;
  }
  for (let i = 0; i < lines.length; i++) {
    if (fillColor) {
      context.fillStyle = fillColor;
      context.fillText(lines[i], x, y + (lineHeight ?? 16) * i, width);
    }
    if (strokeColor) {
      context.strokeStyle = strokeColor;
      context.strokeText(lines[i], x, y + (lineHeight ?? 16) * i, width);
    }
  }
  return idle;
}
function renderRectangle(context, child, offsetX, offsetY) {
  var _a;
  const renderedState = resolveValues(child, rectangleKeys, offsetX, offsetY);
  const { x, y, width, height, idle, fillColor, strokeColor, opacity } = renderedState;
  child.renderedState = renderedState;
  (_a = child.onPreDraw) == null ? void 0 : _a.call(child, child.renderedState);
  if (opacity <= 0 && !child.clip) {
    return idle;
  }
  context.globalAlpha = opacity;
  if (fillColor) {
    context.fillStyle = fillColor;
    context.fillRect(x, y, width, height);
  }
  if (strokeColor) {
    context.strokeStyle = strokeColor;
    context.strokeRect(x, y, width, height);
  }
  if (child.clip) {
    context.beginPath();
    context.rect(x, y, width, height);
    context.clip();
  }
  return idle;
}
function resolveValues(node, props, offsetX, offsetY, applyOrigin = true) {
  var _a;
  const result = {
    idle: true,
    x: 0,
    y: 0
  };
  let idle = true;
  for (const key of props) {
    const baseValue = deref(node[key]);
    const state = (_a = node.animationStates) == null ? void 0 : _a.find((n) => n[key] != void 0);
    if (state) {
      let progress;
      if (!state.transitionTime) {
        progress = 1;
      } else {
        progress = Math.min(1, (Date.now() - node.animationTime) / deref(state.transitionTime));
      }
      const targetValue = state[key];
      result[key] = baseValue + (targetValue - baseValue) * progress;
      if (progress < 1) {
        idle = false;
      }
    } else {
      result[key] = baseValue;
    }
  }
  result.x += offsetX;
  result.y += offsetY;
  if (applyOrigin) {
    if (result.originX && result.width) {
      result.x -= result.width * result.originX;
    }
    if (result.originY && result.height) {
      result.y -= result.height * result.originY;
    }
  }
  if ("tx" in result) {
    result.tx += offsetX;
  }
  if ("ty" in result) {
    result.ty += offsetY;
  }
  if ("cx" in result) {
    result.cx += offsetX;
  }
  if ("cy" in result) {
    result.cy += offsetY;
  }
  if ("c2x" in result) {
    result.c2x += offsetX;
  }
  if ("c2y" in result) {
    result.c2y += offsetY;
  }
  result.idle = idle;
  return result;
}

// node_modules/aurum-canvas/prebuilt/esnext/components/features.js
function initializeKeyboardPanningFeature(props, canvas) {
  let moveToken;
  const keyDown = /* @__PURE__ */ new Set();
  const moveVector = {
    x: 0,
    y: 0
  };
  window.addEventListener("keyup", (e) => {
    if (e.keyCode === props.features.panning.keyboard.leftKeyCode || e.keyCode === props.features.panning.keyboard.rightKeyCode) {
      moveVector.x = 0;
      keyDown.delete(e.keyCode);
    }
    if (e.keyCode === props.features.panning.keyboard.upKeyCode || e.keyCode === props.features.panning.keyboard.downKeyCode) {
      moveVector.y = 0;
      keyDown.delete(e.keyCode);
    }
    if (moveToken && keyDown.size === 0) {
      moveToken.cancel();
      moveToken = void 0;
    }
  });
  window.addEventListener("keydown", (e) => {
    if (e.keyCode === props.features.panning.keyboard.leftKeyCode) {
      moveVector.x = props.features.panning.keyboard.pixelsPerFrame;
      keyDown.add(e.keyCode);
    }
    if (e.keyCode === props.features.panning.keyboard.downKeyCode) {
      moveVector.y = -props.features.panning.keyboard.pixelsPerFrame;
      keyDown.add(e.keyCode);
    }
    if (e.keyCode === props.features.panning.keyboard.rightKeyCode) {
      moveVector.x = -props.features.panning.keyboard.pixelsPerFrame;
      keyDown.add(e.keyCode);
    }
    if (e.keyCode === props.features.panning.keyboard.upKeyCode) {
      moveVector.y = props.features.panning.keyboard.pixelsPerFrame;
      keyDown.add(e.keyCode);
    }
    if (!moveToken && keyDown.size > 0) {
      moveToken = new CancellationToken();
      moveToken.animationLoop(() => {
        props.translate.update({
          x: props.translate.value.x + moveVector.x,
          y: props.translate.value.y + moveVector.y
        });
      });
    }
  });
}
function initializeMousePanningFeature(props, canvas) {
  let downX;
  let downY;
  let beforeX;
  let beforeY;
  let down = false;
  canvas.addEventListener("mousedown", (e) => {
    downX = e.clientX;
    downY = e.clientY;
    beforeX = props.translate.value.x;
    beforeY = props.translate.value.y;
    down = true;
  });
  document.addEventListener("mousemove", (e) => {
    if (down) {
      props.translate.update({
        x: beforeX - (downX - e.clientX) / props.scale.value.x,
        y: beforeY - (downY - e.clientY) / props.scale.value.y
      });
    }
  });
  document.addEventListener("mouseup", (e) => {
    down = false;
  });
}
function initializeZoomFeature(props, canvas) {
  canvas.addEventListener("wheel", (e) => {
    if (e.deltaY > 0) {
      if (props.scale.value.x < props.features.mouseWheelZoom.minZoom) {
        return;
      }
      props.translate.update({
        x: props.translate.value.x + e.offsetX * (props.features.mouseWheelZoom.zoomIncrements - 1) / props.scale.value.x,
        y: props.translate.value.y + e.offsetY * (props.features.mouseWheelZoom.zoomIncrements - 1) / props.scale.value.y
      });
      props.scale.update({
        x: props.scale.value.x / props.features.mouseWheelZoom.zoomIncrements,
        y: props.scale.value.y / props.features.mouseWheelZoom.zoomIncrements
      });
    } else {
      if (props.scale.value.x > props.features.mouseWheelZoom.maxZoom) {
        return;
      }
      props.scale.update({
        x: props.scale.value.x * props.features.mouseWheelZoom.zoomIncrements,
        y: props.scale.value.y * props.features.mouseWheelZoom.zoomIncrements
      });
      props.translate.update({
        x: props.translate.value.x - e.offsetX * (props.features.mouseWheelZoom.zoomIncrements - 1) / props.scale.value.x,
        y: props.translate.value.y - e.offsetY * (props.features.mouseWheelZoom.zoomIncrements - 1) / props.scale.value.y
      });
    }
  });
}

// node_modules/aurum-canvas/prebuilt/esnext/components/canvas.js
var renderCache = /* @__PURE__ */ new WeakMap();
function AurumCanvas(props, children, api) {
  var _a, _b;
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  const components = api.prerender(children, lc);
  let pendingRerender;
  const cancellationToken = new CancellationToken();
  let onMouseMove = new EventEmitter();
  let onMouseUp = new EventEmitter();
  let onMouseDown = new EventEmitter();
  return Aurum.factory("canvas", { onAttach: (canvas) => {
    var _a2, _b2, _c;
    if (props.features) {
      if (!props.scale) {
        props.scale = new DataSource({ x: 1, y: 1 });
      }
      if (!props.translate) {
        props.translate = new DataSource({ x: 0, y: 0 });
      }
      if (props.features.mouseWheelZoom) {
        initializeZoomFeature(props, canvas);
      }
      if ((_a2 = props.features.panning) == null ? void 0 : _a2.mouse) {
        initializeMousePanningFeature(props, canvas);
      }
      if ((_b2 = props.features.panning) == null ? void 0 : _b2.keyboard) {
        initializeKeyboardPanningFeature(props, canvas);
      }
    }
    if (props.width instanceof DataSource) {
      props.width.listen(() => {
        invalidate(canvas);
      }, api.cancellationToken);
    }
    if (props.backgroundColor instanceof DataSource) {
      props.backgroundColor.listen(() => {
        invalidate(canvas);
      }, api.cancellationToken);
    }
    if (props.height instanceof DataSource) {
      props.height.listen(() => {
        invalidate(canvas);
      }, api.cancellationToken);
    }
    bindCanvas(canvas, components, cancellationToken);
    render(canvas, components);
    if (props.translate) {
      props.translate.transform(dsUnique(), api.cancellationToken).listen((v) => {
        invalidate(canvas);
      });
    }
    if (props.scale) {
      props.scale.transform(dsUnique(), api.cancellationToken).listen((v) => {
        invalidate(canvas);
      });
    }
    (_c = props.onAttach) == null ? void 0 : _c.call(props, canvas);
  }, onDetach: () => {
    var _a2;
    cancellationToken.cancel();
    (_a2 = props.onDetach) == null ? void 0 : _a2.call(props);
  }, style: props.style, class: props.class, width: typeof props.width !== "object" ? (_a = props.width) == null ? void 0 : _a.toString() : props.width.transform(dsMap((v) => v.toString())), height: typeof props.height !== "object" ? (_b = props.height) == null ? void 0 : _b.toString() : props.height.transform(dsMap((v) => v.toString())) });
  function bindCanvas(canvas, components2, cancellationToken2) {
    cancellationToken2.registerDomEvent(canvas, "mouseleave", (e) => {
      onMouseMove.fire(e);
    });
    cancellationToken2.registerDomEvent(canvas, "mousemove", (e) => {
      onMouseMove.fire(e);
    });
    cancellationToken2.registerDomEvent(canvas, "mousedown", (e) => {
      onMouseDown.fire(e);
    });
    cancellationToken2.registerDomEvent(canvas, "mouseup", (e) => {
      onMouseUp.fire(e);
    });
    bind(canvas, components2, void 0, cancellationToken2);
  }
  function isOnTopOf(e, target, context) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!target.renderedState) {
      return false;
    }
    let x = e.offsetX - (((_a2 = props.translate) == null ? void 0 : _a2.value.x) ? ((_b2 = props.translate) == null ? void 0 : _b2.value.x) * (((_d = (_c = props.scale) == null ? void 0 : _c.value) == null ? void 0 : _d.x) ?? 1) : 0);
    let y = e.offsetY - (((_e = props.translate) == null ? void 0 : _e.value.y) ? ((_f = props.translate) == null ? void 0 : _f.value.y) * (((_h = (_g = props.scale) == null ? void 0 : _g.value) == null ? void 0 : _h.x) ?? 1) : 0);
    if (props.scale) {
      x /= props.scale.value.x;
      y /= props.scale.value.y;
    }
    if (target.type === ComponentType.TEXT) {
      const label = target;
      const size = deref(label.fontSize) ?? 16;
      if (!label.textBaseline) {
        y += size;
      } else {
        switch (label.textBaseline) {
          case "bottom":
            y += size;
            break;
          case "middle":
            y += size / 2;
            break;
          case "alphabetic":
            y += size;
            break;
        }
      }
    }
    switch (target.type) {
      case ComponentType.IMAGE:
      case ComponentType.RECTANGLE:
      case ComponentType.TEXT:
        return x >= target.renderedState.x && y >= target.renderedState.y && x <= target.renderedState.x + target.renderedState.width * (((_i = props.scale) == null ? void 0 : _i.value.x) ?? 1) && y <= target.renderedState.y + target.renderedState.height * (((_j = props.scale) == null ? void 0 : _j.value.y) ?? 1);
      case ComponentType.ELIPSE:
      case ComponentType.REGULAR_POLYGON:
        if (!target.renderedState.path) {
          return false;
        } else {
          return context.isPointInPath(target.renderedState.path, x, y);
        }
      default:
        if (!target.renderedState.path) {
          return false;
        } else {
          return context.isPointInPath(target.renderedState.path, x - target.renderedState.x, y - target.renderedState.y);
        }
    }
  }
  function bind(canvas, children2, parent, cancellationToken2) {
    for (const child of children2) {
      if (child instanceof ArrayDataSource) {
        child.listen(() => invalidate(canvas), cancellationToken2);
        const tokenMap = /* @__PURE__ */ new Map();
        child.listenAndRepeat((change) => {
          switch (change.operation) {
            case "add":
              for (const item of change.items) {
                tokenMap.set(item, new CancellationToken());
                bindDynamicEntity(item, child, tokenMap.get(item));
              }
              break;
            case "remove":
              for (const item of change.items) {
                tokenMap.get(item).cancel();
                tokenMap.delete(item);
              }
              break;
            case "replace":
              tokenMap.get(change.target).cancel();
              tokenMap.delete(change.target);
              tokenMap.set(change.items[0], new CancellationToken());
              bindDynamicEntity(change.items[0], child, tokenMap.get(change.items[0]));
              break;
            case "swap":
              break;
            case "merge":
              throw new Error("Operation not supported");
          }
        });
        continue;
      }
      if (child instanceof DataSource || child instanceof DuplexDataSource) {
        child.listen(() => invalidate(canvas), cancellationToken2);
        let bindToken;
        let value;
        child.listenAndRepeat((newValue) => {
          if (value !== newValue) {
            value = newValue;
            if (bindToken) {
              bindToken.cancel();
            }
            bindToken = new CancellationToken();
            bindDynamicEntity(value, child, bindToken);
          }
        });
        continue;
      }
      if (child[stateSymbol]) {
        if (!parent) {
          throw new Error("Cannot use <State> nodes at root level");
        }
        parent.animations.push(child);
        continue;
      }
      if ("onMouseEnter" in child || "onMouseLeave" in child) {
        let isInside = false;
        onMouseMove.subscribe((e) => {
          if (isOnTopOf(e, child, canvas.getContext("2d"))) {
            if (!isInside && child.onMouseEnter) {
              child.onMouseEnter(e, child);
            }
            isInside = true;
          } else {
            if (isInside && child.onMouseLeave) {
              child.onMouseLeave(e, child);
            }
            isInside = false;
          }
        }, cancellationToken2);
      }
      for (const key in child) {
        if (key === "onMouseUp") {
          onMouseUp.subscribe((e) => {
            if (isOnTopOf(e, child, canvas.getContext("2d"))) {
              child.onMouseUp(e, child);
            }
          }, cancellationToken2);
          continue;
        }
        if (key === "onMouseDown") {
          onMouseUp.subscribe((e) => {
            if (isOnTopOf(e, child, canvas.getContext("2d"))) {
              child.onMouseUp(e, child);
            }
          }, cancellationToken2);
          continue;
        }
        if (key === "onMouseClick") {
          onMouseUp.subscribe((e) => {
            if (isOnTopOf(e, child, canvas.getContext("2d"))) {
              child.onMouseClick(e, child);
            }
          }, cancellationToken2);
          continue;
        }
        if (child[key] instanceof DataSource) {
          let value = child[key].value;
          let lastState;
          if (key === "state") {
            const value2 = deref(child[key]);
            lastState = value2;
            child.animationStates = child.animations.filter((e) => e.id === value2);
            child.animationTime = Date.now();
          }
          child[key].listen((newValue) => {
            if (value !== newValue) {
              value = newValue;
              if (key === "state") {
                if (lastState !== newValue) {
                  lastState = newValue;
                  child.animationStates = child.animations.filter((e) => e.id === newValue);
                  child.animationTime = Date.now();
                  invalidate(canvas);
                }
              } else {
                invalidate(canvas);
              }
            }
          }, cancellationToken2);
        }
      }
      bind(canvas, child.children, child, cancellationToken2);
    }
    function bindDynamicEntity(value, parent2, bindToken) {
      const arrayedValue = Array.isArray(value) ? value : [value];
      const lc2 = createLifeCycle();
      const renderResult = [];
      for (const piece of arrayedValue) {
        if (!piece) {
          continue;
        }
        if (!renderCache.has(piece)) {
          renderCache.set(piece, api.prerender(piece, lc2));
        }
        renderResult.push(renderCache.get(piece));
      }
      bind(canvas, renderResult, parent2, bindToken);
      lc2.onAttach();
      bindToken.addCancellable(() => lc2.onDetach());
      invalidate(canvas);
    }
  }
  function invalidate(canvas) {
    if (!pendingRerender) {
      pendingRerender = requestAnimationFrame(() => {
        pendingRerender = void 0;
        if (canvas.isConnected) {
          render(canvas, components);
        }
      });
    }
  }
  function render(canvas, components2) {
    const context = canvas.getContext("2d");
    if (props.backgroundColor === void 0) {
      context.clearRect(0, 0, canvas.width, canvas.height);
    } else {
      context.fillStyle = deref(props.backgroundColor);
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    applyContextTransformation(context);
    for (const child of components2) {
      renderChild(context, child, 0, 0);
    }
    unapplyContextTransformation(context);
  }
  function unapplyContextTransformation(context) {
    if (props.scale || props.translate) {
      context.restore();
    }
  }
  function applyContextTransformation(context) {
    var _a2, _b2;
    if (props.scale || props.translate) {
      context.save();
      if ((_a2 = props.scale) == null ? void 0 : _a2.value) {
        context.scale(props.scale.value.x, props.scale.value.y);
      }
      if ((_b2 = props.translate) == null ? void 0 : _b2.value) {
        context.translate(props.translate.value.x, props.translate.value.y);
      }
    }
  }
  function renderChild(context, child, offsetX, offsetY) {
    if (child === void 0 || child === null) {
      return;
    }
    if (Array.isArray(child)) {
      for (const item of child) {
        renderChild(context, item, offsetX, offsetY);
      }
      return;
    }
    if (child[stateSymbol]) {
      return;
    }
    if (child[aurumElementModelIdentitiy]) {
      if (!renderCache.has(child)) {
        throw new Error("illegal state: unrendered aurum element made it into the canvas render phase");
      }
      child = renderCache.get(child);
    }
    if (child instanceof ArrayDataSource) {
      for (const node of child.getData()) {
        renderChild(context, node, offsetX, offsetY);
      }
      return;
    }
    if (child instanceof DataSource || child instanceof DuplexDataSource) {
      renderChild(context, child.value, offsetX, offsetY);
      return;
    }
    context.save();
    let idle;
    switch (child.type) {
      case ComponentType.PATH:
        idle = renderPath(context, child, offsetX, offsetY);
        break;
      case ComponentType.REGULAR_POLYGON:
        idle = renderRegularPolygon(context, child, offsetX, offsetY);
        break;
      case ComponentType.RECTANGLE:
        idle = renderRectangle(context, child, offsetX, offsetY);
        break;
      case ComponentType.TEXT:
        idle = renderText(context, child, offsetX, offsetY);
        break;
      case ComponentType.LINE:
        idle = renderLine(context, child, offsetX, offsetY);
        break;
      case ComponentType.QUADRATIC_CURVE:
        idle = renderQuadraticCurve(context, child, offsetX, offsetY);
        break;
      case ComponentType.BEZIER_CURVE:
        idle = renderBezierCurve(context, child, offsetX, offsetY);
        break;
      case ComponentType.ELIPSE:
        idle = renderElipse(context, child, offsetX, offsetY);
        break;
      case ComponentType.GROUP:
        idle = true;
        break;
    }
    if (!idle) {
      invalidate(context.canvas);
    }
    for (const subChild of child.children) {
      renderChild(context, subChild, deref(child.x) + offsetX, deref(child.y) + offsetY);
    }
    context.restore();
  }
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_rectangle.js
function AurumRectangle(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    opacity: props.opacity ?? 1,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.RECTANGLE
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_text.js
function AurumText(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const content = api.prerender(children, lc).filter((c) => !!c);
  const text = new DataSource("");
  if (props.font instanceof DataSource) {
    props.font.listen(() => {
      if (result.renderedState) {
        result.renderedState.lines = [];
      }
    }, api.cancellationToken);
  }
  if (props.fontWeight instanceof DataSource) {
    props.fontWeight.listen(() => {
      if (result.renderedState) {
        result.renderedState.lines = [];
      }
    }, api.cancellationToken);
  }
  if (props.fontSize instanceof DataSource) {
    props.fontSize.listen(() => {
      if (result.renderedState) {
        result.renderedState.lines = [];
      }
    }, api.cancellationToken);
  }
  if (props.width instanceof DataSource) {
    props.width.listen(() => {
      if (result.renderedState) {
        result.renderedState.lines = [];
      }
    }, api.cancellationToken);
  }
  if (props.wrapWidth instanceof DataSource) {
    props.wrapWidth.listen(() => {
      if (result.renderedState) {
        result.renderedState.lines = [];
      }
    }, api.cancellationToken);
  }
  for (const i of content) {
    if (i instanceof DataSource) {
      i.transform(dsUnique(), api.cancellationToken).listen((v) => {
        if (result.renderedState) {
          result.renderedState.lines = [];
        }
        updateText(text, content);
      });
    }
  }
  updateText(text, content);
  const result = {
    ...props,
    opacity: props.opacity ?? 1,
    renderedState: void 0,
    text,
    children: [],
    animations: [],
    type: ComponentType.TEXT
  };
  return result;
}
function updateText(text, content) {
  text.update(content.reduce((p, c) => {
    if (typeof c === "string") {
      return `${p}${c}`;
    } else {
      if (c.value) {
        return `${p}${c.value}`;
      } else {
        return p;
      }
    }
  }, ""));
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_line.js
function AurumLine(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    opacity: props.opacity ?? 1,
    lineWidth: props.lineWidth ?? 1,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.LINE
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_elipse.js
function AurumElipse(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    opacity: props.opacity ?? 1,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.ELIPSE
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_group.js
function AurumGroup(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  props.x ?? (props.x = 0);
  props.y ?? (props.y = 0);
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.GROUP
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_path.js
function AurumPath(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    opacity: props.opacity ?? 1,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.PATH
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_image.js
function AurumImage(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    opacity: props.opacity ?? 1,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.IMAGE
  };
}

// node_modules/aurum-canvas/prebuilt/esnext/components/drawables/aurum_regular_polygon.js
function AurumRegularPolygon(props, children, api) {
  const lc = createLifeCycle();
  api.synchronizeLifeCycle(lc);
  if (props.onAttach) {
    api.onAttach(() => props.onAttach());
  }
  if (props.onDetach) {
    api.onDetach(() => props.onDetach());
  }
  const components = api.prerender(children, lc).filter((c) => !!c);
  return {
    ...props,
    opacity: props.opacity ?? 1,
    renderedState: void 0,
    children: components,
    animations: [],
    type: ComponentType.REGULAR_POLYGON
  };
}
export {
  AurumCanvas,
  AurumElipse,
  AurumGroup,
  AurumImage,
  AurumLine,
  AurumPath,
  AurumRectangle,
  AurumRegularPolygon,
  AurumText,
  State,
  stateSymbol
};
//# sourceMappingURL=aurum-canvas.js.map
