import {
  __publicField
} from "./chunk-2B2CG5KL.js";

// node_modules/aurumjs/prebuilt/esnext/utilities/cancellation_token.js
var _CancellationToken = class _CancellationToken {
  constructor(...cancellables) {
    __publicField(this, "cancelables");
    __publicField(this, "_isCancelled");
    this.cancelables = cancellables ?? [];
    this._isCancelled = false;
  }
  get isCancelled() {
    return this._isCancelled;
  }
  static fromMultiple(tokens) {
    const result = new _CancellationToken();
    for (const token of tokens) {
      token.chain(result);
    }
    return result;
  }
  hasCancellables() {
    return this.cancelables.length > 0;
  }
  /**
   * Attaches a new cancelable to this token
   * @param delegate
   */
  addCancellable(delegate) {
    this.throwIfCancelled("attempting to add cancellable to token that is already cancelled");
    this.cancelables.push(delegate);
    if (this.cancelables.length === 200) {
      console.log("potential memory leak: cancellation token has over 200 clean up calls");
    }
    return this;
  }
  removeCancellable(delegate) {
    this.throwIfCancelled("attempting to remove cancellable from token that is already cancelled");
    const index = this.cancelables.indexOf(delegate);
    if (index !== -1) {
      this.cancelables.splice(index, 1);
    }
    return this;
  }
  setTimeout(cb, time = 0) {
    const id = setTimeout(() => {
      this.removeCancellable(cancelable);
      cb();
    }, time);
    const cancelable = () => clearTimeout(id);
    this.addCancellable(cancelable);
  }
  setInterval(cb, time) {
    const id = setInterval(cb, time);
    this.addCancellable(() => clearInterval(id));
  }
  requestAnimationFrame(cb) {
    const id = requestAnimationFrame(() => {
      this.removeCancellable(cancelable);
      cb();
    });
    const cancelable = () => cancelAnimationFrame(id);
    this.addCancellable(cancelable);
  }
  animationLoop(cb) {
    registerAnimationLoop(cb, this);
  }
  throwIfCancelled(msg) {
    if (this.isCancelled) {
      throw new Error(msg || "cancellation token is cancelled");
    }
  }
  chain(target, twoWays = false) {
    const cancelable = () => target.cancel();
    if (twoWays) {
      target.chain(this, false);
    } else {
      target.addCancellable(() => {
        if (!this.isCancelled) {
          this.removeCancellable(cancelable);
        }
      });
    }
    this.addCancellable(cancelable);
    return this;
  }
  /**
   * Registers an event using addEventListener and if you cancel the token the event will be canceled as well
   */
  registerDomEvent(eventEmitter, event, callback) {
    eventEmitter.addEventListener(event, callback);
    this.addCancellable(() => eventEmitter.removeEventListener(event, callback));
    return this;
  }
  /**
   * Registers an event using on and if you cancel the token the event will be canceled using off as well
   */
  registerEmitterEvent(eventEmitter, event, callback) {
    eventEmitter.on(event, callback);
    this.addCancellable(() => eventEmitter.off(event, callback));
    return this;
  }
  /**
   * Cancels everything attached to this token
   */
  cancel() {
    if (this.isCancelled) {
      return;
    }
    this._isCancelled = true;
    this.cancelables.forEach((c) => c());
    this.cancelables = void 0;
  }
};
__publicField(_CancellationToken, "forever", new _CancellationToken());
var CancellationToken = _CancellationToken;
var animationCbs = [];
var looping = false;
function registerAnimationLoop(callback, token) {
  animationCbs.push(callback);
  token.addCancellable(() => {
    animationCbs.splice(animationCbs.indexOf(callback), 1);
  });
  if (!looping) {
    looping = true;
    requestAnimationFrame(loop);
  }
}
function loop(time) {
  for (const cb of animationCbs) {
    try {
      cb(time);
    } catch (e) {
      console.error(e);
    }
  }
  if (animationCbs.length === 0) {
    looping = false;
  }
  if (looping) {
    requestAnimationFrame(loop);
  }
}
CancellationToken.forever.addCancellable = () => void 0;
CancellationToken.forever.cancel = () => {
  throw new Error("Cannot cancel forever token");
};

// node_modules/aurumjs/prebuilt/esnext/aurum_server/aurum_server_client.js
var RemoteProtocol;
(function(RemoteProtocol2) {
  RemoteProtocol2[RemoteProtocol2["HEARTBEAT"] = 0] = "HEARTBEAT";
  RemoteProtocol2[RemoteProtocol2["LISTEN_DATASOURCE"] = 1] = "LISTEN_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_DATASOURCE_ERR"] = 2] = "LISTEN_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["UPDATE_DATASOURCE"] = 3] = "UPDATE_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_DATASOURCE_ERR"] = 4] = "UPDATE_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["CANCEL_DATASOURCE"] = 5] = "CANCEL_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["PERFORM_RPC"] = 6] = "PERFORM_RPC";
  RemoteProtocol2[RemoteProtocol2["PERFORM_RPC_ERR"] = 7] = "PERFORM_RPC_ERR";
  RemoteProtocol2[RemoteProtocol2["PERFORM_RPC_RESULT"] = 8] = "PERFORM_RPC_RESULT";
  RemoteProtocol2[RemoteProtocol2["PERFORM_RPC_RESULT_ERR"] = 9] = "PERFORM_RPC_RESULT_ERR";
  RemoteProtocol2[RemoteProtocol2["LISTEN_DUPLEX_DATASOURCE_ERR"] = 10] = "LISTEN_DUPLEX_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["LISTEN_DUPLEX_DATASOURCE"] = 11] = "LISTEN_DUPLEX_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_DUPLEX_DATASOURCE"] = 12] = "UPDATE_DUPLEX_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_DUPLEX_DATASOURCE_ERR"] = 13] = "UPDATE_DUPLEX_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["CANCEL_DUPLEX_DATASOURCE"] = 14] = "CANCEL_DUPLEX_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_ARRAY_DATASOURCE"] = 15] = "LISTEN_ARRAY_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_ARRAY_DATASOURCE_ERR"] = 16] = "LISTEN_ARRAY_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["UPDATE_ARRAY_DATASOURCE"] = 17] = "UPDATE_ARRAY_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_ARRAY_DATASOURCE_ERR"] = 18] = "UPDATE_ARRAY_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["CANCEL_ARRAY_DATASOURCE"] = 19] = "CANCEL_ARRAY_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_MAP_DATASOURCE"] = 20] = "LISTEN_MAP_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_MAP_DATASOURCE_ERR"] = 21] = "LISTEN_MAP_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["UPDATE_MAP_DATASOURCE"] = 22] = "UPDATE_MAP_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_MAP_DATASOURCE_ERR"] = 23] = "UPDATE_MAP_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["CANCEL_MAP_DATASOURCE"] = 24] = "CANCEL_MAP_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_OBJECT_DATASOURCE"] = 25] = "LISTEN_OBJECT_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_OBJECT_DATASOURCE_ERR"] = 26] = "LISTEN_OBJECT_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["UPDATE_OBJECT_DATASOURCE"] = 27] = "UPDATE_OBJECT_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_OBJECT_DATASOURCE_ERR"] = 28] = "UPDATE_OBJECT_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["CANCEL_OBJECT_DATASOURCE"] = 29] = "CANCEL_OBJECT_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_SET_DATASOURCE"] = 30] = "LISTEN_SET_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["LISTEN_SET_DATASOURCE_ERR"] = 31] = "LISTEN_SET_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["UPDATE_SET_DATASOURCE"] = 32] = "UPDATE_SET_DATASOURCE";
  RemoteProtocol2[RemoteProtocol2["UPDATE_SET_DATASOURCE_ERR"] = 33] = "UPDATE_SET_DATASOURCE_ERR";
  RemoteProtocol2[RemoteProtocol2["CANCEL_SET_DATASOURCE"] = 34] = "CANCEL_SET_DATASOURCE";
})(RemoteProtocol || (RemoteProtocol = {}));
var pendingRPCResponses = /* @__PURE__ */ new Map();
function getRemoteFunction(aurumServerInfo, cancellation) {
  return syncFunction(aurumServerInfo, cancellation);
}
function syncFunction(aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  return async (input) => {
    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
    return new Promise((resolve, reject) => {
      const client = connections.get(key);
      if (!client) {
        throw new Error("Client not connected");
      }
      return client.performRPC(input, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation).then(resolve, reject);
    });
  };
}
async function syncSetDataSource(source, aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
  connections.get(key).syncSetDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
}
async function syncObjectDataSource(source, aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
  connections.get(key).syncObjectDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
}
async function syncMapDataSource(source, aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
  connections.get(key).syncMapDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
}
async function syncDataSource(source, aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
  connections.get(key).syncDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
}
function makeKey(protocol, host) {
  return `${resolveProtocol(protocol)}://${resolveHost(host)}`;
}
async function syncArrayDataSource(source, aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
  connections.get(key).syncArrayDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
}
async function syncDuplexDataSource(source, aurumServerInfo, cancellation) {
  const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);
  await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);
  connections.get(key).syncDuplexDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);
}
var connections = /* @__PURE__ */ new Map();
var pendingConnections = /* @__PURE__ */ new Map();
var AurumServerClient = class _AurumServerClient {
  constructor(connection) {
    __publicField(this, "masterToken");
    __publicField(this, "connection");
    __publicField(this, "synchedDataSources");
    __publicField(this, "synchedDuplexDataSources");
    __publicField(this, "synchedArrayDataSources");
    __publicField(this, "synchedMapDataSources");
    __publicField(this, "synchedObjectDataSources");
    __publicField(this, "synchedSetDataSources");
    this.masterToken = new CancellationToken();
    this.connection = connection;
    this.synchedDataSources = /* @__PURE__ */ new Map();
    this.synchedDuplexDataSources = /* @__PURE__ */ new Map();
    this.synchedArrayDataSources = /* @__PURE__ */ new Map();
    this.synchedMapDataSources = /* @__PURE__ */ new Map();
    this.synchedObjectDataSources = /* @__PURE__ */ new Map();
    this.synchedSetDataSources = /* @__PURE__ */ new Map();
  }
  syncDataSource(source, id, authenticationToken, cancellation) {
    this.syncSource(cancellation, id, authenticationToken, source, this.synchedDataSources, RemoteProtocol.LISTEN_DATASOURCE, RemoteProtocol.CANCEL_DATASOURCE);
  }
  syncObjectDataSource(source, id, authenticationToken, cancellation) {
    this.syncSource(cancellation, id, authenticationToken, source, this.synchedObjectDataSources, RemoteProtocol.LISTEN_OBJECT_DATASOURCE, RemoteProtocol.CANCEL_OBJECT_DATASOURCE);
  }
  performRPC(input, endpointId, authenticationToken, cancellation) {
    return new Promise((resolve, reject) => {
      const uuid = Math.random().toString();
      pendingRPCResponses.set(uuid, { resolve, reject });
      this.connection.send(JSON.stringify({
        type: RemoteProtocol.PERFORM_RPC,
        token: authenticationToken,
        id: endpointId,
        value: input,
        uuid
      }));
    });
  }
  syncSetDataSource(source, id, authenticationToken, cancellation) {
    this.syncSource(cancellation, id, authenticationToken, source, this.synchedSetDataSources, RemoteProtocol.LISTEN_SET_DATASOURCE, RemoteProtocol.CANCEL_SET_DATASOURCE);
  }
  syncMapDataSource(source, id, authenticationToken, cancellation) {
    this.syncSource(cancellation, id, authenticationToken, source, this.synchedMapDataSources, RemoteProtocol.LISTEN_MAP_DATASOURCE, RemoteProtocol.CANCEL_MAP_DATASOURCE);
  }
  syncArrayDataSource(source, id, authenticationToken, cancellation) {
    this.syncSource(cancellation, id, authenticationToken, source, this.synchedArrayDataSources, RemoteProtocol.LISTEN_ARRAY_DATASOURCE, RemoteProtocol.CANCEL_ARRAY_DATASOURCE);
  }
  syncDuplexDataSource(source, id, authenticationToken, cancellation) {
    this.syncSource(cancellation, id, authenticationToken, source, this.synchedDuplexDataSources, RemoteProtocol.LISTEN_DUPLEX_DATASOURCE, RemoteProtocol.CANCEL_DUPLEX_DATASOURCE);
    source.listenUpstream((v) => {
      this.connection.send(JSON.stringify({
        type: RemoteProtocol.UPDATE_DUPLEX_DATASOURCE,
        token: authenticationToken,
        value: v,
        id
      }));
    }, CancellationToken.fromMultiple([cancellation, this.masterToken]));
  }
  syncSource(cancellation, id, authenticationToken, source, syncedSources, listenMessage, cancelMessage) {
    cancellation.addCancellable(() => {
      const listenersByAuth = syncedSources.get(id);
      const listeners = listenersByAuth.get(authenticationToken);
      listeners.listeners.splice(listeners.listeners.findIndex((s) => s.source === source));
      if (listeners.listeners.length === 0) {
        listenersByAuth.delete(authenticationToken);
        listeners.source.cancelAll();
        this.connection.send(JSON.stringify({
          type: cancelMessage,
          id,
          token: authenticationToken
        }));
      }
    });
    if (!syncedSources.has(id)) {
      syncedSources.set(id, /* @__PURE__ */ new Map());
    }
    if (!syncedSources.get(id).has(authenticationToken)) {
      this.connection.send(JSON.stringify({
        type: listenMessage,
        id,
        token: authenticationToken
      }));
      syncedSources.get(id).set(authenticationToken, { source, listeners: [] });
    }
    syncedSources.get(id).get(authenticationToken).listeners.push({
      source,
      token: cancellation
    });
  }
  static connect(host, protocol) {
    let pendingToken = new CancellationToken();
    let started = false;
    let latency = [0, 0, 0, 0, 0];
    let cycle = 0;
    let latencyTs;
    let lastBeat;
    return new Promise((resolve, reject) => {
      protocol = resolveProtocol(protocol);
      host = resolveHost(host);
      const connection = new WebSocket(`${protocol}://${host}`);
      const client = new _AurumServerClient(connection);
      client.masterToken.addCancellable(() => {
        connections.delete(makeKey(protocol, host));
      });
      pendingToken.setTimeout(() => {
        connection.close(4001, "no response");
        reject();
        client.masterToken.cancel();
      }, 5e3);
      connection.addEventListener("message", (m) => {
        lastBeat = Date.now();
        try {
          const msg = JSON.parse(m.data);
          switch (msg.type) {
            case RemoteProtocol.HEARTBEAT:
              latency[cycle] = Date.now() - latencyTs;
              if ((cycle + 1) % latency.length === 0) {
                console.log(`AurumServer latency: ${(latency.reduce((p, c) => p + c) / latency.length).toFixed(1)}ms`);
                cycle = 0;
              } else {
                cycle++;
              }
              break;
            case RemoteProtocol.PERFORM_RPC_RESULT_ERR:
            case RemoteProtocol.PERFORM_RPC_ERR:
              pendingRPCResponses.get(msg.uuid).reject(new Error(msg.error));
              pendingRPCResponses.delete(msg.uuid);
              break;
            case RemoteProtocol.PERFORM_RPC_RESULT:
              pendingRPCResponses.get(msg.uuid).resolve(msg.result);
              pendingRPCResponses.delete(msg.uuid);
              break;
            case RemoteProtocol.UPDATE_DATASOURCE:
              if (client.synchedDataSources.has(msg.id)) {
                const byAuth = client.synchedDataSources.get(msg.id);
                for (const dss of byAuth.values()) {
                  dss.source.update(msg.value);
                }
              }
              break;
            case RemoteProtocol.UPDATE_ARRAY_DATASOURCE:
              if (client.synchedArrayDataSources.has(msg.id)) {
                const byAuth = client.synchedArrayDataSources.get(msg.id);
                for (const dss of byAuth.values()) {
                  const change = msg.change;
                  dss.source.applyCollectionChange(change);
                }
              }
              break;
            case RemoteProtocol.UPDATE_DUPLEX_DATASOURCE:
              if (client.synchedDuplexDataSources.has(msg.id)) {
                const byAuth = client.synchedDuplexDataSources.get(msg.id);
                for (const dss of byAuth.values()) {
                  dss.source.updateDownstream(msg.value);
                }
              }
              break;
            case RemoteProtocol.UPDATE_MAP_DATASOURCE:
              if (client.synchedMapDataSources.has(msg.id)) {
                const byAuth = client.synchedMapDataSources.get(msg.id);
                for (const dss of byAuth.values()) {
                  dss.source.applyMapChange(msg.change);
                }
              }
              break;
          }
        } catch (e) {
          console.warn("Recieved malformed message from server");
          console.warn(e);
        }
      });
      connection.addEventListener("error", (e) => {
        client.masterToken.cancel();
        reject(e);
      });
      connection.addEventListener("open", () => {
        pendingToken.cancel();
        pendingToken = void 0;
        started = true;
        lastBeat = Date.now();
        client.masterToken.setInterval(() => {
          if (Date.now() - lastBeat > 1e4) {
            connection.close(4e3, "timeout");
            return;
          }
          latencyTs = Date.now();
          connection.send(JSON.stringify({
            type: RemoteProtocol.HEARTBEAT
          }));
        }, 2500);
        resolve(client);
      });
      connection.addEventListener("close", () => {
        client.masterToken.cancel();
        if (started) {
          ensureConnection(makeKey(protocol, host), protocol, host).then((newClient) => {
            newClient.migrate(client);
          });
        } else {
          reject();
        }
      });
    });
  }
  migrate(client) {
    for (const id of client.synchedDataSources.keys()) {
      for (const auth of client.synchedDataSources.get(id).keys()) {
        for (const { source, token } of client.synchedDataSources.get(id).get(auth).listeners) {
          this.syncDataSource(source, id, auth, token);
        }
      }
    }
    for (const id of client.synchedArrayDataSources.keys()) {
      for (const auth of client.synchedArrayDataSources.get(id).keys()) {
        for (const { source, token } of client.synchedArrayDataSources.get(id).get(auth).listeners) {
          this.syncArrayDataSource(source, id, auth, token);
        }
      }
    }
    for (const id of client.synchedDuplexDataSources.keys()) {
      for (const auth of client.synchedDuplexDataSources.get(id).keys()) {
        for (const { source, token } of client.synchedDuplexDataSources.get(id).get(auth).listeners) {
          this.syncDuplexDataSource(source, id, auth, token);
        }
      }
    }
    for (const id of client.synchedMapDataSources.keys()) {
      for (const auth of client.synchedMapDataSources.get(id).keys()) {
        for (const { source, token } of client.synchedMapDataSources.get(id).get(auth).listeners) {
          this.syncMapDataSource(source, id, auth, token);
        }
      }
    }
    for (const id of client.synchedObjectDataSources.keys()) {
      for (const auth of client.synchedObjectDataSources.get(id).keys()) {
        for (const { source, token } of client.synchedObjectDataSources.get(id).get(auth).listeners) {
          this.syncObjectDataSource(source, id, auth, token);
        }
      }
    }
    for (const id of client.synchedSetDataSources.keys()) {
      for (const auth of client.synchedSetDataSources.get(id).keys()) {
        for (const { source, token } of client.synchedSetDataSources.get(id).get(auth).listeners) {
          this.syncSetDataSource(source, id, auth, token);
        }
      }
    }
    this.synchedDataSources = /* @__PURE__ */ new Map();
    this.synchedDuplexDataSources = /* @__PURE__ */ new Map();
    this.synchedArrayDataSources = /* @__PURE__ */ new Map();
    this.synchedMapDataSources = /* @__PURE__ */ new Map();
    this.synchedObjectDataSources = /* @__PURE__ */ new Map();
    this.synchedSetDataSources = /* @__PURE__ */ new Map();
  }
};
function resolveProtocol(protocol) {
  if (!protocol) {
    if (typeof location === "undefined") {
      throw new Error("Protocol is not optional in non browser environments");
    }
    if (location.protocol.startsWith("https")) {
      protocol = "wss";
    } else {
      protocol = "ws";
    }
  }
  return protocol;
}
function resolveHost(host) {
  if (!host) {
    if (typeof location === "undefined") {
      throw new Error("Host is not optional in non browser environments");
    }
    return location.host;
  }
  return host;
}
async function ensureConnection(key, protocol, host) {
  if (connections.has(key)) {
    return connections.get(key);
  }
  let backoff = 1e3;
  if (pendingConnections.has(key)) {
    return pendingConnections.get(key);
  } else {
    const pendingConnection = new Promise((resolve) => {
      async function tryConnect() {
        const p = AurumServerClient.connect(host, protocol);
        try {
          const client = await p;
          connections.set(key, client);
          pendingConnections.delete(key);
          resolve(client);
          backoff = 1e3;
        } catch (e) {
          setTimeout(() => {
            backoff += 1e3;
            tryConnect();
          }, backoff);
        }
      }
      tryConnect();
    });
    pendingConnections.set(key, pendingConnection);
    return pendingConnection;
  }
}

// node_modules/aurumjs/prebuilt/esnext/utilities/event_emitter.js
var _EventEmitter = class _EventEmitter {
  constructor() {
    __publicField(this, "isFiring");
    __publicField(this, "onAfterFire");
    /**
     * Callback that if set is called when all subscriptions are removed
     */
    __publicField(this, "onEmpty");
    __publicField(this, "subscribeChannel");
    __publicField(this, "subscribeOnceChannel");
    this.subscribeChannel = [];
    this.subscribeOnceChannel = [];
    this.onAfterFire = [];
  }
  /**
   * Set a number of subscriptions that any event can have at most before emitting warnings. The subscriptions will continue working but the warnings can be used
   * to track potential subscription memory leaks
   */
  static setSubscriptionLeakWarningThreshold(limit) {
    _EventEmitter.leakWarningThreshold = limit;
  }
  /**
   * returns the count of subscriptions both one time and regular
   */
  get subscriptions() {
    return this.subscribeChannel.length + this.subscribeOnceChannel.length;
  }
  toAsyncIterator(cancellationToken) {
    const buffer = new Array();
    let sink;
    cancellationToken == null ? void 0 : cancellationToken.addCancellable(() => {
      if (sink) {
        sink({
          done: true,
          value: void 0
        });
      } else {
        buffer.push({
          done: true,
          value: void 0
        });
      }
    });
    this.subscribe((value) => {
      if (sink) {
        sink({
          done: false,
          value
        });
        sink = void 0;
      } else {
        buffer.push({
          done: false,
          value
        });
      }
    }, cancellationToken);
    return {
      [Symbol.asyncIterator]() {
        return this;
      },
      async next() {
        if (buffer.length > 0) {
          return buffer.shift();
        }
        return new Promise((resolve) => {
          sink = resolve;
        });
      }
    };
  }
  /**
   * Subscribe to the event. The callback will be called whenever the event fires an update
   */
  subscribe(callback, cancellationToken) {
    const { facade } = this.createSubscription(callback, this.subscribeChannel, cancellationToken);
    if (_EventEmitter.leakWarningThreshold && this.subscribeChannel.length > _EventEmitter.leakWarningThreshold) {
      console.warn(`Observable has ${this.subscribeChannel.length} subscriptions. This could potentially indicate a memory leak`);
    }
    return facade;
  }
  /**
   * Subscribe to the event. The callback will be called when the event next fires an update after which the subscription is cancelled
   */
  subscribeOnce(callback, cancellationToken) {
    const { facade } = this.createSubscription(callback, this.subscribeOnceChannel, cancellationToken);
    if (_EventEmitter.leakWarningThreshold && this.subscribeOnceChannel.length > _EventEmitter.leakWarningThreshold) {
      console.warn(`Observable has ${this.subscribeOnceChannel.length} one time subscriptions. This could potentially indicate a memory leak`);
    }
    return facade;
  }
  /**
   * Whether the event has any subscriptions
   */
  hasSubscriptions() {
    return this.subscriptions > 0;
  }
  /**
   * Removes all currently active subscriptions. If called in the callback of a subscription will be defered until after the fire event finished
   */
  cancelAll() {
    var _a;
    if (!this.isFiring) {
      this.subscribeChannel.length = 0;
      this.subscribeOnceChannel.length = 0;
      (_a = this.onEmpty) == null ? void 0 : _a.call(this);
    } else {
      this.onAfterFire.push(() => {
        var _a2;
        this.subscribeChannel.length = 0;
        this.subscribeOnceChannel.length = 0;
        (_a2 = this.onEmpty) == null ? void 0 : _a2.call(this);
      });
    }
  }
  afterFire() {
    if (this.onAfterFire.length > 0) {
      this.onAfterFire.forEach((cb) => cb());
      this.onAfterFire.length = 0;
    }
  }
  /**
   * Publishes a new value all subscribers will be called
   * Errors in the callbacks are caught and deferred until after fire finishes before throwing to avoid interrupting the propagation of the event
   * to all subscribers simply because of one faulty subscriber
   */
  fire(data) {
    const length = this.subscribeChannel.length;
    const lengthOnce = this.subscribeOnceChannel.length;
    if (length === 0 && lengthOnce === 0) {
      return;
    }
    this.isFiring = true;
    let error = void 0;
    for (let i = 0; i < length; i++) {
      try {
        this.subscribeChannel[i].callback(data);
      } catch (e) {
        error = e;
        console.error(e);
      }
    }
    if (this.subscribeOnceChannel.length > 0) {
      for (let i = 0; i < lengthOnce; i++) {
        try {
          this.subscribeOnceChannel[i].callback(data);
        } catch (e) {
          error = e;
          console.error(e);
        }
      }
      this.subscribeOnceChannel.length = 0;
    }
    this.isFiring = false;
    this.afterFire();
    if (error) {
      throw error;
    }
  }
  createSubscription(callback, channel, cancellationToken) {
    const that = this;
    const subscription = {
      callback
    };
    const facade = {
      cancel() {
        that.cancel(subscription, channel);
      }
    };
    if (cancellationToken !== void 0) {
      cancellationToken.addCancellable(() => that.cancel(subscription, channel));
    }
    if (this.isFiring) {
      this.onAfterFire.push(() => channel.push(subscription));
    } else {
      channel.push(subscription);
    }
    return { subscription, facade };
  }
  cancel(subscription, channel) {
    var _a;
    let index = channel.indexOf(subscription);
    if (index >= 0) {
      if (!this.isFiring) {
        channel.splice(index, 1);
        if (!this.hasSubscriptions()) {
          (_a = this.onEmpty) == null ? void 0 : _a.call(this);
        }
      } else {
        this.onAfterFire.push(() => this.cancel(subscription, channel));
      }
    }
  }
};
__publicField(_EventEmitter, "leakWarningThreshold");
var EventEmitter = _EventEmitter;

// node_modules/aurumjs/prebuilt/esnext/debug_mode.js
var debugMode = false;
var customWindow = globalThis;
var debugStreamData;
function enableDebugMode() {
  debugStreamData = [];
  debugMode = true;
  setInterval(() => garbageCollect(), 6e4);
  customWindow.__debugUpdates = new EventEmitter();
  customWindow.__debugNewSource = new EventEmitter();
  customWindow.__debugLinked = new EventEmitter();
  customWindow.__debugUnlinked = new EventEmitter();
  customWindow.__debugGetStreamData = () => debugStreamData.map(serializeStreamData);
}
function serializeStreamData(ref) {
  let serializedValue;
  try {
    serializedValue = JSON.stringify(ref.value);
  } catch (e) {
    serializedValue = "[Unserializable]";
  }
  return {
    name: ref.name,
    value: serializedValue,
    children: ref.children,
    consumers: ref.consumers,
    id: ref.id,
    parents: ref.parents,
    stack: ref.stack,
    timestamp: ref.timestamp
  };
}
function debugRegisterStream(stream, stack) {
  const ref = {
    name: stream.name,
    value: stream.value,
    id: Math.random(),
    children: [],
    parents: [],
    stack,
    timestamp: Date.now(),
    reference: new WeakRef(stream),
    consumers: []
  };
  debugStreamData.push(ref);
  customWindow.__debugNewSource.fire({
    source: serializeStreamData(ref)
  });
}
function debugRegisterLink(parent, child) {
  let pref = findDataByRef(parent);
  let cref = findDataByRef(child);
  if (!pref) {
    throw new Error("illegal state");
  }
  if (!cref) {
    throw new Error("illegal state");
  }
  pref.children.push(cref.id);
  cref.parents.push(pref.id);
  customWindow.__debugLinked.fire({
    child: serializeStreamData(cref),
    parent: serializeStreamData(pref)
  });
}
function debugDeclareUpdate(source, value, stack) {
  let ref = findDataByRef(source);
  if (!ref) {
    throw new Error("illegal state");
  }
  ref.value = source.value;
  customWindow.__debugUpdates.fire({
    newValue: value,
    source: serializeStreamData(ref),
    stack
  });
}
function debugRegisterConsumer(stream, consumer, consumerStack) {
  let ref = findDataByRef(stream);
  if (!ref) {
    throw new Error("illegal state");
  }
  ref.consumers.push({
    code: consumer,
    stack: consumerStack
  });
}
function garbageCollect() {
  debugStreamData = debugStreamData.filter((dsd) => dsd.reference.deref() !== void 0);
}
function findDataByRef(target) {
  return debugStreamData.find((dsd) => dsd.reference.deref() === target);
}

// node_modules/aurumjs/prebuilt/esnext/stream/operator_model.js
var OperationType;
(function(OperationType2) {
  OperationType2[OperationType2["FILTER"] = 0] = "FILTER";
  OperationType2[OperationType2["NOOP"] = 1] = "NOOP";
  OperationType2[OperationType2["MAP"] = 2] = "MAP";
  OperationType2[OperationType2["DELAY"] = 3] = "DELAY";
  OperationType2[OperationType2["MAP_DELAY"] = 4] = "MAP_DELAY";
  OperationType2[OperationType2["DELAY_FILTER"] = 5] = "DELAY_FILTER";
  OperationType2[OperationType2["MAP_DELAY_FILTER"] = 6] = "MAP_DELAY_FILTER";
})(OperationType || (OperationType = {}));

// node_modules/aurumjs/prebuilt/esnext/utilities/iteration.js
var FILTERED = Symbol("filtered");
async function* transformAsyncIterator(asyncIterator, operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
  let token;
  const operations = [
    operationA,
    operationB,
    operationC,
    operationD,
    operationE,
    operationF,
    operationG,
    operationH,
    operationI,
    operationJ,
    operationK
  ].filter((e) => e && (e instanceof CancellationToken ? (token = e, false) : true));
  if (cancellationToken) {
    token = cancellationToken;
  }
  const transform = async (v) => {
    try {
      for (const operation of operations) {
        switch (operation.operationType) {
          case OperationType.NOOP:
          case OperationType.MAP:
            v = operation.operation(v);
            break;
          case OperationType.MAP_DELAY_FILTER:
            const tmp = await operation.operation(v);
            if (tmp.cancelled) {
              return;
            } else {
              v = await tmp.item;
            }
            break;
          case OperationType.DELAY:
          case OperationType.MAP_DELAY:
            v = await operation.operation(v);
            break;
          case OperationType.DELAY_FILTER:
            if (!await operation.operation(v)) {
              return FILTERED;
            }
            break;
          case OperationType.FILTER:
            if (!operation.operation(v)) {
              return FILTERED;
            }
            break;
        }
      }
      return v;
    } catch (e) {
      throw e;
    }
  };
  for await (const v of asyncIterator) {
    if (token == null ? void 0 : token.isCancelled) {
      return;
    }
    const i = await transform(v);
    if (i !== FILTERED) {
      yield i;
    }
  }
  return;
}
function promiseIterator(promises, cancellation) {
  let pendingCount = promises.length;
  const output = new DataSource();
  cancellation = cancellation ?? new CancellationToken();
  for (const promise of promises) {
    promise.then((v) => {
      pendingCount--;
      output.update({
        status: "fulfilled",
        value: v
      });
      if (pendingCount === 0) {
        cancellation.cancel();
      }
    }, (e) => {
      pendingCount--;
      output.update({
        status: "rejected",
        reason: e
      });
      if (pendingCount === 0) {
        cancellation.cancel();
      }
    });
  }
  return output.toAsyncIterator(cancellation);
}

// node_modules/aurumjs/prebuilt/esnext/stream/stream.js
var Stream = class _Stream {
  constructor() {
    __publicField(this, "input");
    __publicField(this, "output");
  }
  get name() {
    return `IN:${this.input.name} OUT:${this.output.name}`;
  }
  /**
   * The current value of this data source, can be changed through update
   */
  get value() {
    return this.output.value;
  }
  static fromFunction(func) {
    const result = new _Stream();
    result.input = new DataSource();
    result.output = new DataSource();
    result.input.listen((value) => {
      result.output.update(func(value));
    });
    return result;
  }
  static fromFetchRaw(url) {
    const input = new DataSource();
    const output = new DataSource();
    input.listen((value) => {
      output.update(fetch(url, value));
    });
    return _Stream.fromPreconnectedSources(input, output);
  }
  static fromPreconnectedSources(inputSource, outputSource) {
    const result = new _Stream();
    result.input = inputSource ?? new DataSource();
    result.output = outputSource ?? result.input;
    return result;
  }
  aggregate(otherSources, combinator, cancellationToken) {
    cancellationToken = cancellationToken ?? new CancellationToken();
    const aggregatedSource = new DataSource(combinator(this.value, ...otherSources.map((s) => s.value)));
    for (let i = 0; i < otherSources.length; i++) {
      otherSources[i].listen(() => {
        aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s.value)));
      }, cancellationToken);
    }
    this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s.value))), cancellationToken);
    return aggregatedSource;
  }
  static fromStreamTransformation(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ) {
    const result = new _Stream();
    result.input = new DataSource();
    result.output = result.input.transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ);
    return result;
  }
  static fromFetchPostJson(url, baseRequestData) {
    const input = new DataSource();
    const output = new DataSource();
    input.listen(async (value) => {
      output.update(await fetch(url, Object.assign({
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        }
      }, baseRequestData, {
        body: JSON.stringify(value)
      })).then((s) => s.json()));
    });
    return _Stream.fromPreconnectedSources(input, output);
  }
  static fromFetchGetJson(url, baseRequestData) {
    const input = new DataSource();
    const output = new DataSource();
    input.listen(async () => {
      output.update(await fetch(url).then((s) => s.json()));
    });
    return _Stream.fromPreconnectedSources(input, output);
  }
  update(data) {
    this.input.update(data);
  }
  transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
    let token;
    const operations = [
      operationA,
      operationB,
      operationC,
      operationD,
      operationE,
      operationF,
      operationG,
      operationH,
      operationI,
      operationJ,
      operationK
    ].filter((e) => e && (e instanceof CancellationToken ? (token = e, false) : true));
    if (cancellationToken) {
      token = cancellationToken;
    }
    const result = new DataSource(void 0, this.output.name + " " + operations.map((v) => v.name).join(" "));
    this.listen(processTransform(operations, result), token);
    return _Stream.fromPreconnectedSources(this.input, result);
  }
  getInput() {
    return this.input;
  }
  getOutput() {
    return this.output;
  }
  listen(callback, cancellationToken) {
    return this.output.listen(callback, cancellationToken);
  }
  listenAndRepeat(callback, cancellationToken) {
    return this.output.listenAndRepeat(callback, cancellationToken);
  }
  listenOnce(callback, cancellationToken) {
    return this.output.listenOnce(callback, cancellationToken);
  }
  awaitNextUpdate(cancellationToken) {
    return this.output.awaitNextUpdate(cancellationToken);
  }
  cancelAll() {
    this.input.cancelAll();
    this.output.cancelAll();
  }
};

// node_modules/aurumjs/prebuilt/esnext/stream/data_source_operators.js
function dsMap(mapper) {
  return {
    name: "map",
    operationType: OperationType.MAP,
    operation: (v) => mapper(v)
  };
}
function dsFork(condition, truthyPath, falsyPath) {
  return {
    name: "fork",
    operationType: OperationType.NOOP,
    operation: (v) => {
      if (condition(v)) {
        truthyPath.update(v);
      } else {
        falsyPath.update(v);
      }
      return v;
    }
  };
}
function dsMapAsync(mapper) {
  return {
    name: "mapAsync",
    operationType: OperationType.MAP_DELAY,
    operation: (v) => mapper(v)
  };
}
function dsDiff() {
  let lastValue = void 0;
  return {
    name: "diff",
    operationType: OperationType.MAP,
    operation: (v) => {
      let result = {
        oldValue: lastValue,
        newValue: v
      };
      lastValue = v;
      return result;
    }
  };
}
function dsUpdateToken() {
  let token;
  return {
    name: "diff",
    operationType: OperationType.MAP,
    operation: (v) => {
      if (token) {
        token.cancel();
      }
      token = new CancellationToken();
      return {
        token,
        value: v
      };
    }
  };
}
function dsFilter(predicate) {
  return {
    name: "filter",
    operationType: OperationType.FILTER,
    operation: (v) => predicate(v)
  };
}
function dsFilterAsync(predicate) {
  return {
    name: "filterAsync",
    operationType: OperationType.DELAY_FILTER,
    operation: (v) => predicate(v)
  };
}
function dsEven() {
  return {
    name: "even",
    operationType: OperationType.FILTER,
    operation: (v) => v % 2 === 0
  };
}
function dsOdd() {
  return {
    name: "odd",
    operationType: OperationType.FILTER,
    operation: (v) => v % 2 !== 0
  };
}
function dsMin() {
  let last = Number.MAX_SAFE_INTEGER;
  return {
    name: "min",
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (v < last) {
        last = v;
        return true;
      } else {
        return false;
      }
    }
  };
}
function dsMax() {
  let last = Number.MIN_SAFE_INTEGER;
  return {
    name: "max",
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (v > last) {
        last = v;
        return true;
      } else {
        return false;
      }
    }
  };
}
function dsSkipDynamic(amountLeft) {
  return {
    operationType: OperationType.FILTER,
    name: "skipDynamic",
    operation: (v) => {
      if (amountLeft.value === 0) {
        return true;
      } else {
        amountLeft.update(amountLeft.value - 1);
        return false;
      }
    }
  };
}
function dsSkip(amount) {
  return {
    operationType: OperationType.FILTER,
    name: `skip ${amount}`,
    operation: (v) => {
      if (amount === 0) {
        return true;
      } else {
        amount--;
        return false;
      }
    }
  };
}
function dsCutOff(amount) {
  return {
    name: `cutoff ${amount}`,
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (amount === 0) {
        return false;
      } else {
        amount--;
        return true;
      }
    }
  };
}
function dsCutOffDynamic(amountLeft) {
  return {
    name: "cutoffDynamic",
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (amountLeft.value === 0) {
        return false;
      } else {
        amountLeft.update(amountLeft.value - 1);
        return true;
      }
    }
  };
}
function dsSemaphore(state) {
  return {
    operationType: OperationType.DELAY,
    name: "semaphore",
    operation: (v) => {
      return new Promise((resolve) => {
        if (state.value > 0) {
          state.update(state.value - 1);
          resolve(v);
        } else {
          const cancel = state.listen(() => {
            if (state.value > 0) {
              cancel();
              state.update(state.value - 1);
              resolve(v);
            }
          });
        }
      });
    }
  };
}
function dsUnique(isEqual) {
  let primed = false;
  let last;
  return {
    name: "unique",
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (primed && (isEqual ? isEqual(last, v) : v === last)) {
        return false;
      } else {
        primed = true;
        last = v;
        return true;
      }
    }
  };
}
function dsAwait() {
  return {
    name: "await",
    operationType: OperationType.MAP_DELAY,
    operation: (v) => {
      return v;
    }
  };
}
function dsAwaitOrdered() {
  const queue = [];
  const onDequeue = new EventEmitter();
  return {
    operationType: OperationType.MAP_DELAY,
    name: "awaitOrdered",
    operation: async (v) => {
      queue.push(v);
      if (queue.length === 1) {
        return processItem();
      } else {
        const unsub = onDequeue.subscribe(async () => {
          if (queue[0] === v) {
            unsub.cancel();
            return processItem();
          }
        });
      }
    }
  };
  async function processItem() {
    await queue[0];
    const item = queue.shift();
    onDequeue.fire();
    return item;
  }
}
function dsAwaitLatest() {
  let freshnessToken;
  return {
    operationType: OperationType.MAP_DELAY_FILTER,
    name: "awaitLatest",
    operation: async (v) => {
      freshnessToken = Date.now();
      const timestamp = freshnessToken;
      const resolved = await v;
      if (freshnessToken === timestamp) {
        return {
          item: resolved,
          cancelled: false
        };
      } else {
        return {
          item: void 0,
          cancelled: true
        };
      }
    }
  };
}
function dsReduce(reducer, initialValue) {
  let last = initialValue;
  return {
    name: "reduce",
    operationType: OperationType.MAP,
    operation: (v) => {
      last = reducer(last, v);
      return last;
    }
  };
}
function dsStringJoin(seperator = ", ") {
  let last;
  return {
    name: `stringJoin ${seperator}`,
    operationType: OperationType.MAP,
    operation: (v) => {
      if (last) {
        last += seperator + v;
      } else {
        last = v;
      }
      return last;
    }
  };
}
function dsDelay(time) {
  return {
    name: `delay ${time}ms`,
    operationType: OperationType.DELAY,
    operation: (v) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(v);
        }, time);
      });
    }
  };
}
function dsDebounce(time) {
  let timeout;
  let cancelled = new EventEmitter();
  return {
    operationType: OperationType.DELAY_FILTER,
    name: `debounce ${time}ms`,
    operation: (v) => {
      return new Promise((resolve) => {
        clearTimeout(timeout);
        cancelled.fire();
        cancelled.subscribeOnce(() => {
          resolve(false);
        });
        timeout = setTimeout(() => {
          resolve(true);
          cancelled.cancelAll();
        }, time);
      });
    }
  };
}
function dsMicroDebounce() {
  let scheduled;
  return {
    operationType: OperationType.DELAY_FILTER,
    name: `microDebounce`,
    operation: (v) => {
      return new Promise((resolve) => {
        if (!scheduled) {
          scheduled = true;
          queueMicrotask(() => {
            scheduled = false;
            resolve(true);
          });
        } else {
          resolve(false);
        }
      });
    }
  };
}
function dsThrottleFrame() {
  let timeout;
  let cancelled = new EventEmitter();
  return {
    operationType: OperationType.DELAY_FILTER,
    name: `throttle frame`,
    operation: (v) => {
      return new Promise((resolve) => {
        clearTimeout(timeout);
        cancelled.fire();
        cancelled.subscribeOnce(() => {
          resolve(false);
        });
        timeout = requestAnimationFrame(() => {
          resolve(true);
          cancelled.cancelAll();
        });
      });
    }
  };
}
function dsLock(state) {
  return {
    name: "lock",
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (!state.value) {
        return true;
      } else {
        return false;
      }
    }
  };
}
function dsThrottle(time) {
  let cooldown = false;
  return {
    name: `throttle ${time}ms`,
    operationType: OperationType.FILTER,
    operation: (v) => {
      if (!cooldown) {
        cooldown = true;
        setTimeout(() => {
          cooldown = false;
        }, time);
        return true;
      } else {
        return false;
      }
    }
  };
}
function dsBuffer(time) {
  let buffer = [];
  let promise;
  return {
    name: `buffer ${time}ms`,
    operationType: OperationType.MAP_DELAY_FILTER,
    operation: (v) => {
      buffer.push(v);
      if (!promise) {
        promise = new Promise((resolve) => {
          setTimeout(() => {
            promise = void 0;
            resolve({
              cancelled: false,
              item: buffer
            });
            buffer = [];
          }, time);
        });
        return promise;
      } else {
        return Promise.resolve({
          cancelled: true,
          item: void 0
        });
      }
    }
  };
}
function dsPick(key) {
  return {
    name: `pick ${key.toString()}`,
    operationType: OperationType.MAP,
    operation: (v) => {
      if (v !== void 0 && v !== null) {
        return v[key];
      } else {
        return v;
      }
    }
  };
}
function dsPipe(target) {
  return {
    name: `pipe ${target.name}`,
    operationType: OperationType.NOOP,
    operation: (v) => {
      if (target instanceof DataSource || target instanceof Stream) {
        target.update(v);
      } else {
        target.updateDownstream(v);
      }
      return v;
    }
  };
}
function dsPipeUp(target) {
  return {
    name: `pipeup ${target.name}`,
    operationType: OperationType.NOOP,
    operation: (v) => {
      if (target instanceof DataSource || target instanceof Stream) {
        target.update(v);
      } else {
        target.updateUpstream(v);
      }
      return v;
    }
  };
}
function dsHistory(reportTarget, generations, cancellationToken = new CancellationToken()) {
  return {
    operationType: OperationType.NOOP,
    name: `history`,
    operation: (v) => {
      if (!cancellationToken.isCancelled) {
        if (generations) {
          if (reportTarget.length.value >= generations) {
            reportTarget.removeLeft(reportTarget.length.value - generations);
          }
        }
        reportTarget.push(v);
      }
      return v;
    }
  };
}
function dsThroughputMeter(reportTarget, interval, cancellationToken = new CancellationToken()) {
  let amount = 0;
  cancellationToken.setInterval(() => {
    reportTarget.update(amount);
    amount = 0;
  }, interval);
  return {
    operationType: OperationType.NOOP,
    name: `throughput meter`,
    operation: (v) => {
      amount++;
      return v;
    }
  };
}
function dsTap(cb) {
  return {
    name: "tap",
    operationType: OperationType.NOOP,
    operation: (v) => {
      cb(v);
      return v;
    }
  };
}
function dsLoadBalance(targets) {
  let i = 0;
  return {
    name: `loadBalance [${targets.map((v) => v.name).join()}]`,
    operationType: OperationType.NOOP,
    operation: (v) => {
      const target = targets[i++];
      if (i >= targets.length) {
        i = 0;
      }
      if (target instanceof DataSource || target instanceof Stream) {
        target.update(v);
      } else {
        target.updateDownstream(v);
      }
      return v;
    }
  };
}
function dsLog(prefix = "", suffix = "") {
  return {
    name: `log`,
    operationType: OperationType.NOOP,
    operation: (v) => {
      console.log(`${prefix}${v}${suffix}`);
      return v;
    }
  };
}
function dsPipeAll(...sources) {
  return {
    name: `pipeAll [${sources.map((v) => v.name).join()}]`,
    operationType: OperationType.NOOP,
    operation: (v) => {
      sources.forEach((source) => {
        if (source instanceof DataSource || source instanceof Stream) {
          source.update(v);
        } else {
          source.updateDownstream(v);
        }
      });
      return v;
    }
  };
}
function dsAccumulate(initialValue) {
  let sum = initialValue;
  return {
    name: `accumulate`,
    operationType: OperationType.MAP,
    operation: (v) => {
      sum += v;
      return sum;
    }
  };
}

// node_modules/aurumjs/prebuilt/esnext/stream/duplex_data_source_operators.js
var DataFlow;
(function(DataFlow2) {
  DataFlow2[DataFlow2["UPSTREAM"] = 0] = "UPSTREAM";
  DataFlow2[DataFlow2["DOWNSTREAM"] = 1] = "DOWNSTREAM";
})(DataFlow || (DataFlow = {}));
var DataFlowBoth;
(function(DataFlowBoth2) {
  DataFlowBoth2[DataFlowBoth2["UPSTREAM"] = 0] = "UPSTREAM";
  DataFlowBoth2[DataFlowBoth2["DOWNSTREAM"] = 1] = "DOWNSTREAM";
  DataFlowBoth2[DataFlowBoth2["BOTH"] = 2] = "BOTH";
})(DataFlowBoth || (DataFlowBoth = {}));
function ddsMap(mapDown, mapUp) {
  return {
    name: "map",
    operationType: OperationType.MAP,
    operationDown: (v) => mapDown(v),
    operationUp: (v) => mapUp(v)
  };
}
function ddsDebounce(time, direction) {
  const debounceDown = dsDebounce(time);
  const debounceUp = dsDebounce(time);
  return {
    operationType: OperationType.DELAY_FILTER,
    name: `debounce ${time}ms`,
    operationDown: (v) => {
      if (direction === void 0 || direction === DataFlowBoth.DOWNSTREAM || direction === DataFlowBoth.BOTH) {
        return debounceDown.operation(v);
      } else {
        return Promise.resolve(true);
      }
    },
    operationUp: (v) => {
      if (direction === void 0 || direction === DataFlowBoth.UPSTREAM || direction === DataFlowBoth.BOTH) {
        return debounceUp.operation(v);
      } else {
        return Promise.resolve(true);
      }
    }
  };
}
function ddsOneWayFlow(direction) {
  if (direction === DataFlow.DOWNSTREAM) {
    return ddsFilter(() => true, () => false);
  } else {
    return ddsFilter(() => false, () => true);
  }
}
function ddsFilter(predicateDown, predicateUp) {
  return {
    name: "filter",
    operationType: OperationType.FILTER,
    operationDown: (v) => predicateDown(v),
    operationUp: (v) => predicateUp(v)
  };
}
function ddsUnique(direction, isEqual) {
  let lastDown;
  let lastUp;
  let primedUp = false;
  let primedDown = false;
  return {
    name: "filter",
    operationType: OperationType.FILTER,
    operationDown: (v) => {
      if (direction === void 0 || direction === DataFlowBoth.DOWNSTREAM || direction === DataFlowBoth.BOTH) {
        if (primedDown && (isEqual ? isEqual(lastDown, v) : v === lastDown)) {
          return false;
        } else {
          primedDown = true;
          lastDown = v;
          return true;
        }
      } else {
        return true;
      }
    },
    operationUp: (v) => {
      if (direction === void 0 || direction === DataFlowBoth.UPSTREAM || direction === DataFlowBoth.BOTH) {
        if (primedUp && (isEqual ? isEqual(lastUp, v) : v === lastUp)) {
          return false;
        } else {
          lastUp = v;
          primedUp = true;
          return true;
        }
      } else {
        return true;
      }
    }
  };
}

// node_modules/aurumjs/prebuilt/esnext/stream/duplex_data_source.js
var DuplexDataSource = class _DuplexDataSource {
  /**
   * The top can be viewed as the source of truth and bottom as the derived value. UpdateDownStream means the change is propagated from top to bottom or that the source of truth changed.
   * UpdateUpstream means the change is propagated from bottom to top or that the derived value changed.
   * @param initialValue
   * @param rootNode If a write is done propagate this update back down to all the consumers. Useful at the root node because in case of a tree structure changes from one branch won't propagate to the other without this
   */
  constructor(initialValue, rootNode = true, name = "RootDuplexDataSource") {
    /**
     * The current value of this data source, can be changed through update
     */
    __publicField(this, "value");
    __publicField(this, "primed");
    __publicField(this, "errorHandler");
    __publicField(this, "errorEvent");
    __publicField(this, "updatingUpstream");
    __publicField(this, "updatingDownstream");
    __publicField(this, "updateDownstreamEvent");
    __publicField(this, "updateUpstreamEvent");
    __publicField(this, "propagateWritesToReadStream");
    __publicField(this, "name");
    this.name = name;
    this.value = initialValue;
    this.primed = initialValue !== void 0;
    this.updateDownstreamEvent = new EventEmitter();
    this.updateUpstreamEvent = new EventEmitter();
    this.propagateWritesToReadStream = rootNode;
  }
  /**
   * Connects to an aurum-server exposed datasource view https://github.com/CyberPhoenix90/aurum-server for more information
   * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated
   * @param  {AurumServerInfo} aurumServerInfo
   * @returns DataSource
   */
  static fromRemoteSource(aurumServerInfo, cancellation) {
    const result = new _DuplexDataSource(void 0, false);
    syncDuplexDataSource(result, aurumServerInfo, cancellation);
    return result;
  }
  static fromAsyncIterator(iterator, cancellation) {
    const result = new _DuplexDataSource();
    (async () => {
      for await (const item of iterator) {
        if (cancellation == null ? void 0 : cancellation.isCancelled) {
          return;
        }
        result.updateDownstream(item);
      }
    })();
    return result;
  }
  static fromPromise(promise, cancellation) {
    const result = new _DuplexDataSource();
    promise.then((v) => {
      if (cancellation == null ? void 0 : cancellation.isCancelled) {
        return;
      }
      result.updateDownstream(v);
    }, (e) => {
      if (cancellation == null ? void 0 : cancellation.isCancelled) {
        return;
      }
      result.emitError(e, DataFlow.DOWNSTREAM);
    });
    return result;
  }
  static fromPromiseArray(promises, cancellation) {
    const result = new _DuplexDataSource();
    (async () => {
      for await (const promise of promiseIterator(promises, cancellation)) {
        if (cancellation == null ? void 0 : cancellation.isCancelled) {
          return;
        }
        if (promise.status === "fulfilled") {
          result.updateDownstream(promise.value);
        } else {
          result.emitError(promise.reason, DataFlow.DOWNSTREAM);
        }
      }
    })();
    return result;
  }
  toAsyncIterator(cancellation) {
    return this.updateDownstreamEvent.toAsyncIterator(cancellation);
  }
  static toDuplexDataSource(value) {
    if (value instanceof _DuplexDataSource) {
      return value;
    } else {
      return new _DuplexDataSource(value);
    }
  }
  /**
   * Makes it possible to have 2 completely separate data flow pipelines for each direction
   * @param downStream stream to pipe downstream data to
   * @param upstream  stream to pipe upstream data to
   */
  static fromTwoDataSource(downStream, upstream, initialValue, propagateWritesToReadStream = true) {
    const result = new _DuplexDataSource(initialValue, propagateWritesToReadStream);
    result.updateDownstreamEvent = downStream.updateEvent;
    result.updateUpstreamEvent = upstream.updateEvent;
    return result;
  }
  /**
   * Updates the data source with a value if it has never had a value before
   */
  withInitial(value) {
    if (!this.primed) {
      this.updateDownstream(value);
    }
    return this;
  }
  toString() {
    return this.value.toString();
  }
  /**
   * Allows creating a duplex stream that blocks data in one direction. Useful for plugging into code that uses two way flow but only one way is desired
   * @param direction direction of the dataflow that is allowed
   */
  static createOneWay(direction = DataFlow.DOWNSTREAM, initialValue) {
    return new _DuplexDataSource(initialValue, false).transformDuplex(ddsOneWayFlow(direction));
  }
  /**
   * Updates the value in the data source and calls the listen callback for all listeners
   * Moves the data from the top to the bottom. Used to reflect changes in the source data to the derived data
   * @param newValue new value for the data source
   */
  updateDownstream(newValue) {
    if (newValue === this) {
      throw new Error("Cannot update data source with itself");
    }
    if (this.updatingDownstream) {
      throw new Error("Problem in datas source: Unstable value propagation, when updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed");
    }
    this.primed = true;
    this.updatingDownstream = true;
    this.value = newValue;
    this.updateDownstreamEvent.fire(newValue);
    this.updatingDownstream = false;
  }
  /**
   * Updates the value in the data source and calls the listen callback for all listeners.
   * Moves the data from the bottom to the top. Used to reflect changes in derived data back to the source
   * @param newValue new value for the data source
   */
  updateUpstream(newValue) {
    if (newValue === this) {
      throw new Error("Cannot update data source with itself");
    }
    if (this.updatingUpstream) {
      throw new Error("Problem in datas source: Unstable value propagation, when updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed");
    }
    this.primed = true;
    this.updatingUpstream = true;
    this.value = newValue;
    this.updateUpstreamEvent.fire(newValue);
    if (this.propagateWritesToReadStream) {
      this.updateDownstreamEvent.fire(newValue);
    }
    this.updatingUpstream = false;
  }
  /**
   * Same as listen but will immediately call the callback with the current value first
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenAndRepeat(callback, cancellationToken) {
    if (this.primed) {
      callback(this.value);
    }
    return this.listen(callback, cancellationToken);
  }
  /**
   * alias for listenDownstream
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listen(callback, cancellationToken) {
    return this.listenInternal(callback, cancellationToken);
  }
  listenInternal(callback, cancellationToken) {
    return this.updateDownstreamEvent.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Subscribes exclusively to updates of the data stream that occur due to an update flowing upstream
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenUpstream(callback, cancellationToken) {
    return this.updateUpstreamEvent.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Subscribes exclusively to updates of the data stream that occur due to an update flowing upstream
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenUpstreamAndRepeat(callback, cancellationToken) {
    if (this.primed) {
      callback(this.value);
    }
    return this.updateUpstreamEvent.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Subscribes exclusively to one update of the data stream that occur due to an update flowing upstream
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenUpstreamOnce(callback, cancellationToken) {
    return this.updateUpstreamEvent.subscribeOnce(callback, cancellationToken).cancel;
  }
  /**
   * Subscribes exclusively to updates of the data stream that occur due to an update flowing downstream
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenDownstream(callback, cancellationToken) {
    return this.updateDownstreamEvent.subscribe(callback, cancellationToken).cancel;
  }
  downStreamToDataSource(cancellationToken) {
    const downStreamDatasource = new DataSource(this.value);
    this.listenDownstream((newVal) => {
      downStreamDatasource.update(newVal);
    }, cancellationToken);
    return downStreamDatasource;
  }
  aggregate(otherSources, combinator, cancellationToken) {
    var _a;
    cancellationToken = cancellationToken ?? new CancellationToken();
    const aggregatedSource = new DataSource(combinator(this.value, ...otherSources.map((s) => s == null ? void 0 : s.value)));
    for (let i = 0; i < otherSources.length; i++) {
      (_a = otherSources[i]) == null ? void 0 : _a.listen(() => {
        aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s == null ? void 0 : s.value)));
      }, cancellationToken);
    }
    this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s == null ? void 0 : s.value))), cancellationToken);
    return aggregatedSource;
  }
  transformDuplex(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
    let token;
    const operations = [
      operationA,
      operationB,
      operationC,
      operationD,
      operationE,
      operationF,
      operationG,
      operationH,
      operationI,
      operationJ,
      operationK
    ].filter((e) => e && (e instanceof CancellationToken ? (token = e, false) : true));
    if (cancellationToken) {
      token = cancellationToken;
    }
    const result = new _DuplexDataSource(void 0, false, this.name + " " + operations.map((v) => v.name).join(" "));
    (this.primed ? this.listenAndRepeat : this.listen).call(this, processTransformDuplex(operations, result, DataFlow.DOWNSTREAM), token);
    result.listenUpstream.call(result, processTransformDuplex(operations, this, DataFlow.UPSTREAM), token);
    return result;
  }
  transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
    let token;
    const operations = [
      operationA,
      operationB,
      operationC,
      operationD,
      operationE,
      operationF,
      operationG,
      operationH,
      operationI,
      operationJ,
      operationK
    ].filter((e) => e && (e instanceof CancellationToken ? (token = e, false) : true));
    if (cancellationToken) {
      token = cancellationToken;
    }
    const result = new DataSource(void 0, this.name + " " + operations.map((v) => v.name).join(" "));
    (this.primed ? this.listenAndRepeat : this.listen).call(this, processTransform(operations, result), token);
    return result;
  }
  /**
   * Like aggregate except that no combination method is needed as a result both parents must have the same type and the new stream just exposes the last update recieved from either parent
   * @param otherSource Second parent for the new source
   * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources
   */
  combine(otherSources, cancellationToken) {
    cancellationToken = cancellationToken ?? new CancellationToken();
    let combinedDataSource;
    if (this.primed) {
      combinedDataSource = new DataSource(this.value);
    } else {
      combinedDataSource = new DataSource();
    }
    this.pipe(combinedDataSource, cancellationToken);
    for (const otherSource of otherSources) {
      otherSource.pipe(combinedDataSource, cancellationToken);
    }
    return combinedDataSource;
  }
  /**
   * Forwards all updates from this source to another
   * @param targetDataSource datasource to pipe the updates to
   * @param cancellationToken  Cancellation token to cancel the subscriptions added to the datasources by this operation
   */
  pipe(targetDataSource, cancellationToken) {
    this.listenDownstream((newVal) => targetDataSource.update(newVal), cancellationToken);
    targetDataSource.listen((newVal) => this.updateUpstream(newVal), cancellationToken);
    return this;
  }
  listenOnce(callback, cancellationToken) {
    return this.updateDownstreamEvent.subscribeOnce(callback, cancellationToken).cancel;
  }
  /**
   * Returns a promise that resolves when the next update occurs
   * @param cancellationToken
   */
  awaitNextUpdate(cancellationToken) {
    return new Promise((resolve) => {
      this.listenOnce((value) => resolve(value), cancellationToken);
    });
  }
  /**
   * Remove all listeners
   */
  cancelAll() {
    this.updateDownstreamEvent.cancelAll();
    this.updateUpstreamEvent.cancelAll();
  }
  cancelAllDownstream() {
    this.updateDownstreamEvent.cancelAll();
  }
  cancelAllUpstream() {
    this.updateUpstreamEvent.cancelAll();
  }
  /**
   * Assign a function to handle errors and map them back to regular values. Rethrow the error in case you want to fallback to emitting error
   */
  handleErrors(callback) {
    this.errorHandler = callback;
    return this;
  }
  onError(callback, cancellationToken) {
    this.errorEvent.subscribe(callback, cancellationToken);
    return this;
  }
  emitError(e, direction) {
    if (this.errorHandler) {
      try {
        if (direction === DataFlow.DOWNSTREAM) {
          return this.updateDownstream(this.errorHandler(e));
        } else {
          return this.updateUpstream(this.errorHandler(e));
        }
      } catch (newError) {
        e = newError;
      }
    }
    if (this.errorEvent.hasSubscriptions()) {
      this.errorEvent.fire(e);
    } else {
      throw e;
    }
  }
};
function processTransformDuplex(operations, result, direction) {
  return async (v) => {
    try {
      for (const operation of operations) {
        switch (operation.operationType) {
          case OperationType.NOOP:
          case OperationType.MAP:
            v = direction === DataFlow.DOWNSTREAM ? operation.operationDown(v) : operation.operationUp(v);
            break;
          case OperationType.MAP_DELAY_FILTER:
            const tmp = direction === DataFlow.DOWNSTREAM ? await operation.operationDown(v) : await operation.operationUp(v);
            if (tmp.cancelled) {
              return;
            } else {
              v = await tmp.item;
            }
            break;
          case OperationType.DELAY:
          case OperationType.MAP_DELAY:
            v = direction === DataFlow.DOWNSTREAM ? await operation.operationDown(v) : await operation.operationUp(v);
            break;
          case OperationType.DELAY_FILTER:
            if (!(direction === DataFlow.DOWNSTREAM ? await operation.operationDown(v) : await operation.operationUp(v))) {
              return;
            }
            break;
          case OperationType.FILTER:
            if (!(direction === DataFlow.DOWNSTREAM ? operation.operationDown(v) : operation.operationUp(v))) {
              return;
            }
            break;
        }
      }
      if (direction === DataFlow.DOWNSTREAM) {
        result.updateDownstream(v);
      } else {
        result.updateUpstream(v);
      }
    } catch (e) {
      result.emitError(e, direction);
    }
  };
}

// node_modules/aurumjs/prebuilt/esnext/stream/object_data_source.js
var ObjectDataSource = class _ObjectDataSource {
  constructor(initialData) {
    __publicField(this, "data");
    __publicField(this, "updateEvent");
    __publicField(this, "updateEventOnKey");
    this.data = initialData;
    this.updateEvent = new EventEmitter();
    this.updateEventOnKey = /* @__PURE__ */ new Map();
  }
  /**
   * Connects to an aurum-server exposed object datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
   * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server
   * @param  {AurumServerInfo} aurumServerInfo
   * @returns DataSource
   */
  static fromRemoteSource(aurumServerInfo, cancellation) {
    const result = new _ObjectDataSource(void 0);
    syncObjectDataSource(result, aurumServerInfo, cancellation);
    return result;
  }
  static toObjectDataSource(value) {
    if (value instanceof _ObjectDataSource) {
      return value;
    } else {
      return new _ObjectDataSource(value);
    }
  }
  toString() {
    return this.data.toString();
  }
  /**
   * Remove all listeners
   */
  cancelAll() {
    this.updateEvent.cancelAll();
    this.updateEventOnKey.forEach((v) => v.cancelAll());
  }
  pickObject(key, cancellationToken) {
    if (typeof this.data[key] === "object") {
      const subDataSource = new _ObjectDataSource(this.data[key]);
      subDataSource.listen((change) => {
        if (change.deleted) {
          delete this.data[key][change.key];
        } else {
          this.get(key)[change.key] = change.newValue;
        }
      }, cancellationToken);
      this.listenOnKey(key, (v) => {
        if (typeof v.newValue === "object") {
          if (v.newValue !== subDataSource.data) {
            subDataSource.merge(v.newValue);
          }
        } else {
          subDataSource.clear();
        }
      });
      return subDataSource;
    } else {
      throw new Error("Cannot pick a non object key");
    }
  }
  pickArray(key, cancellationToken) {
    var _a;
    if (Array.isArray(this.data[key])) {
      const subDataSource = new ArrayDataSource((_a = this.data) == null ? void 0 : _a[key]);
      subDataSource.listen((change) => {
        this.set(key, change.newState);
      }, cancellationToken);
      this.listenOnKey(key, (v) => {
        if (Array.isArray(v.newValue)) {
          if (v.newValue.length !== subDataSource.length.value || !subDataSource.getData().every((item, index) => v.newValue[index] === item)) {
            subDataSource.merge(v.newValue);
          }
        } else {
          subDataSource.clear();
        }
      });
      return subDataSource;
    } else {
      throw new Error("Cannot pick a non array key");
    }
  }
  /**
   * Creates a datasource for a single key of the object
   * @param key
   * @param cancellationToken
   */
  pick(key, cancellationToken) {
    var _a;
    const subDataSource = new DataSource((_a = this.data) == null ? void 0 : _a[key]);
    subDataSource.listen(() => {
      this.set(key, subDataSource.value);
    }, cancellationToken);
    this.listenOnKey(key, (v) => {
      if (subDataSource.value !== v.newValue) {
        subDataSource.update(v.newValue);
      }
    }, cancellationToken);
    return subDataSource;
  }
  /**
   * Creates a duplexdatasource for a single key of the object
   * @param key
   * @param cancellationToken
   */
  pickDuplex(key, cancellationToken) {
    var _a;
    const subDataSource = new DuplexDataSource((_a = this.data) == null ? void 0 : _a[key]);
    subDataSource.listenUpstream((v) => {
      this.set(key, v);
    });
    this.listenOnKey(key, (v) => {
      if (subDataSource.value !== v.newValue) {
        subDataSource.updateDownstream(v.newValue);
      }
    }, cancellationToken);
    return subDataSource;
  }
  hasKey(key) {
    return this.data.hasOwnProperty(key);
  }
  applyObjectChange(change) {
    if (change.deleted && this.hasKey(change.key)) {
      this.delete(change.key);
    } else if (change.newValue !== this.get(change.key)) {
      this.set(change.key, change.newValue);
    }
  }
  /**
   * Listen to changes of the object
   */
  listen(callback, cancellationToken) {
    return this.updateEvent.subscribe(callback, cancellationToken).cancel;
  }
  map(mapper) {
    const stateMap = /* @__PURE__ */ new Map();
    const result = new ArrayDataSource();
    this.listenAndRepeat((change) => {
      if (change.deleted && stateMap.has(change.key)) {
        const item = stateMap.get(change.key);
        result.remove(item);
        stateMap.delete(change.key);
      } else if (stateMap.has(change.key)) {
        const newItem = mapper(change.key, change.newValue);
        result.replace(stateMap.get(change.key), newItem);
        stateMap.set(change.key, newItem);
      } else if (!stateMap.has(change.key) && !change.deleted) {
        const newItem = mapper(change.key, change.newValue);
        result.push(newItem);
        stateMap.set(change.key, newItem);
      }
    });
    return result;
  }
  /**
   * Same as listen but will immediately call the callback with the current value of each key
   */
  listenAndRepeat(callback, cancellationToken) {
    const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;
    for (const key in this.data) {
      callback({
        key,
        newValue: this.data[key],
        oldValue: void 0,
        deleted: false
      });
    }
    return c;
  }
  /**
   * Same as listenOnKey but will immediately call the callback with the current value first
   */
  listenOnKeyAndRepeat(key, callback, cancellationToken) {
    callback({
      key,
      newValue: this.data[key],
      oldValue: void 0
    });
    return this.listenOnKey(key, callback, cancellationToken);
  }
  /**
   * Listen to changes of a single key of the object
   */
  listenOnKey(key, callback, cancellationToken) {
    if (!this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.set(key, new EventEmitter());
    }
    const event = this.updateEventOnKey.get(key);
    return event.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Returns all the keys of the object in the source
   */
  keys() {
    return Object.keys(this.data);
  }
  /**
   * Returns all the values of the object in the source
   */
  values() {
    return Object.values(this.data);
  }
  /**
   * get the current value of a key of the object
   * @param key
   */
  get(key) {
    return this.data[key];
  }
  /**
   * delete a key from the object
   * @param key
   * @param value
   */
  delete(key) {
    if (this.hasKey(key)) {
      const old = this.data[key];
      delete this.data[key];
      this.updateEvent.fire({ oldValue: old, key, newValue: void 0, deleted: true });
      if (this.updateEventOnKey.has(key)) {
        this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: void 0 });
      }
    }
  }
  /**
   * set the value for a key of the object
   * @param key
   * @param value
   */
  set(key, value) {
    if (this.data[key] === value) {
      return;
    }
    const old = this.data[key];
    this.data[key] = value;
    this.updateEvent.fire({ oldValue: old, key, newValue: this.data[key] });
    if (this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: this.data[key] });
    }
  }
  /**
   * Merge the key value pairs of an object into this object non recursively
   * @param newData
   */
  assign(newData) {
    if (newData instanceof _ObjectDataSource) {
      for (const key of newData.keys()) {
        this.set(key, newData.data[key]);
      }
    } else {
      for (const key of Object.keys(newData)) {
        this.set(key, newData[key]);
      }
    }
  }
  /**
   * Merge the key value pairs of an object into this object non recursively and delete properties that do not exist in the newData
   * @param newData
   */
  merge(newData) {
    const keys = new Set(Object.keys(this.data ?? {}));
    if (newData instanceof _ObjectDataSource) {
      for (const key of newData.keys()) {
        keys.delete(key);
        this.set(key, newData.data[key]);
      }
    } else {
      for (const key of Object.keys(newData)) {
        keys.delete(key);
        this.set(key, newData[key]);
      }
    }
    for (const key of keys) {
      this.delete(key);
    }
  }
  /**
   * Deletes all keys
   */
  clear() {
    if (this.data == void 0) {
      return;
    }
    for (const key in this.data) {
      this.delete(key);
    }
  }
  getData() {
    return this.data;
  }
  /**
   * Returns a shallow copy of the object
   */
  toObject() {
    return { ...this.data };
  }
  /**
   * Returns a simplified version of this datasource
   */
  toDataSource() {
    const stream = new DataSource(this.data);
    this.listen((s) => {
      stream.update(this.data);
    });
    return stream;
  }
};

// node_modules/aurumjs/prebuilt/esnext/utilities/sources.js
function getValueOf(sourceOrPrimitive) {
  if (sourceOrPrimitive instanceof DataSource || sourceOrPrimitive instanceof DuplexDataSource || sourceOrPrimitive instanceof Stream) {
    return sourceOrPrimitive.value;
  }
  if (sourceOrPrimitive instanceof ArrayDataSource) {
    return sourceOrPrimitive.getData();
  }
  return sourceOrPrimitive;
}
function unwrapObjectRecursive(object) {
  if (object instanceof DataSource || object instanceof DuplexDataSource || object instanceof Stream) {
    return unwrapObjectRecursive(object.value);
  }
  if (object instanceof ArrayDataSource) {
    return unwrapObjectRecursive(object.toArray());
  }
  if (object instanceof ObjectDataSource) {
    return unwrapObjectRecursive(object.getData());
  }
  if (object instanceof DuplexDataSource) {
    return unwrapObjectRecursive(object.value);
  }
  if (object instanceof Stream) {
    return unwrapObjectRecursive(object.value);
  }
  if (Array.isArray(object)) {
    return object.map(unwrapObjectRecursive);
  }
  if (object instanceof Object) {
    const result = {};
    for (const key in object) {
      result[key] = unwrapObjectRecursive(object[key]);
    }
    return result;
  }
  return object;
}

// node_modules/aurumjs/prebuilt/esnext/stream/data_source.js
var DataSource = class _DataSource {
  constructor(initialValue, name = "RootDataSource") {
    /**
     * The current value of this data source, can be changed through update
     */
    __publicField(this, "value");
    __publicField(this, "primed");
    __publicField(this, "updating");
    __publicField(this, "name");
    __publicField(this, "updateEvent");
    __publicField(this, "errorHandler");
    __publicField(this, "errorEvent");
    this.name = name;
    this.value = initialValue;
    if (debugMode) {
      debugRegisterStream(this, new Error().stack);
    }
    this.primed = initialValue !== void 0;
    this.errorEvent = new EventEmitter();
    this.updateEvent = new EventEmitter();
  }
  toString() {
    return this.value.toString();
  }
  static toDataSource(value) {
    if (value instanceof _DataSource) {
      return value;
    } else {
      return new _DataSource(value);
    }
  }
  static fromEvent(event, cancellation) {
    const result = new _DataSource();
    event.subscribe((v) => result.update(v), cancellation);
    return result;
  }
  /**
   * Connects to an aurum-server exposed datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
   * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated
   * @param  {AurumServerInfo} aurumServerInfo
   * @returns DataSource
   */
  static fromRemoteSource(aurumServerInfo, cancellation) {
    const result = new _DataSource();
    syncDataSource(result, aurumServerInfo, cancellation);
    return result;
  }
  static fromMultipleSources(sources, cancellation) {
    const result = new _DataSource();
    for (const s of sources) {
      if (debugMode) {
        debugRegisterLink(s, result);
      }
      s.listenInternal((v) => result.update(v), cancellation);
    }
    result.name = `Combination of [${sources.map((v) => v.name).join(" & ")}]`;
    return result;
  }
  static fromAsyncIterator(iterator, cancellation) {
    const result = new _DataSource();
    (async () => {
      try {
        for await (const item of iterator) {
          if (cancellation == null ? void 0 : cancellation.isCancelled) {
            return;
          }
          result.update(item);
        }
      } catch (e) {
        result.emitError(e);
      }
    })();
    return result;
  }
  static fromPromise(promise, cancellation) {
    const result = new _DataSource();
    promise.then((v) => {
      if (cancellation == null ? void 0 : cancellation.isCancelled) {
        return;
      }
      result.update(v);
    }, result.emitError.bind(result));
    return result;
  }
  static fromPromiseArray(promises, cancellation) {
    const result = new _DataSource();
    (async () => {
      for await (const promise of promiseIterator(promises, cancellation)) {
        if (cancellation == null ? void 0 : cancellation.isCancelled) {
          return;
        }
        if (promise.status === "fulfilled") {
          result.update(promise.value);
        } else {
          result.emitError(promise.reason);
        }
      }
    })();
    return result;
  }
  toAsyncIterator(cancellation) {
    return this.updateEvent.toAsyncIterator(cancellation);
  }
  /**
   * Allows tapping into the stream and calls a function for each value.
   */
  tap(callback, cancellationToken) {
    this.listen((value) => {
      callback(value);
    }, cancellationToken);
    return this;
  }
  /**
   * Assign a function to handle errors and map them back to regular values. Rethrow the error in case you want to fallback to emitting error
   */
  handleErrors(callback) {
    this.errorHandler = callback;
    return this;
  }
  onError(callback, cancellationToken) {
    this.errorEvent.subscribe(callback, cancellationToken);
    return this;
  }
  emitError(e) {
    if (this.errorHandler) {
      try {
        return this.update(this.errorHandler(e));
      } catch (newError) {
        e = newError;
      }
    }
    if (this.errorEvent.hasSubscriptions()) {
      this.errorEvent.fire(e);
    } else {
      throw e;
    }
  }
  /**
   * Updates with the same value as the last value
   */
  repeatLast() {
    this.update(this.value);
    return this;
  }
  /**
   * Updates the value in the data source and calls the listen callback for all listeners
   * @param newValue new value for the data source
   */
  update(newValue) {
    if (newValue === this) {
      throw new Error("Cannot update data source with itself");
    }
    this.primed = true;
    if (this.updating) {
      throw new Error("Problem in data source: Unstable value propagation. When updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed");
    }
    this.updating = true;
    this.value = newValue;
    this.updateEvent.fire(newValue);
    if (debugMode) {
      debugDeclareUpdate(this, newValue, new Error().stack);
    }
    this.updating = false;
  }
  /**
   * Updates the data source with a value if it has never had a value before
   */
  withInitial(value) {
    if (!this.primed) {
      this.update(value);
    }
    return this;
  }
  /**
   * Same as listen but will immediately call the callback with the current value first
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenAndRepeat(callback, cancellationToken) {
    if (this.primed) {
      callback(this.value);
    }
    return this.listen(callback, cancellationToken);
  }
  listenAndRepeatInternal(callback, cancellationToken, parent) {
    callback(this.value);
    return this.listenInternal(callback, cancellationToken, parent);
  }
  /**
   * Subscribes to the updates of the data stream
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listen(callback, cancellationToken) {
    if (debugMode) {
      debugRegisterConsumer(this, callback.toString(), new Error().stack);
    }
    return this.listenInternal(callback, cancellationToken);
  }
  listenInternal(callback, cancellationToken, parent) {
    const cancel = this.updateEvent.subscribe(callback, cancellationToken).cancel;
    return cancel;
  }
  /**
   * Subscribes to the updates of the data stream for a single update
   * @param callback Callback to call when value is updated
   * @param cancellationToken Optional token to control the cancellation of the subscription
   * @returns Cancellation callback, can be used to cancel subscription without a cancellation token
   */
  listenOnce(callback, cancellationToken) {
    return this.updateEvent.subscribeOnce(callback, cancellationToken).cancel;
  }
  transform(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK, cancellationToken) {
    let token;
    const operations = [
      operationA,
      operationB,
      operationC,
      operationD,
      operationE,
      operationF,
      operationG,
      operationH,
      operationI,
      operationJ,
      operationK
    ].filter((e) => e && (e instanceof CancellationToken ? (token = e, false) : true));
    if (cancellationToken) {
      token = cancellationToken;
    }
    const result = new _DataSource(void 0, this.name + " " + operations.map((v) => v.name).join(" "));
    if (debugMode) {
      debugRegisterLink(this, result);
    }
    (this.primed ? this.listenAndRepeatInternal : this.listenInternal).call(this, processTransform(operations, result), token);
    this.onError((e) => result.emitError(e), token);
    return result;
  }
  static fromCombination(sources, cancellationToken) {
    if (sources.length === 0) {
      throw new Error("Cannot combine zero data sources");
    }
    return sources[0].combine(sources.slice(1), cancellationToken);
  }
  static fromAggregation(sources, combinator, cancellationToken) {
    var _a;
    cancellationToken = cancellationToken ?? new CancellationToken();
    const aggregatedSource = new _DataSource(combinator(...sources.map((s) => s == null ? void 0 : s.value)));
    for (let i = 0; i < sources.length; i++) {
      (_a = sources[i]) == null ? void 0 : _a.listen(() => {
        aggregatedSource.update(combinator(...sources.map((s) => s == null ? void 0 : s.value)));
      }, cancellationToken);
    }
    return aggregatedSource;
  }
  aggregate(otherSources, combinator, cancellationToken) {
    var _a;
    cancellationToken = cancellationToken ?? new CancellationToken();
    const aggregatedSource = new _DataSource(combinator(this.value, ...otherSources.map((s) => s == null ? void 0 : s.value)));
    for (let i = 0; i < otherSources.length; i++) {
      (_a = otherSources[i]) == null ? void 0 : _a.listen(() => {
        aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s == null ? void 0 : s.value)));
      }, cancellationToken);
    }
    this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s == null ? void 0 : s.value))), cancellationToken);
    return aggregatedSource;
  }
  /**
   * Forwards all updates from this source to another
   * @param targetDataSource datasource to pipe the updates to
   * @param cancellationToken  Cancellation token to cancel the subscription the target datasource has to this datasource
   */
  pipe(targetDataSource, cancellationToken) {
    this.listen((v) => targetDataSource.update(v), cancellationToken);
    return this;
  }
  /**
   * Like aggregate except that it aggregates an array data source of datasources
   * @param data Second parent for the new source
   * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources
   */
  static dynamicAggregation(data, aggregate, cancellationToken) {
    cancellationToken = cancellationToken ?? new CancellationToken();
    const session = /* @__PURE__ */ new WeakMap();
    const result = new _DataSource();
    data.listenAndRepeat((change) => {
      for (const item of change.items) {
        listenToSubSource(item);
      }
      result.update(aggregate(data.getData().map((e) => e.value)));
    });
    data.onItemsAdded.subscribe((items) => {
      for (const item of items) {
        listenToSubSource(item);
      }
    });
    data.onItemsRemoved.subscribe((items) => {
      for (const item of items) {
        session.get(item).cancel();
        session.delete(item);
      }
    });
    return result;
    function listenToSubSource(item) {
      session.set(item, new CancellationToken());
      item.listen(() => {
        result.update(aggregate(data.getData().map((e) => e.value)));
      }, session.get(item));
    }
  }
  /**
   * Like aggregate except that no combination method is needed as a result both parents must have the same type and the new stream just exposes the last update recieved from either parent
   * @param otherSource Second parent for the new source
   * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources
   */
  combine(otherSources, cancellationToken) {
    cancellationToken = cancellationToken ?? new CancellationToken();
    let combinedDataSource;
    if (this.primed) {
      combinedDataSource = new _DataSource(this.value);
    } else {
      combinedDataSource = new _DataSource();
    }
    this.pipe(combinedDataSource, cancellationToken);
    for (const otherSource of otherSources) {
      otherSource.pipe(combinedDataSource, cancellationToken);
    }
    return combinedDataSource;
  }
  /**
   * Returns a promise that resolves when the next update occurs
   * @param cancellationToken
   */
  awaitNextUpdate(cancellationToken) {
    return new Promise((resolve) => {
      this.listenOnce((value) => resolve(value), cancellationToken);
    });
  }
  /**
   * Remove all listeners
   */
  cancelAll() {
    this.updateEvent.cancelAll();
  }
};
var ArrayDataSource = class _ArrayDataSource {
  constructor(initialData, name = "RootArrayDataSource") {
    __publicField(this, "data");
    __publicField(this, "updateEvent");
    __publicField(this, "lengthSource");
    __publicField(this, "name");
    __publicField(this, "onItemsAdded", new EventEmitter());
    __publicField(this, "onItemsRemoved", new EventEmitter());
    this.name = name;
    if (initialData) {
      this.data = initialData.slice();
    } else {
      this.data = [];
    }
    this.lengthSource = new DataSource(this.data.length, this.name + ".length");
    this.updateEvent = new EventEmitter();
  }
  *[Symbol.iterator]() {
    yield* this.getData();
    return;
  }
  /**
   * Returns a datasource that always contains the item that is currently at the specified index
   * @param index
   * @param cancellationToken
   * @returns
   */
  pickAt(index, cancellationToken) {
    if (index < 0) {
      throw new Error("Index out of bounds");
    }
    const result = new DataSource(this.data[index], this.name + `[${index}]`);
    this.listen((change) => {
      if (result.value !== change.newState[index]) {
        result.update(change.newState[index]);
      }
    }, cancellationToken);
    return result;
  }
  toSetDataSource(cancellationToken) {
    const result = new SetDataSource();
    this.listenAndRepeat((change) => {
      switch (change.operation) {
        case "add":
          for (const item of change.items) {
            result.add(item);
          }
          break;
        case "remove":
          for (const item of change.items) {
            if (!this.includes(item)) {
              result.delete(item);
            }
          }
          break;
        case "replace":
          if (!this.includes(change.target)) {
            result.delete(change.target);
          }
          for (const item of change.items) {
            result.add(item);
          }
          break;
        case "merge":
          result.clear();
          for (const item of change.items) {
            result.add(item);
          }
          break;
      }
    }, cancellationToken);
    return result;
  }
  toString() {
    return this.data.toString();
  }
  static fromFetchText(response, config = { itemSeperatorSequence: "\n" }) {
    const decoder = new TextDecoder("utf-8");
    const stream = new _ArrayDataSource();
    const { onComplete, itemSeperatorSequence } = config;
    let buffer = "";
    const readerStream = response.body.getReader();
    function read(reader) {
      reader.read().then(({ done, value }) => {
        if (!done) {
          const data = (buffer + decoder.decode(value)).split(itemSeperatorSequence);
          buffer = data.splice(data.length - 1, 1)[0];
          stream.appendArray(data);
          read(reader);
        } else {
          if (buffer.length) {
            stream.push(buffer);
          }
          onComplete == null ? void 0 : onComplete();
        }
      });
    }
    read(readerStream);
    return stream;
  }
  static fromFetchJSON(response, config = {
    itemSeperatorSequence: "\n"
  }) {
    const decoder = new TextDecoder("utf-8");
    const stream = new _ArrayDataSource();
    const { onParseError, onComplete, itemSeperatorSequence = "\n" } = config;
    let buffer = "";
    const readerStream = response.body.getReader();
    function read(reader) {
      reader.read().then(({ done, value }) => {
        if (!done) {
          const data = (buffer + decoder.decode(value)).split(itemSeperatorSequence);
          buffer = data.splice(data.length - 1, 1)[0];
          for (const item of data) {
            parseAndPush(item);
          }
          read(reader);
        } else {
          if (buffer.length) {
            parseAndPush(buffer);
          }
          onComplete == null ? void 0 : onComplete();
        }
      });
    }
    read(readerStream);
    function parseAndPush(item) {
      try {
        stream.push(JSON.parse(item));
      } catch (e) {
        try {
          stream.push(onParseError(item));
        } catch (e2) {
        }
      }
    }
    return stream;
  }
  /**
   * Connects to an aurum-server exposed array datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
   * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated
   * @param  {AurumServerInfo} aurumServerInfo
   * @returns DataSource
   */
  static fromRemoteSource(aurumServerInfo, cancellation) {
    const result = new _ArrayDataSource();
    syncArrayDataSource(result, aurumServerInfo, cancellation);
    return result;
  }
  static fromMultipleSources(sources, cancellationToken) {
    const boundaries = [0];
    const result = new _ArrayDataSource(void 0, `ArrayDataSource of (${sources.reduce((p, c) => p + (c instanceof _ArrayDataSource ? c.name + " " : ""), "")})`);
    for (let i = 0; i < sources.length; i++) {
      const item = sources[i];
      if (Array.isArray(item)) {
        result.appendArray(item);
      } else if (item instanceof DataSource || item instanceof DuplexDataSource) {
        let index = i;
        item.transform(dsDiff(), dsTap(({ newValue, oldValue }) => {
          let sizeDiff = 0;
          let oldSize = 0;
          let newSize = 0;
          if (Array.isArray(oldValue)) {
            oldSize = oldValue.length;
            sizeDiff -= oldValue.length;
          } else if (oldValue !== void 0) {
            oldSize = 1;
            sizeDiff--;
          }
          if (Array.isArray(newValue)) {
            sizeDiff += newValue.length;
            newSize = newValue.length;
          } else if (newValue !== void 0) {
            sizeDiff++;
            newSize = 1;
          }
          if (Array.isArray(newValue)) {
            for (let i2 = 0; i2 < newValue.length; i2++) {
              if (i2 < oldSize) {
                result.set(boundaries[index] + i2, newValue[i2]);
              } else {
                result.insertAt(boundaries[index] + i2, newValue[i2]);
              }
            }
          } else if (newValue !== void 0) {
            if (newSize <= oldSize) {
              result.set(boundaries[index], newValue);
            } else {
              result.insertAt(boundaries[index], newValue);
            }
          }
          for (let i2 = 0; i2 < oldSize - newSize; i2++) {
            result.removeAt(boundaries[index] + newSize);
          }
          for (let i2 = index + 1; i2 < boundaries.length; i2++) {
            boundaries[i2] += sizeDiff;
          }
        }), cancellationToken);
      } else {
        result.appendArray(sources[i].data ?? []);
        let index = i;
        sources[i].listen((change) => {
          switch (change.operationDetailed) {
            case "append":
            case "prepend":
            case "insert":
              result.insertAt(change.index + boundaries[index], ...change.items);
              for (let i2 = index + 1; i2 < boundaries.length; i2++) {
                boundaries[i2] += change.count;
              }
              break;
            case "remove":
            case "removeLeft":
            case "removeRight":
            case "clear":
              result.removeRange(change.index + boundaries[index], change.index + boundaries[index] + change.count);
              for (let i2 = index + 1; i2 < boundaries.length; i2++) {
                boundaries[i2] -= change.count;
              }
              break;
            case "merge":
              const lengthDiff = change.newState.length + change.previousState.length;
              result.removeRange(change.index + boundaries[index], change.index + boundaries[index] + change.previousState.length);
              result.insertAt(change.index + boundaries[index], ...change.newState);
              if (lengthDiff != 0) {
                for (let i2 = index + 1; i2 < boundaries.length; i2++) {
                  boundaries[i2] += lengthDiff;
                }
              }
              break;
            case "replace":
              result.set(change.index + boundaries[index], change.items[0]);
              break;
            case "swap":
              result.swap(change.index + boundaries[index], change.index2 + boundaries[index]);
              break;
          }
        }, cancellationToken);
      }
      boundaries.push(result.length.value);
    }
    return result;
  }
  /**
   * Creates a new array data source where the type T is no longer wrapped by a DataSource however the values of these data sources are observed on the parent
   * array data source and changes are forwarded to the new array data source through array mutations. This makes it possible to use view methods such as map and filter
   * on the raw data instead of on data sources to cover highly dynamic use cases
   */
  static DynamicArrayDataSourceToArrayDataSource(arrayDataSource, cancellation) {
    const result = new _ArrayDataSource();
    const session = /* @__PURE__ */ new WeakMap();
    arrayDataSource.listenAndRepeat(({ operationDetailed, index, index2, count, items, previousState, newState, target }) => {
      switch (operationDetailed) {
        case "append":
          for (const item of items) {
            listenToItem(item);
          }
          result.appendArray(items.map((item) => getValueOf(item)));
          break;
        case "prepend":
          for (const item of items) {
            listenToItem(item);
          }
          result.unshift(...items.map((item) => getValueOf(item)));
          break;
        case "merge":
          for (const item of previousState) {
            stopLitenToItem(item);
          }
          for (const item of newState) {
            listenToItem(item);
          }
          result.merge(newState.map((i) => getValueOf(i)));
          break;
        case "insert":
          for (const item of items) {
            listenToItem(item);
          }
          result.insertAt(index, ...items.map((item) => getValueOf(item)));
          break;
        case "clear":
          for (const item of previousState) {
            stopLitenToItem(item);
          }
          result.clear();
          break;
        case "remove":
          for (const item of items) {
            stopLitenToItem(item);
          }
          result.removeRange(index, index + count);
          break;
        case "removeLeft":
          for (const item of items) {
            stopLitenToItem(item);
          }
          result.removeLeft(count);
          break;
        case "removeRight":
          for (const item of items) {
            stopLitenToItem(item);
          }
          result.removeRight(count);
          break;
        case "replace":
          stopLitenToItem(target);
          listenToItem(items[0]);
          result.set(index, getValueOf(items[0]));
          break;
        case "swap":
          result.swap(index, index2);
          break;
      }
    }, cancellation);
    return result;
    function listenToItem(item) {
      if (typeof item !== "object" || !("listen" in item)) {
        return;
      }
      session.set(item, new CancellationToken());
      cancellation.chain(session.get(item));
      item.listen((value) => {
        result.set(arrayDataSource.indexOf(item), value);
      }, session.get(item));
    }
    function stopLitenToItem(item) {
      if (session.has(item)) {
        session.get(item).cancel();
        session.delete(item);
      }
    }
  }
  static fromAsyncIterator(iterator, cancellation) {
    const result = new _ArrayDataSource();
    (async () => {
      for await (const item of iterator) {
        if (cancellation == null ? void 0 : cancellation.isCancelled) {
          return;
        }
        result.push(item);
      }
    })();
    return result;
  }
  static fromPromiseArray(promises, cancellation) {
    const result = new _ArrayDataSource();
    (async () => {
      for await (const promise of promiseIterator(promises, cancellation)) {
        if (cancellation == null ? void 0 : cancellation.isCancelled) {
          return;
        }
        result.push(promise);
      }
    })();
    return result;
  }
  toAsyncIterator(cancellation) {
    return this.updateEvent.toAsyncIterator(cancellation);
  }
  static toArrayDataSource(value) {
    if (value instanceof _ArrayDataSource) {
      return value;
    } else {
      return new _ArrayDataSource(value);
    }
  }
  pipe(target, cancellation) {
    this.listenAndRepeat((c) => target.applyCollectionChange(c), cancellation);
  }
  /**
   * Remove all listeners
   */
  cancelAll() {
    this.onItemsAdded.cancelAll();
    this.onItemsRemoved.cancelAll();
    this.updateEvent.cancelAll();
  }
  /**
   * Same as listen but will immediately call the callback with an append of all existing elements first
   */
  listenAndRepeat(callback, cancellationToken) {
    if (this.data.length) {
      callback({
        operation: "add",
        operationDetailed: "append",
        index: 0,
        items: this.data,
        newState: this.data,
        count: this.data.length
      });
    }
    return this.listen(callback, cancellationToken);
  }
  /**
   * Sends a reset signal followed by an append with all items signal. This will force all the views of this source the synchronize can be useful in case your views rely on non pure transformation functions.
   */
  repeatCurrentState() {
    this.update({
      operation: "remove",
      operationDetailed: "clear",
      count: this.data.length,
      index: 0,
      items: this.data,
      newState: []
    });
    this.update({
      operation: "add",
      operationDetailed: "append",
      index: 0,
      items: this.data,
      newState: this.data,
      count: this.data.length
    });
  }
  listen(callback, cancellationToken) {
    return this.updateEvent.subscribe(callback, cancellationToken).cancel;
  }
  listenOnce(callback, cancellationToken) {
    return this.updateEvent.subscribeOnce(callback, cancellationToken).cancel;
  }
  /**
   * Applies the changes described in the colleciton change to the array. Useful for synchronizing array data sources over the network or workers by serializing the changes and sending them over
   * @param collectionChange
   */
  applyCollectionChange(collectionChange) {
    switch (collectionChange.operationDetailed) {
      case "append":
        this.appendArray(collectionChange.items);
        break;
      case "clear":
        this.clear();
        break;
      case "insert":
        this.insertAt(collectionChange.index, ...collectionChange.items);
        break;
      case "merge":
        this.merge(collectionChange.items);
        break;
      case "prepend":
        this.unshift(...collectionChange.items);
        break;
      case "remove":
        this.removeRange(collectionChange.index, collectionChange.index + collectionChange.count);
        break;
      case "removeLeft":
        this.removeLeft(collectionChange.count);
        break;
      case "removeRight":
        this.removeRight(collectionChange.count);
        break;
      case "replace":
        this.set(collectionChange.index, collectionChange.items[0]);
        break;
      case "swap":
        this.swap(collectionChange.index, collectionChange.index2);
        break;
    }
  }
  /**
   * Returns a promise that resolves when the next update occurs
   * @param cancellationToken
   */
  awaitNextUpdate(cancellationToken) {
    return new Promise((resolve) => {
      this.listenOnce((value) => resolve(value), cancellationToken);
    });
  }
  get length() {
    return this.lengthSource;
  }
  getData() {
    return this.data;
  }
  get(index) {
    return this.data[index];
  }
  set(index, item) {
    const old = this.data[index];
    if (old === item) {
      return;
    }
    this.data[index] = item;
    this.update({ operation: "replace", operationDetailed: "replace", target: old, count: 1, index, items: [item], newState: this.data });
    this.onItemsRemoved.fire([old]);
    this.onItemsAdded.fire([item]);
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
  }
  indexOf(item) {
    return this.data.indexOf(item);
  }
  find(predicate, thisArg) {
    return this.data.find(predicate, thisArg);
  }
  findIndex(predicate, thisArg) {
    return this.data.findIndex(predicate, thisArg);
  }
  lastIndexOf(item) {
    return this.data.lastIndexOf(item);
  }
  includes(item) {
    return this.data.includes(item);
  }
  replace(item, newItem) {
    const index = this.indexOf(item);
    if (index !== -1) {
      this.set(index, newItem);
    }
  }
  swap(indexA, indexB) {
    if (indexA === indexB) {
      return;
    }
    const itemA = this.data[indexA];
    const itemB = this.data[indexB];
    this.data[indexB] = itemA;
    this.data[indexA] = itemB;
    this.update({ operation: "swap", operationDetailed: "swap", index: indexA, index2: indexB, items: [itemA, itemB], newState: this.data });
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
  }
  swapItems(itemA, itemB) {
    if (itemA === itemB) {
      return;
    }
    const indexA = this.data.indexOf(itemA);
    const indexB = this.data.indexOf(itemB);
    if (indexA !== -1 && indexB !== -1) {
      this.data[indexB] = itemA;
      this.data[indexA] = itemB;
    }
    this.update({ operation: "swap", operationDetailed: "swap", index: indexA, index2: indexB, items: [itemA, itemB], newState: this.data });
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
  }
  appendArray(items) {
    if (!items || items.length === 0) {
      return;
    }
    if (items.length <= 65e3) {
      this.data.push.apply(this.data, items);
    } else {
      console.warn("Appending over 65000 items in one go can lead to performance issues. Consider streaming your changes progressively");
      this.data = this.data.concat(items);
    }
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({
      operation: "add",
      operationDetailed: "append",
      count: items.length,
      index: this.data.length - items.length,
      items,
      newState: this.data
    });
    this.onItemsAdded.fire(items);
  }
  splice(index, deleteCount, ...insertion) {
    let removed = [];
    if (deleteCount > 0) {
      removed = this.removeAt(index, deleteCount);
    }
    if (insertion && insertion.length > 0) {
      this.insertAt(index, ...insertion);
    }
    return removed;
  }
  insertAt(index, ...items) {
    if (items.length === 0) {
      return;
    }
    this.data.splice(index, 0, ...items);
    this.update({
      operation: "add",
      operationDetailed: "insert",
      count: items.length,
      index,
      items,
      newState: this.data
    });
    this.onItemsAdded.fire(items);
    this.lengthSource.update(this.data.length);
  }
  push(...items) {
    this.appendArray(items);
  }
  unshift(...items) {
    this.data.unshift(...items);
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({ operation: "add", operationDetailed: "prepend", count: items.length, items, index: 0, newState: this.data });
    this.onItemsAdded.fire(items);
  }
  pop() {
    const item = this.data.pop();
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({
      operation: "remove",
      operationDetailed: "removeRight",
      count: 1,
      index: this.data.length,
      items: [item],
      newState: this.data
    });
    this.onItemsRemoved.fire([item]);
    return item;
  }
  merge(newData) {
    if (newData.length === 0) {
      return this.clear();
    }
    if (newData === this.data) {
      return;
    }
    if (newData.every((v, i) => v === this.data[i])) {
      if (this.data.length > newData.length) {
        this.removeRight(this.data.length - newData.length);
        return;
      } else {
        return;
      }
    }
    const old = this.data;
    this.data = newData.slice();
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({
      operation: "merge",
      operationDetailed: "merge",
      previousState: old,
      index: 0,
      items: this.data,
      newState: this.data
    });
    this.onItemsRemoved.fire(old);
    this.onItemsAdded.fire(this.data);
  }
  removeRight(count) {
    const length = this.data.length;
    const result = this.data.splice(length - count, count);
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({ operation: "remove", operationDetailed: "removeRight", count, index: length - count, items: result, newState: this.data });
    this.onItemsRemoved.fire(result);
    return result;
  }
  removeLeft(count) {
    const removed = this.data.splice(0, count);
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({ operation: "remove", operationDetailed: "removeLeft", count, index: 0, items: removed, newState: this.data });
    this.onItemsRemoved.fire(removed);
  }
  removeWhere(reject) {
    const removed = this.data.filter(reject);
    for (const item of removed) {
      this.remove(item);
    }
  }
  removeAt(index, count = 1) {
    const removed = this.data.splice(index, count);
    this.update({ operation: "remove", operationDetailed: "remove", count: removed.length, index, items: removed, newState: this.data });
    this.onItemsRemoved.fire(removed);
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    return removed;
  }
  removeRange(start, end) {
    const removed = this.data.splice(start, end - start);
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({ operation: "remove", operationDetailed: "remove", count: removed.length, index: start, items: removed, newState: this.data });
    this.onItemsRemoved.fire(removed);
    return removed;
  }
  remove(item) {
    const index = this.data.indexOf(item);
    if (index !== -1) {
      return this.removeAt(index)[0];
    } else {
      return void 0;
    }
  }
  clear() {
    if (this.data.length === 0) {
      return;
    }
    const items = this.data;
    this.data = [];
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({
      operation: "remove",
      operationDetailed: "clear",
      count: items.length,
      index: 0,
      items,
      previousState: items,
      newState: this.data
    });
    this.onItemsRemoved.fire(items);
  }
  some(cb) {
    return this.data.some(cb);
  }
  every(cb) {
    return this.data.every(cb);
  }
  shift() {
    const item = this.data.shift();
    if (this.lengthSource.value !== this.data.length) {
      this.lengthSource.update(this.data.length);
    }
    this.update({ operation: "remove", operationDetailed: "removeLeft", items: [item], count: 1, index: 0, newState: this.data });
    this.onItemsRemoved.fire([item]);
    return item;
  }
  toArray() {
    return this.data.slice();
  }
  flat(cancellationToken, config) {
    const view = new FlattenedArrayView(this, 1, cancellationToken, this.name + ".flat()", config);
    return view;
  }
  reduce(reducer, initial, cancellationToken) {
    const result = new DataSource(initial);
    this.listenAndRepeat((change) => {
      switch (change.operationDetailed) {
        case "append":
          let newVal = result.value;
          for (const item of change.items) {
            newVal = reducer(newVal, item);
          }
          result.update(newVal);
          break;
        case "clear":
          result.update(initial);
          break;
        case "removeRight":
        case "removeLeft":
        case "prepend":
        case "insert":
        case "merge":
        case "replace":
        case "swap":
        case "remove":
          let newVal2 = initial;
          for (const item of change.newState) {
            newVal2 = reducer(newVal2, item);
          }
          result.update(newVal2);
          break;
      }
    }, cancellationToken);
    return result;
  }
  reverse(cancellationToken, config) {
    const view = new ReversedArrayView(this, cancellationToken, this.name + ".reverse()", config);
    return view;
  }
  sort(comparator = (a, b) => {
    if (a == void 0) {
      return 1;
    }
    if (b == void 0) {
      return -1;
    }
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    } else {
      return a.toString().localeCompare(b.toString());
    }
  }, dependencies = [], cancellationToken, config) {
    const view = new SortedArrayView(this, comparator, cancellationToken, this.name + ".sort()", config);
    dependencies.forEach((dep) => {
      dep.listen(() => view.refresh());
    }, cancellationToken);
    return view;
  }
  slice(start, end, cancellationToken, config) {
    if (typeof start === "number") {
      start = new DataSource(start);
    }
    if (typeof end === "number") {
      end = new DataSource(end);
    }
    if (end === void 0) {
      end = this.length;
    }
    return new SlicedArrayView(this, start, end, cancellationToken, this.name + ".slice()", config);
  }
  map(mapper, dependencies = [], cancellationToken, config) {
    const view = new MappedArrayView(this, mapper, cancellationToken, this.name + ".map()", config);
    dependencies.forEach((dep) => {
      dep.listen(() => view.refresh());
    }, cancellationToken);
    return view;
  }
  unique(cancellationToken, config) {
    return new UniqueArrayView(this, cancellationToken, this.name + ".unique()", config);
  }
  indexBy(key, cancellationToken, config) {
    const view = new MapDataSource();
    this.listenAndRepeat((change) => {
      var _a;
      if (!((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed))) {
        switch (change.operation) {
          case "add":
            for (const item of change.items) {
              view.set(item[key], item);
            }
            break;
          case "remove":
            for (const item of change.items) {
              view.delete(item[key]);
            }
            break;
          case "replace":
            view.delete(change.target[key]);
            view.set(change.items[0][key], change.items[0]);
            break;
          case "merge":
            const oldKeys = new Set(view.keys());
            const newKeys = new Set(change.items.map((item) => item[key]));
            for (const oldKey of oldKeys) {
              if (!newKeys.has(oldKey)) {
                view.delete(oldKey);
              }
            }
            for (const newKey of newKeys) {
              if (!oldKeys.has(newKey)) {
                view.set(newKey, change.items.find((item) => item[key] === newKey));
              }
            }
            break;
        }
      }
    }, cancellationToken);
    return view;
  }
  indexByProvider(provider, cancellationToken, config) {
    const view = new MapDataSource();
    this.listenAndRepeat((change) => {
      var _a;
      if (!((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed))) {
        switch (change.operation) {
          case "add":
            for (const item of change.items) {
              view.set(provider(item), item);
            }
            break;
          case "remove":
            for (const item of change.items) {
              view.delete(provider(item));
            }
            break;
          case "replace":
            view.delete(provider(change.target));
            view.set(provider(change.items[0]), change.items[0]);
            break;
          case "merge":
            const oldKeys = new Set(view.keys());
            const newKeys = new Set(change.items.map((item) => provider(item)));
            for (const oldKey of oldKeys) {
              if (!newKeys.has(oldKey)) {
                view.delete(oldKey);
              }
            }
            for (const newKey of newKeys) {
              if (!oldKeys.has(newKey)) {
                view.set(newKey, change.items.find((item) => provider(item) === newKey));
              }
            }
            break;
        }
      }
    }, cancellationToken);
    return view;
  }
  groupBy(key, cancellationToken, config) {
    const view = new MapDataSource();
    function handleRemove(item) {
      const list = view.get(item[key]);
      list.splice(list.indexOf(item), 1);
      if (list.length.value === 0) {
        view.delete(item[key]);
      }
    }
    function handleAdd(item) {
      if (!view.has(item[key])) {
        view.set(item[key], new _ArrayDataSource());
      }
      view.get(item[key]).push(item);
    }
    this.listenAndRepeat((change) => {
      var _a;
      if (!((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed))) {
        switch (change.operation) {
          case "add":
            for (const item of change.items) {
              handleAdd(item);
            }
            break;
          case "remove":
            for (const item of change.items) {
              handleRemove(item);
            }
            break;
          case "replace":
            handleRemove(change.target);
            handleAdd(change.items[0]);
            break;
          case "merge":
            const diff = change.previousState.filter((item) => !change.newState.includes(item));
            for (const item of diff) {
              if (view.has(item[key]) && view.get(item[key]).includes(item)) {
                handleRemove(item);
              }
            }
            for (const item of change.items) {
              if (!view.has(item[key])) {
                handleAdd(item);
              } else {
                if (!view.get(item[key]).includes(item)) {
                  handleAdd(item);
                }
              }
            }
            break;
        }
      }
    }, cancellationToken);
    return view;
  }
  groupByProvider(provider, cancellationToken, config) {
    const view = new MapDataSource();
    function handleRemove(item) {
      const list = view.get(provider(item));
      list.splice(list.indexOf(item), 1);
      if (list.length.value === 0) {
        view.delete(provider(item));
      }
    }
    function handleAdd(item) {
      if (!view.has(provider(item))) {
        view.set(provider(item), new _ArrayDataSource());
      }
      view.get(provider(item)).push(item);
    }
    this.listenAndRepeat((change) => {
      var _a;
      if (!((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed))) {
        switch (change.operation) {
          case "add":
            for (const item of change.items) {
              handleAdd(item);
            }
            break;
          case "remove":
            for (const item of change.items) {
              handleRemove(item);
            }
            break;
          case "replace":
            handleRemove(change.target);
            handleAdd(change.items[0]);
            break;
          case "merge":
            const diff = change.previousState.filter((item) => !change.newState.includes(item));
            for (const item of diff) {
              if (view.has(provider(item)) && view.get(provider(item)).includes(item)) {
                handleRemove(item);
              }
            }
            for (const item of change.items) {
              if (!view.has(provider(item))) {
                handleAdd(item);
              } else {
                if (!view.get(provider(item)).includes(item)) {
                  handleAdd(item);
                }
              }
            }
            break;
        }
      }
    }, cancellationToken);
    return view;
  }
  groupByMultiProvider(provider, cancellationToken, config) {
    const view = new MapDataSource();
    function handleRemove(item) {
      for (const i of provider(item)) {
        const list = view.get(i);
        list.splice(list.indexOf(item), 1);
        if (list.length.value === 0) {
          view.delete(i);
        }
      }
    }
    function handleAdd(item) {
      for (const i of provider(item)) {
        if (!view.has(i)) {
          view.set(i, new _ArrayDataSource());
        }
        view.get(i).push(item);
      }
    }
    this.listenAndRepeat((change) => {
      var _a;
      if (!((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed))) {
        switch (change.operation) {
          case "add":
            for (const item of change.items) {
              handleAdd(item);
            }
            break;
          case "remove":
            for (const item of change.items) {
              handleRemove(item);
            }
            break;
          case "replace":
            handleRemove(change.target);
            handleAdd(change.items[0]);
            break;
          case "merge":
            const diff = change.previousState.filter((item) => !change.newState.includes(item));
            for (const item of diff) {
              for (const i of provider(item)) {
                if (view.has(i) && view.get(i).includes(item)) {
                  handleRemove(item);
                }
              }
            }
            for (const item of change.items) {
              for (const i of provider(item)) {
                if (!view.has(i)) {
                  handleAdd(item);
                } else {
                  if (!view.get(i).includes(item)) {
                    handleAdd(item);
                  }
                }
              }
            }
            break;
        }
      }
    }, cancellationToken);
    return view;
  }
  filter(callback, dependencies = [], cancellationToken, config) {
    const view = new FilteredArrayView(this, callback, cancellationToken, this.name + ".filter()", config);
    dependencies.forEach((dep) => {
      dep.listen(() => view.refresh(), cancellationToken);
    });
    return view;
  }
  limit(count, cancellationToken) {
    const view = new LimitedArrayView(this, count, cancellationToken, this.name + ".limit()");
    return view;
  }
  forEach(callbackfn) {
    return this.data.forEach(callbackfn);
  }
  update(change) {
    this.updateEvent.fire(change);
  }
};
var FlattenedArrayView = class extends ArrayDataSource {
  constructor(parent, depth, cancellationToken = new CancellationToken(), name, config) {
    super([], name);
    __publicField(this, "parent");
    __publicField(this, "depth");
    __publicField(this, "sessionToken");
    this.depth = depth;
    this.parent = parent;
    this.refresh();
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      switch (change.operationDetailed) {
        case "removeLeft":
        case "removeRight":
        case "remove":
        case "swap":
        case "replace":
        case "insert":
        case "merge":
        case "prepend":
        case "append":
          this.refresh();
          break;
        case "clear":
          this.clear();
          break;
      }
    }, cancellationToken);
  }
  refresh() {
    if (this.sessionToken) {
      this.sessionToken.cancel();
      this.sessionToken = void 0;
    }
    const data = this.parent.getData();
    if (data.length > 0) {
      if (data[0] instanceof ArrayDataSource) {
        this.sessionToken = new CancellationToken();
        const combination = ArrayDataSource.fromMultipleSources(data);
        combination.listen((change) => {
          this.applyCollectionChange(change);
        }, this.sessionToken);
        this.merge(combination.getData());
      } else {
        this.merge(data.flat(this.depth));
      }
    }
  }
};
var MappedArrayView = class extends ArrayDataSource {
  constructor(parent, mapper, cancellationToken = new CancellationToken(), name, config) {
    const initial = parent.getData().map(mapper);
    super(initial, name);
    __publicField(this, "parent");
    __publicField(this, "mapper");
    this.parent = parent;
    this.mapper = mapper;
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      switch (change.operationDetailed) {
        case "removeLeft":
          this.removeLeft(change.count);
          break;
        case "removeRight":
          this.removeRight(change.count);
          break;
        case "remove":
          for (let i = 0; i < change.items.length; i++) {
            this.remove(this.data[change.index + i]);
          }
          break;
        case "clear":
          this.clear();
          break;
        case "prepend":
          this.unshift(...change.items.map(this.mapper));
          break;
        case "append":
          this.appendArray(change.items.map(this.mapper));
          break;
        case "insert":
          this.insertAt(change.index, ...change.items.map(this.mapper));
          break;
        case "swap":
          this.swap(change.index, change.index2);
          break;
        case "replace":
          this.set(change.index, this.mapper(change.items[0]));
          break;
        case "merge":
          const old = this.data.slice();
          const source = change.previousState.slice();
          for (let i = 0; i < change.newState.length; i++) {
            if (this.data.length <= i) {
              this.data.push(this.mapper(change.newState[i]));
              source.push(change.newState[i]);
            } else if (source[i] !== change.newState[i]) {
              const index = source.indexOf(change.newState[i], i);
              if (index !== -1) {
                const a = this.data[i];
                const b = this.data[index];
                this.data[i] = b;
                this.data[index] = a;
                const c = source[i];
                const d = source[index];
                source[i] = d;
                source[index] = c;
              } else {
                this.data.splice(i, 0, this.mapper(change.newState[i]));
                source.splice(i, 0, change.newState[i]);
              }
            }
          }
          if (this.data.length > change.newState.length) {
            this.data.length = change.newState.length;
          }
          this.length.update(this.data.length);
          this.update({
            operation: "merge",
            operationDetailed: "merge",
            previousState: old,
            index: 0,
            items: this.data,
            newState: this.data
          });
          this.onItemsRemoved.fire(old);
          this.onItemsAdded.fire(this.data);
          break;
      }
    }, cancellationToken);
  }
  refresh() {
    this.merge(this.parent.getData().map(this.mapper));
  }
};
var ReversedArrayView = class extends ArrayDataSource {
  constructor(parent, cancellationToken = new CancellationToken(), name, config) {
    const initial = parent.getData().slice().reverse();
    super(initial, name);
    __publicField(this, "parent");
    this.parent = parent;
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      switch (change.operationDetailed) {
        case "removeLeft":
          this.removeRight(change.count);
          break;
        case "removeRight":
          this.removeLeft(change.count);
          break;
        case "remove":
          for (const item of change.items) {
            this.remove(item);
          }
          break;
        case "clear":
          this.clear();
          break;
        case "prepend":
          this.appendArray(change.items.reverse());
          break;
        case "append":
          this.unshift(...change.items.reverse());
          break;
        case "insert":
          this.merge(change.newState.slice().reverse());
          break;
        case "merge":
          this.merge(change.items.slice().reverse());
          break;
        case "swap":
          this.merge(change.newState.slice().reverse());
          break;
        case "replace":
          this.merge(change.newState.slice().reverse());
          break;
      }
    }, cancellationToken);
  }
  refresh() {
    this.merge(this.parent.getData().slice().reverse());
  }
};
var SlicedArrayView = class extends ArrayDataSource {
  constructor(parent, start, end, cancellationToken = new CancellationToken(), name, config) {
    const initial = parent.getData().slice(start.value, end.value);
    super(initial, name);
    start.listen(() => this.merge(parent.getData().slice(start.value, end.value)), cancellationToken);
    end.listen(() => this.merge(parent.getData().slice(start.value, end.value)), cancellationToken);
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      switch (change.operationDetailed) {
        case "removeLeft":
        case "removeRight":
        case "remove":
        case "append":
        case "prepend":
        case "insert":
        case "swap":
        case "replace":
        case "merge":
          this.merge(parent.getData().slice(start.value, end.value));
          break;
        case "clear":
          this.clear();
          break;
      }
    }, cancellationToken);
  }
};
var UniqueArrayView = class extends ArrayDataSource {
  constructor(parent, cancellationToken = new CancellationToken(), name, config) {
    const initial = Array.from(new Set(parent.getData()));
    super(initial, name);
    let filteredItems;
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      switch (change.operationDetailed) {
        case "removeLeft":
        case "removeRight":
        case "remove":
          for (const item of change.items) {
            if (!change.newState.includes(item)) {
              this.remove(item);
            }
          }
          break;
        case "clear":
          this.clear();
          break;
        case "prepend":
          filteredItems = change.items.filter((e) => !this.data.includes(e));
          this.unshift(...filteredItems);
          break;
        case "append":
          filteredItems = change.items.filter((e) => !this.data.includes(e));
          this.appendArray(filteredItems);
          break;
        case "insert":
          filteredItems = change.items.filter((e) => !this.data.includes(e));
          this.insertAt(change.index, ...filteredItems);
          break;
        case "merge":
          this.merge(Array.from(new Set(parent.getData())));
          break;
        case "swap":
          this.swap(change.index, change.index2);
          break;
        case "replace":
          if (this.data.includes(change.items[0])) {
            this.remove(change.target);
          } else {
            this.set(change.index, change.items[0]);
          }
          break;
      }
    }, cancellationToken);
  }
};
var SortedArrayView = class extends ArrayDataSource {
  constructor(parent, comparator, cancellationToken = new CancellationToken(), name, config) {
    const initial = parent.getData().slice().sort(comparator);
    super(initial, name);
    __publicField(this, "comparator");
    __publicField(this, "parent");
    this.parent = parent;
    this.comparator = comparator;
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      switch (change.operationDetailed) {
        case "removeLeft":
        case "removeRight":
        case "remove":
          for (const item of change.items) {
            this.remove(item);
          }
          break;
        case "clear":
          this.clear();
          break;
        case "prepend":
          this.unshift(...change.items);
          this.data.sort(this.comparator);
          break;
        case "append":
          this.appendSorted(change.items);
          break;
        case "insert":
          this.appendSorted(change.items);
          break;
        case "merge":
          this.merge(change.items.slice().sort(this.comparator));
          break;
        case "swap":
          break;
        case "replace":
          this.remove(change.target);
          this.appendSorted(change.items);
          break;
      }
    }, cancellationToken);
  }
  appendSorted(items) {
    if (items.length === 1 && this.data.length === 0) {
      this.push(items[0]);
    } else {
      this.merge(this.data.concat(items).sort(this.comparator));
    }
  }
  refresh() {
    this.merge(this.parent.getData().slice().sort(this.comparator));
  }
};
var FilteredArrayView = class extends ArrayDataSource {
  constructor(parent, filter, cancellationToken = new CancellationToken(), name, config) {
    if (Array.isArray(parent)) {
      parent = new ArrayDataSource(parent);
    }
    filter = filter ?? (() => true);
    const initial = parent.data.filter(filter);
    super(initial, name);
    __publicField(this, "viewFilter");
    __publicField(this, "parent");
    this.parent = parent;
    this.viewFilter = filter;
    parent.listen((change) => {
      var _a;
      if ((_a = config == null ? void 0 : config.ignoredOperations) == null ? void 0 : _a.includes(change.operationDetailed)) {
        return;
      }
      let filteredItems;
      switch (change.operationDetailed) {
        case "clear":
          this.clear();
          break;
        case "removeLeft":
        case "removeRight":
        case "remove":
          for (const item of change.items) {
            this.remove(item);
          }
          break;
        case "prepend":
          filteredItems = change.items.filter(this.viewFilter);
          this.unshift(...filteredItems);
          break;
        case "append":
          filteredItems = change.items.filter(this.viewFilter);
          this.appendArray(filteredItems);
          break;
        case "insert":
          filteredItems = change.items.filter(this.viewFilter);
          this.insertAt(change.index, ...filteredItems);
          break;
        case "merge":
          this.merge(change.items.filter(this.viewFilter));
          break;
        case "swap":
          const indexA = this.data.indexOf(change.items[0]);
          const indexB = this.data.indexOf(change.items[1]);
          if (indexA !== -1 && indexB !== -1) {
            this.swap(indexA, indexB);
          }
          break;
        case "replace":
          const index = this.data.indexOf(change.target);
          if (index !== -1) {
            const acceptNew = this.viewFilter(change.items[0]);
            if (acceptNew) {
              this.set(index, change.items[0]);
            } else {
              this.remove(change.target);
            }
          }
          break;
      }
    }, cancellationToken);
  }
  /**
   * Replaces the filter function
   * @param filter
   * @returns returns new size of array view after applying filter
   */
  updateFilter(filter) {
    if (this.viewFilter === filter) {
      return this.data.length;
    }
    this.viewFilter = filter;
    this.refresh();
    return this.data.length;
  }
  /**
   * Recalculates the filter. Only needed if your filter function isn't pure and you know the result would be different if run again compared to before
   */
  refresh() {
    this.merge(this.parent.data.filter(this.viewFilter));
  }
};
var LimitedArrayView = class extends ArrayDataSource {
  constructor(parent, sizeLimit, cancellationToken = new CancellationToken(), name) {
    if (Array.isArray(parent)) {
      parent = new ArrayDataSource(parent);
    }
    const initial = parent.data.slice(0, sizeLimit);
    super(initial, name);
    parent.listen((change) => {
      switch (change.operationDetailed) {
        case "clear":
          this.clear();
          break;
        case "removeLeft":
        case "removeRight":
        case "remove":
          if (change.index < sizeLimit) {
            this.removeRange(change.index, change.index + Math.min(sizeLimit, change.count));
            if (this.data.length < sizeLimit) {
              this.appendArray(change.newState.slice(this.data.length, sizeLimit));
            }
          }
          break;
        case "prepend":
          this.removeRight(Math.min(change.count, sizeLimit));
          this.unshift(...change.items.slice(0, sizeLimit));
          break;
        case "append":
          if (this.data.length < sizeLimit) {
            this.appendArray(change.items.slice(0, sizeLimit - this.data.length));
          }
          break;
        case "insert":
          if (change.index < sizeLimit) {
            this.removeRight(Math.min(change.count, sizeLimit - change.index));
            this.insertAt(change.index, ...change.items.slice(0, sizeLimit - change.index));
          }
          break;
        case "merge":
        case "swap":
          this.merge(change.newState.slice(0, sizeLimit));
          break;
        case "replace":
          if (change.index < sizeLimit) {
            this.set(change.index, change.items[0]);
          }
          break;
      }
    }, cancellationToken);
  }
};
function processTransform(operations, result) {
  return async (v) => {
    try {
      for (const operation of operations) {
        switch (operation.operationType) {
          case OperationType.NOOP:
          case OperationType.MAP:
            v = operation.operation(v);
            break;
          case OperationType.MAP_DELAY_FILTER:
            const tmp = await operation.operation(v);
            if (tmp.cancelled) {
              return;
            } else {
              v = await tmp.item;
            }
            break;
          case OperationType.DELAY:
          case OperationType.MAP_DELAY:
            v = await operation.operation(v);
            break;
          case OperationType.DELAY_FILTER:
            if (!await operation.operation(v)) {
              return;
            }
            break;
          case OperationType.FILTER:
            if (!operation.operation(v)) {
              return;
            }
            break;
        }
      }
      result.update(v);
    } catch (e) {
      result.emitError(e);
    }
  };
}
var MapDataSource = class _MapDataSource {
  constructor(initialData) {
    __publicField(this, "data");
    __publicField(this, "updateEvent");
    __publicField(this, "updateEventOnKey");
    this.data = initialData ?? /* @__PURE__ */ new Map();
    this.updateEvent = new EventEmitter();
    this.updateEventOnKey = /* @__PURE__ */ new Map();
  }
  cancelAll() {
    this.updateEvent.cancelAll();
    this.updateEventOnKey.forEach((v, k) => v.cancelAll());
    this.updateEventOnKey.clear();
  }
  /**
   * Connects to an aurum-server exposed map datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
   * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server
   * @param  {AurumServerInfo} aurumServerInfo
   * @returns DataSource
   */
  static fromRemoteSource(aurumServerInfo, cancellation) {
    const result = new _MapDataSource();
    syncMapDataSource(result, aurumServerInfo, cancellation);
    return result;
  }
  static fromMultipleMaps(maps, cancellationToken) {
    const result = new _MapDataSource();
    let i = 0;
    for (const map of maps) {
      let index = i;
      result.assign(map);
      map.listen((change) => {
        let isOverwritten = false;
        for (let j = index + 1; j < maps.length; j++) {
          if (maps[j].has(change.key)) {
            isOverwritten = true;
            break;
          }
        }
        if (!isOverwritten) {
          if (change.deleted) {
            result.delete(change.key);
          } else {
            result.set(change.key, change.newValue);
          }
        }
      }, cancellationToken);
    }
    return result;
  }
  toAsyncIterator(cancellation) {
    return this.updateEvent.toAsyncIterator(cancellation);
  }
  pipe(target, cancellation) {
    this.listenAndRepeat((c) => target.applyMapChange(c), cancellation);
  }
  forEach(callbackfn, thisArg) {
    this.data.forEach(callbackfn, thisArg);
  }
  toString() {
    return this.data.toString();
  }
  static toMapDataSource(value) {
    if (value instanceof _MapDataSource) {
      return value;
    } else {
      return new _MapDataSource(value);
    }
  }
  applyMapChange(change) {
    if (change.deleted && this.data.has(change.key)) {
      this.delete(change.key);
    } else if (!change.deleted && !this.data.has(change.key)) {
      this.set(change.key, change.newValue);
    }
  }
  /**
   * Creates a datasource for a single key of the object
   * @param key
   * @param cancellationToken
   */
  pick(key, cancellationToken) {
    const subDataSource = new DataSource(this.data.get(key));
    this.listenOnKey(key, (v) => {
      subDataSource.update(v.newValue);
    }, cancellationToken);
    return subDataSource;
  }
  /**
   * Listen to changes of the object
   */
  listen(callback, cancellationToken) {
    return this.updateEvent.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Same as listen but will immediately call the callback with the current value of each key
   */
  listenAndRepeat(callback, cancellationToken) {
    const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;
    for (const key of this.data.keys()) {
      callback({
        key,
        newValue: this.data.get(key),
        oldValue: void 0,
        deleted: false
      });
    }
    return c;
  }
  map(mapper, cancellation) {
    const result = new _MapDataSource();
    const lifeTimeMap = /* @__PURE__ */ new Map();
    this.listenAndRepeat((change) => {
      if (change.deleted) {
        lifeTimeMap.get(change.key).cancel();
        lifeTimeMap.delete(change.key);
        result.delete(change.key);
      } else {
        const lifeTimeToken = new CancellationToken();
        if (lifeTimeMap.has(change.key)) {
          lifeTimeMap.get(change.key).cancel();
        }
        lifeTimeMap.set(change.key, lifeTimeToken);
        const newItem = mapper(change.key, change.newValue, lifeTimeToken);
        result.set(change.key, newItem);
      }
    }, cancellation);
    return result;
  }
  toKeysArrayDataSource(cancellation) {
    const result = new ArrayDataSource();
    this.listenAndRepeat((change) => {
      if (change.deleted) {
        result.remove(change.key);
      } else if (!change.deleted) {
        if (!result.includes(change.key)) {
          result.push(change.key);
        }
      }
    }, cancellation);
    return result;
  }
  toArrayDataSource(cancellation) {
    const stateMap = /* @__PURE__ */ new Map();
    const result = new ArrayDataSource();
    this.listenAndRepeat((change) => {
      if (change.deleted && stateMap.has(change.key)) {
        const item = stateMap.get(change.key);
        result.remove(item);
        stateMap.delete(change.key);
      } else if (stateMap.has(change.key)) {
        const newItem = change.newValue;
        result.replace(stateMap.get(change.key), newItem);
        stateMap.set(change.key, newItem);
      } else if (!stateMap.has(change.key) && !change.deleted) {
        const newItem = change.newValue;
        result.push(newItem);
        stateMap.set(change.key, newItem);
      }
    }, cancellation);
    return result;
  }
  toEntriesArrayDataSource(cancellation) {
    const stateMap = /* @__PURE__ */ new Map();
    const result = new ArrayDataSource();
    this.listenAndRepeat((change) => {
      if (change.deleted && stateMap.has(change.key)) {
        const index = result.findIndex((v) => v[0] === change.key);
        result.removeAt(index);
        stateMap.delete(change.key);
      } else if (stateMap.has(change.key)) {
        const newItem = change.newValue;
        const index = result.findIndex((v) => v[0] === change.key);
        result.set(index, [change.key, newItem]);
        stateMap.set(change.key, newItem);
      } else if (!stateMap.has(change.key) && !change.deleted) {
        const newItem = change.newValue;
        result.push([change.key, newItem]);
        stateMap.set(change.key, newItem);
      }
    }, cancellation);
    return result;
  }
  clear() {
    for (const key of this.data.keys()) {
      this.delete(key);
    }
  }
  /**
   * Same as listenOnKey but will immediately call the callback with the current value first
   */
  listenOnKeyAndRepeat(key, callback, cancellationToken) {
    callback({
      key,
      newValue: this.data.get(key),
      oldValue: void 0
    });
    return this.listenOnKey(key, callback, cancellationToken);
  }
  /**
   * Listen to changes of a single key of the object
   */
  listenOnKey(key, callback, cancellationToken) {
    if (!this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.set(key, new EventEmitter());
    }
    const event = this.updateEventOnKey.get(key);
    return event.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Returns all the keys of the object in the source
   */
  keys() {
    return this.data.keys();
  }
  /**
   * Returns all the values of the object in the source
   */
  values() {
    return this.data.values();
  }
  /**
   * get the current value of a key of the object
   * @param key
   */
  get(key) {
    return this.data.get(key);
  }
  /**
   * check if map has a key
   * @param key
   */
  has(key) {
    return this.data.has(key);
  }
  /**
   * delete a key from the object
   * @param key
   * @param value
   */
  delete(key) {
    if (!this.has(key)) {
      return;
    }
    const old = this.data.get(key);
    this.data.delete(key);
    this.updateEvent.fire({ oldValue: old, key, newValue: void 0, deleted: true });
    if (this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: void 0 });
    }
  }
  /**
   * set the value for a key of the object
   * @param key
   * @param value
   */
  set(key, value) {
    if (this.data.get(key) === value) {
      return;
    }
    const old = this.data.get(key);
    this.data.set(key, value);
    this.updateEvent.fire({ oldValue: old, key, newValue: this.data.get(key) });
    if (this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: this.data.get(key) });
    }
  }
  merge(newData) {
    for (const key of newData.keys()) {
      this.set(key, newData.get(key));
    }
    for (const key of this.keys()) {
      if (!newData.has(key)) {
        this.delete(key);
      }
    }
  }
  entries() {
    return this.data.entries();
  }
  /**
   * Merge the key value pairs of an object into this object non recursively
   * @param newData
   */
  assign(newData) {
    for (const key of newData.keys()) {
      this.set(key, newData.get(key));
    }
  }
  /**
   * Returns a shallow copy of the map
   */
  toMap() {
    return new Map(this.data.entries());
  }
};
var SetDataSource = class _SetDataSource {
  constructor(initialData) {
    __publicField(this, "data");
    __publicField(this, "updateEvent");
    __publicField(this, "updateEventOnKey");
    if (Array.isArray(initialData)) {
      this.data = new Set(initialData);
    } else {
      this.data = initialData ?? /* @__PURE__ */ new Set();
    }
    this.updateEvent = new EventEmitter();
    this.updateEventOnKey = /* @__PURE__ */ new Map();
  }
  /**
   * Connects to an aurum-server exposed set datasource. View https://github.com/CyberPhoenix90/aurum-server for more information
   * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server
   * @param  {AurumServerInfo} aurumServerInfo
   * @returns DataSource
   */
  static fromRemoteSource(aurumServerInfo, cancellation) {
    const result = new _SetDataSource(void 0);
    syncSetDataSource(result, aurumServerInfo, cancellation);
    return result;
  }
  static fromAsyncIterator(iterator, cancellation) {
    const result = new _SetDataSource();
    (async () => {
      for await (const item of iterator) {
        if (cancellation == null ? void 0 : cancellation.isCancelled) {
          return;
        }
        result.add(item);
      }
    })();
    return result;
  }
  toAsyncIterator(cancellation) {
    return this.updateEvent.toAsyncIterator(cancellation);
  }
  /**
   * Remove all listeners
   */
  cancelAll() {
    this.updateEvent.cancelAll();
  }
  applySetChange(change) {
    if (change.exists && !this.has(change.key)) {
      this.data.add(change.key);
    } else if (!change.exists && this.has(change.key)) {
      this.data.delete(change.key);
    }
  }
  clear() {
    for (const key of this.data.keys()) {
      this.delete(key);
    }
  }
  isSubsetOf(otherSet) {
    for (const key of this) {
      if (!otherSet.has(key)) {
        return false;
      }
    }
    return true;
  }
  isSupersetOf(otherSet) {
    for (const key of otherSet) {
      if (!this.has(key)) {
        return false;
      }
    }
    return true;
  }
  isDisjointWith(otherSet) {
    for (const key of otherSet) {
      if (this.has(key)) {
        return false;
      }
    }
    return true;
  }
  get size() {
    return this.data.size;
  }
  isIdenticalTo(otherSet) {
    if (this.size !== otherSet.size) {
      return false;
    }
    for (const key of otherSet) {
      if (!this.has(key)) {
        return false;
      }
    }
    return true;
  }
  static toSetDataSource(value) {
    if (value instanceof _SetDataSource) {
      return value;
    } else {
      return new _SetDataSource(value);
    }
  }
  [Symbol.iterator]() {
    return this.data.keys();
  }
  /**
   * Returns an iterable of [v,v] pairs for every value `v` in the set.
   */
  entries() {
    return this.data.entries();
  }
  /**
   * Returns an iterable of values in the set.
   */
  values() {
    return this.data.values();
  }
  difference(otherSet, cancellationToken) {
    const result = new _SetDataSource();
    const otherSetKeys = new Set(otherSet.keys());
    this.listenAndRepeat((change) => {
      if (change.exists && !otherSetKeys.has(change.key)) {
        result.add(change.key);
      }
      if (!change.exists) {
        result.delete(change.key);
      }
    }, cancellationToken);
    otherSet.listenAndRepeat((change) => {
      if (change.exists) {
        result.delete(change.key);
      }
      if (!change.exists && this.has(change.key)) {
        result.add(change.key);
      }
    }, cancellationToken);
    return result;
  }
  union(otherSet, cancellationToken) {
    const result = new _SetDataSource();
    this.listenAndRepeat((change) => {
      if (change.exists) {
        result.add(change.key);
      } else if (!otherSet.has(change.key)) {
        result.delete(change.key);
      }
    }, cancellationToken);
    otherSet.listenAndRepeat((change) => {
      if (change.exists) {
        result.add(change.key);
      } else if (!this.has(change.key)) {
        result.delete(change.key);
      }
    }, cancellationToken);
    return result;
  }
  intersection(otherSet, cancellationToken) {
    const result = new _SetDataSource();
    this.listenAndRepeat((change) => {
      if (change.exists && otherSet.has(change.key)) {
        result.add(change.key);
      } else {
        result.delete(change.key);
      }
    }, cancellationToken);
    otherSet.listenAndRepeat((change) => {
      if (change.exists && this.has(change.key)) {
        result.add(change.key);
      } else {
        result.delete(change.key);
      }
    }, cancellationToken);
    return result;
  }
  symmetricDifference(otherSet, cancellationToken) {
    const result = new _SetDataSource();
    this.listenAndRepeat((change) => {
      if (change.exists && !otherSet.has(change.key)) {
        result.add(change.key);
      } else if (!change.exists && otherSet.has(change.key)) {
        result.add(change.key);
      } else if (change.exists && otherSet.has(change.key)) {
        result.delete(change.key);
      } else if (!change.exists && !otherSet.has(change.key)) {
        result.delete(change.key);
      }
    }, cancellationToken);
    otherSet.listenAndRepeat((change) => {
      if (change.exists && !this.has(change.key)) {
        result.add(change.key);
      } else if (!change.exists && this.has(change.key)) {
        result.add(change.key);
      } else if (change.exists && this.has(change.key)) {
        result.delete(change.key);
      } else if (!change.exists && !this.has(change.key)) {
        result.delete(change.key);
      }
    }, cancellationToken);
    return result;
  }
  toString() {
    return this.data.toString();
  }
  /**
   * Creates a datasource for a single key of the object
   * @param key
   * @param cancellationToken
   */
  pick(key, cancellationToken) {
    const subDataSource = new DataSource(this.data.has(key));
    this.listenOnKey(key, (v) => {
      subDataSource.update(v);
    }, cancellationToken);
    return subDataSource;
  }
  /**
   * Listen to changes of the object
   */
  listen(callback, cancellationToken) {
    return this.updateEvent.subscribe(callback, cancellationToken).cancel;
  }
  /**
   * Same as listen but will immediately call the callback with the current value of each key
   */
  listenAndRepeat(callback, cancellationToken) {
    const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;
    for (const key of this.data.keys()) {
      callback({
        key,
        exists: true
      });
    }
    return c;
  }
  /**
   * Same as listenOnKey but will immediately call the callback with the current value first
   */
  listenOnKeyAndRepeat(key, callback, cancellationToken) {
    callback(this.has(key));
    return this.listenOnKey(key, callback, cancellationToken);
  }
  /**
   * Listen to changes of a single key of the object
   */
  listenOnKey(key, callback, cancellationToken) {
    if (!this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.set(key, new EventEmitter());
    }
    const event = this.updateEventOnKey.get(key);
    return event.subscribe(callback, cancellationToken).cancel;
  }
  toArrayDataSource(cancellationToken) {
    return this.map((key) => key, cancellationToken);
  }
  map(mapper, cancellationToken) {
    const stateMap = /* @__PURE__ */ new Map();
    const result = new ArrayDataSource();
    this.listenAndRepeat((change) => {
      if (!change.exists && stateMap.has(change.key)) {
        const item = stateMap.get(change.key);
        result.remove(item);
        stateMap.delete(change.key);
      } else if (!stateMap.has(change.key) && change.exists) {
        const newItem = mapper(change.key);
        result.push(newItem);
        stateMap.set(change.key, newItem);
      }
    }, cancellationToken);
    return result;
  }
  /**
   * Returns all the keys of the object in the source
   */
  keys() {
    return this.data.keys();
  }
  /**
   * check if map has a key
   * @param key
   */
  has(key) {
    return this.data.has(key);
  }
  /**
   * Returns a datasource that reflects if the key exists in the set
   * @param key
   * @param cancellationToken
   * @returns
   */
  pickKey(key, cancellationToken) {
    const result = new DataSource(this.has(key));
    this.listenOnKey(key, (v) => result.update(v), cancellationToken);
    return result;
  }
  /**
   * delete a key from the object
   * @param key
   * @param value
   */
  delete(key) {
    if (this.has(key)) {
      this.data.delete(key);
      this.updateEvent.fire({ key, exists: false });
      if (this.updateEventOnKey.has(key)) {
        this.updateEventOnKey.get(key).fire(false);
      }
    }
  }
  /**
   * set the value for a key of the object
   * @param key
   * @param value
   */
  add(key) {
    if (this.data.has(key)) {
      return;
    }
    this.data.add(key);
    this.updateEvent.fire({ key, exists: true });
    if (this.updateEventOnKey.has(key)) {
      this.updateEventOnKey.get(key).fire(true);
    }
  }
  merge(newData) {
    let newItems;
    if (newData instanceof _SetDataSource) {
      newItems = newData.data;
    } else if (newData instanceof Set) {
      newItems = newData;
    } else if (newData instanceof ArrayDataSource) {
      newItems = new Set(newData.getData());
    } else {
      newItems = new Set(newData);
    }
    for (const item of this.data) {
      if (!newItems.has(item)) {
        this.delete(item);
      }
    }
    for (const item of newItems) {
      this.add(item);
    }
  }
  /**
   * Merge the key value pairs of an object into this object non recursively
   * @param newData
   */
  assign(newData) {
    for (const key of newData.keys()) {
      this.add(key);
    }
  }
  /**
   * Returns a shallow copy of the set
   */
  toSet() {
    return new Set(this.data.keys());
  }
  toArray() {
    return Array.from(this.data.keys());
  }
};
function dsCriticalSection(operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI, operationJ, operationK) {
  const lockState = new DataSource(false);
  const operations = [
    operationA,
    operationB,
    operationC,
    operationD,
    operationE,
    operationF,
    operationG,
    operationH,
    operationI,
    operationJ,
    operationK
  ].filter((v) => v !== void 0);
  const buffer = [];
  lockState.listen((v) => {
    if (!v) {
      if (buffer.length > 0) {
        queueMicrotask(async () => {
          if (!lockState.value) {
            lockState.update(true);
            const item = buffer.shift();
            try {
              const value = await processInlineTransform(operations, item.value);
              item.resolve(value);
            } catch (e) {
              item.reject(e);
            } finally {
              lockState.update(false);
            }
          }
        });
      }
    }
  });
  return {
    name: `CriticalSection<${operations.map((v) => v.name).join(", ")}>`,
    operationType: OperationType.MAP_DELAY_FILTER,
    operation: async (v) => {
      if (!lockState.value) {
        lockState.update(true);
        try {
          const result = await processInlineTransform(operations, v);
          return result;
        } finally {
          lockState.update(false);
        }
      }
      return new Promise((resolve, reject) => {
        buffer.push({
          resolve,
          reject,
          value: v
        });
      });
    }
  };
}
function dsForkInline(condition, operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI) {
  const ops = [operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI].filter((v) => v !== void 0);
  return {
    name: "fork-inline",
    operationType: OperationType.MAP_DELAY_FILTER,
    operation: async (v) => {
      if (condition(v)) {
        return processInlineTransform(ops, v);
      } else {
        return { item: v, cancelled: false };
      }
    }
  };
}
async function processInlineTransform(operations, value) {
  let out;
  let error;
  let hasValue = false;
  const sink = new DataSource();
  sink.listen((result) => {
    out = result;
    hasValue = true;
  });
  sink.handleErrors((e) => {
    error = e;
  });
  await processTransform(operations, sink)(value);
  if (error) {
    throw error;
  }
  return { item: out, cancelled: !hasValue };
}

// node_modules/aurumjs/prebuilt/esnext/utilities/classname.js
function aurumClassName(data, cancellationToken) {
  if (data instanceof MapDataSource) {
    return handleClassMapDataSource(data, cancellationToken);
  } else {
    return handleClassMapLike(data, cancellationToken);
  }
}
function handleClassMapLike(data, cancellationToken) {
  const result = [];
  for (const key in data) {
    if (data[key]) {
      if (data[key] instanceof DataSource || data[key] instanceof DuplexDataSource) {
        const source = data[key];
        const mappedSource = new DataSource(source.value ? key : "");
        source.listen((value) => {
          mappedSource.update(value ? key : "");
        }, cancellationToken);
        result.push(mappedSource);
      } else {
        result.push(key);
      }
    }
  }
  return result;
}
function handleClassMapDataSource(data, cancellationToken) {
  const stateMap = /* @__PURE__ */ new Map();
  const result = new ArrayDataSource();
  data.listenAndRepeat((change) => {
    if (change.deleted && stateMap.has(change.key)) {
      result.remove(change.key);
      stateMap.delete(change.key);
    } else if (stateMap.has(change.key)) {
      const newState = change.newValue;
      if (newState && !stateMap.get(change.key)) {
        result.push(change.key);
      }
      if (!newState && stateMap.get(change.key)) {
        result.remove(change.key);
      }
      stateMap.set(change.key, newState);
    } else if (!stateMap.has(change.key) && !change.deleted) {
      const newState = change.newValue;
      if (newState) {
        result.push(change.key);
      }
      stateMap.set(change.key, newState);
    }
  }, cancellationToken);
  return result;
}
function combineClass(cancellationToken, ...args) {
  args = args.filter((e) => !!e);
  if (args.length < 2) {
    return args[0];
  }
  let fixed = "";
  const sources = [];
  const maps = [];
  resolveConstants(args);
  function resolveConstants(args2) {
    for (const arg of args2) {
      if (typeof arg === "string") {
        fixed += arg + " ";
      } else if (Array.isArray(arg)) {
        resolveConstants(arg);
      } else if (arg instanceof DataSource || arg instanceof DuplexDataSource) {
        sources.push(arg);
      } else if (arg instanceof MapDataSource) {
        maps.push(arg);
      } else if (typeof arg === "object") {
        for (const key in arg) {
          if (arg[key] instanceof DataSource || arg[key] instanceof DuplexDataSource) {
            sources.push(arg[key].transform(dsMap((v) => v ? key : ""), cancellationToken));
          } else {
            fixed += arg[key] ? key + " " : "";
          }
        }
      }
    }
  }
  fixed = fixed.trim();
  if (sources.length || maps.length) {
    let update = function() {
      const classes = [fixed];
      for (const source of sources) {
        if (Array.isArray(source.value)) {
          classes.push(...source.value);
        } else {
          classes.push(source.value);
        }
      }
      for (const map of maps) {
        for (const key of map.keys()) {
          if (map.get(key)) {
            classes.push(key);
          }
        }
      }
      result.update(classes.join(" "));
    };
    const result = new DataSource();
    update();
    for (const source of sources) {
      source.listen(update, cancellationToken);
    }
    for (const map of maps) {
      map.listen(update, cancellationToken);
    }
    return result;
  } else {
    return fixed;
  }
}
function combineAttribute(cancellationToken, ...args) {
  const constants = [];
  const sources = [];
  for (const attr of args) {
    if (typeof attr === "string" || typeof attr === "boolean") {
      constants.push(attr);
    }
    if (attr instanceof DataSource || attr instanceof DuplexDataSource) {
      sources.push(attr);
    }
  }
  if (sources.length) {
    return sources[0].aggregate(sources.slice(1), (...data) => {
      if (constants.length) {
        return data.concat(constants).join(" ");
      } else {
        return data.join(" ");
      }
    }, cancellationToken);
  } else {
    return constants.join(" ");
  }
}
function combineStyle(cancellationToken, ...args) {
  let fixed = "";
  const sources = [];
  const maps = [];
  for (const attr of args) {
    if (typeof attr === "string") {
      fixed += attr + ";";
    } else if (attr instanceof DataSource || attr instanceof DuplexDataSource) {
      sources.push(attr);
    } else if (attr instanceof MapDataSource) {
      maps.push(attr);
    } else if (typeof attr === "object" && !(attr instanceof DataSource || attr instanceof DuplexDataSource)) {
      for (const key in attr) {
        if (attr[key] instanceof DataSource) {
          sources.push(attr[key].transform((v) => `${camelCaseToKebabCase(key)}:${v};`, cancellationToken));
        } else {
          fixed += `${camelCaseToKebabCase(key)}:${attr[key]};`;
        }
      }
    }
  }
  if (sources.length || maps.length) {
    let result = new DataSource(computeResult(fixed, sources, maps));
    for (const source of sources) {
      source.listenAndRepeat((change) => {
        result.update(computeResult(fixed, sources, maps));
      }, cancellationToken);
    }
    for (const map of maps) {
      map.listenAndRepeat((change) => {
        result.update(computeResult(fixed, sources, maps));
      }, cancellationToken);
    }
    return result;
  } else {
    return fixed;
  }
}
function computeResult(fixed, sources, maps) {
  let result = fixed;
  for (const source of sources) {
    result += source.value;
  }
  for (const map of maps) {
    for (const key of map.keys()) {
      if (map.get(key)) {
        result += `${camelCaseToKebabCase(key)}:${map.get(key)};`;
      }
    }
  }
  return result;
}
function camelCaseToKebabCase(key) {
  return key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
}

// node_modules/aurumjs/prebuilt/esnext/nodes/rendering_helpers.js
function handleClass(data, cleanUp) {
  if (typeof data === "string") {
    return data;
  } else if (data instanceof DataSource || data instanceof DuplexDataSource) {
    return data.transform(dsUnique(), dsMap((v) => {
      if (Array.isArray(v)) {
        return v.join(" ");
      } else {
        return v;
      }
    }), cleanUp).withInitial(data.value);
  } else if (data instanceof ArrayDataSource) {
    return data.reduce((p, c) => `${p} ${c}`, "", cleanUp);
  } else if (data instanceof MapDataSource || typeof data === "object" && !Array.isArray(data)) {
    const result = aurumClassName(data, cleanUp);
    return handleClass(result, cleanUp);
  } else {
    const result = new DataSource(buildClass(data));
    for (const i of data) {
      if (i instanceof DataSource) {
        i.transform(dsUnique(), cleanUp).listen((v) => {
          result.update(buildClass(data));
        }, cleanUp);
      }
    }
    return result;
  }
}
function buildClass(data) {
  return data.reduce((p, c) => {
    if (c == null) {
      return p;
    }
    if (typeof c === "string") {
      return `${p} ${c}`;
    } else {
      if (c.value) {
        return `${p} ${c.value}`;
      } else {
        return p;
      }
    }
  }, "");
}
function handleStyle(data, cleanUp) {
  if (typeof data === "string") {
    return data;
  } else if (data instanceof DataSource || data instanceof DuplexDataSource) {
    return data.transform(dsUnique(), dsMap((v) => {
      return v.toString();
    }), cleanUp);
  } else if (data instanceof MapDataSource) {
    return data.toEntriesArrayDataSource(cleanUp).reduce((p, c) => {
      return `${p}${camelCaseToKebabCase(c[0])}:${c[1]};`;
    }, "", cleanUp);
  } else if (typeof data === "object" && !Array.isArray(data)) {
    const result = new ArrayDataSource();
    let index = 0;
    for (const i in data) {
      if (data[i] instanceof DataSource) {
        const myIndex = index;
        result.push([i, data[i].value]);
        data[i].listen((v) => {
          result.set(myIndex, [i, v]);
        }, cleanUp);
      } else {
        result.push([i, data[i]]);
      }
      index++;
    }
    return result.reduce((p, c) => `${p}${camelCaseToKebabCase(c[0])}:${c[1]};`, "", cleanUp);
  } else {
    return "";
  }
}

// node_modules/aurumjs/prebuilt/esnext/rendering/aurum_element.js
function createRenderSession() {
  const session = {
    attachCalls: [],
    sessionToken: new CancellationToken(() => {
      for (const token of session.tokens) {
        token.cancel();
      }
    }),
    tokens: []
  };
  return session;
}
var aurumElementModelIdentitiy = Symbol("AurumElementModel");
function createLifeCycle() {
  const lc = {
    attach: new EventEmitter(),
    detach: new EventEmitter(),
    onAttach() {
      lc.attach.fire();
    },
    onDetach() {
      lc.detach.fire();
    }
  };
  return lc;
}
var _AurumElement = class _AurumElement {
  constructor(dataSource, api) {
    __publicField(this, "children");
    __publicField(this, "api");
    __publicField(this, "contentStartMarker");
    __publicField(this, "contentEndMarker");
    __publicField(this, "hostNode");
    __publicField(this, "lastStartIndex");
    __publicField(this, "lastEndIndex");
    __publicField(this, "disposed", false);
    this.children = [];
    this.api = api;
    this.api.onAttach(() => {
      if (!this.api.cancellationToken.isCancelled) {
        if (this.hostNode === void 0) {
          throw new Error("illegal state: Attach fired but not actually attached");
        }
        this.render(dataSource);
      }
    });
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    if (this.hostNode.isConnected) {
      this.clearContent();
      this.contentStartMarker.remove();
      this.contentEndMarker.remove();
    }
    this.disposed = true;
  }
  attachToDom(node, index) {
    if (this.hostNode) {
      throw new Error("Aurum Element is already attached");
    }
    const id = _AurumElement.id++;
    this.hostNode = node;
    this.contentStartMarker = document.createComment("START Aurum Node " + id);
    this.contentStartMarker.owner = this;
    this.contentEndMarker = document.createComment("END Aurum Node " + id);
    if (index >= node.childNodes.length) {
      node.appendChild(this.contentStartMarker);
      node.appendChild(this.contentEndMarker);
    } else {
      node.insertBefore(this.contentStartMarker, node.childNodes[index]);
      node.insertBefore(this.contentEndMarker, node.childNodes[index + 1]);
    }
  }
  getStartIndex() {
    return this.getWorkIndex() - 1;
  }
  getWorkIndex() {
    if (this.lastStartIndex !== void 0 && this.hostNode.childNodes[this.lastStartIndex] === this.contentStartMarker) {
      return this.lastStartIndex + 1;
    }
    for (let i = 0; i < this.hostNode.childNodes.length; i++) {
      if (this.hostNode.childNodes[i] === this.contentStartMarker) {
        this.lastStartIndex = i;
        return i + 1;
      }
    }
    return -1;
  }
  getLastIndex() {
    if (this.lastEndIndex !== void 0 && this.hostNode.childNodes[this.lastEndIndex] === this.contentEndMarker) {
      return this.lastEndIndex;
    }
    for (let i = 0; i < this.hostNode.childNodes.length; i++) {
      if (this.hostNode.childNodes[i] === this.contentEndMarker) {
        this.lastEndIndex = i;
        return i;
      }
    }
    return -1;
  }
  clearContent() {
    if (this.hostNode === void 0) {
      throw new Error("illegal state: Aurum element was not attched to anything");
    }
    let workIndex = this.getWorkIndex();
    while (this.hostNode.childNodes[workIndex] !== this.contentEndMarker) {
      if (!(this.hostNode.childNodes[workIndex] instanceof Comment)) {
        this.hostNode.removeChild(this.hostNode.childNodes[workIndex]);
      } else {
        if (this.hostNode.childNodes[workIndex].owner.disposed) {
          break;
        }
        this.hostNode.childNodes[workIndex].owner.dispose();
      }
    }
  }
  updateDom() {
    var _a;
    const workIndex = this.getWorkIndex();
    let i;
    let offset = 0;
    for (i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child === void 0 || child === null) {
        offset--;
        continue;
      }
      if (child === this.hostNode.childNodes[i + workIndex + offset]) {
        continue;
      }
      if (child instanceof _AurumElement) {
        if (!child.hostNode) {
          child.attachToDom(this.hostNode, i + workIndex + offset);
        }
        if (child.getStartIndex() === i + workIndex + offset) {
          offset += child.getLastIndex() - i - offset - workIndex;
        } else {
          let start = child.getStartIndex();
          let end = child.getLastIndex();
          for (let ptr = start, swapIteration = 0; ptr <= end; ptr++, swapIteration++) {
            const itemA = this.hostNode.childNodes[i + workIndex + offset + swapIteration];
            const itemB = this.hostNode.childNodes[ptr];
            const parentA = itemA.parentNode;
            const siblingA = itemA.nextSibling === itemB ? itemB : itemA.nextSibling;
            itemB.parentNode.insertBefore(itemA, itemB);
            parentA.insertBefore(itemB, siblingA);
          }
          offset += child.getLastIndex() - i - offset - workIndex;
        }
        continue;
      }
      if (this.hostNode.childNodes[i + workIndex + offset] !== this.contentEndMarker && this.hostNode.childNodes[i + workIndex + offset] !== this.children[i] && this.hostNode.childNodes[i + workIndex + offset] !== ((_a = this.children[i + 1]) == null ? void 0 : _a.contentStartMarker)) {
        if (child instanceof HTMLElement || child instanceof Text || child instanceof SVGElement) {
          this.hostNode.removeChild(this.hostNode.childNodes[i + workIndex + offset]);
          if (this.hostNode.childNodes[i + workIndex + offset]) {
            this.lastEndIndex++;
            this.hostNode.insertBefore(child, this.hostNode.childNodes[i + workIndex + offset]);
          } else {
            this.lastEndIndex++;
            this.hostNode.appendChild(child);
          }
        } else {
          throw new Error("not implemented");
        }
      } else {
        if (child instanceof HTMLElement || child instanceof Text || child instanceof SVGElement) {
          if (this.hostNode.childNodes[i + workIndex + offset]) {
            this.lastEndIndex++;
            this.hostNode.insertBefore(child, this.hostNode.childNodes[i + workIndex + offset]);
          } else {
            this.lastEndIndex++;
            this.hostNode.appendChild(child);
          }
        } else {
          throw new Error("not implemented");
        }
      }
    }
    while (this.hostNode.childNodes[i + workIndex + offset] !== this.contentEndMarker) {
      this.lastEndIndex--;
      this.hostNode.removeChild(this.hostNode.childNodes[i + workIndex + offset]);
    }
  }
};
__publicField(_AurumElement, "id", 1);
var AurumElement = _AurumElement;
function renderInternal(element, session, prerendering = false) {
  if (element == void 0) {
    return void 0;
  }
  if (Array.isArray(element)) {
    const result = [];
    for (const item of element) {
      const rendered = renderInternal(item, session, prerendering);
      if (rendered !== void 0 && rendered !== null) {
        if (Array.isArray(rendered)) {
          result.push(...rendered);
        } else {
          result.push(rendered);
        }
      }
    }
    return result;
  }
  if (!prerendering) {
    const type = typeof element;
    if (type === "string") {
      return document.createTextNode(element);
    } else if (type === "number" || type === "bigint" || type === "boolean") {
      return document.createTextNode(element.toString());
    }
    if (element instanceof Promise) {
      const ds = new DataSource();
      element.then((val) => {
        ds.update(val);
      });
      const result = new SingularAurumElement(ds, createAPI(session));
      return result;
    } else if (element instanceof DataSource || element instanceof DuplexDataSource) {
      const result = new SingularAurumElement(element, createAPI(session));
      return result;
    } else if (element instanceof ArrayDataSource) {
      const result = new ArrayAurumElement(element, createAPI(session));
      return result;
    }
  }
  if (element[aurumElementModelIdentitiy]) {
    const model = element;
    let api;
    if (!model.isIntrinsic || model.props) {
      api = createAPI(session);
    } else {
      api = {
        renderSession: session
      };
    }
    let componentResult;
    if (model.isIntrinsic) {
      componentResult = model.factory(model.props, model.children, api);
    } else {
      componentResult = model.factory(model.props ?? {}, model.children, api);
    }
    return renderInternal(componentResult, session, prerendering);
  }
  return element;
}
function createAPI(session) {
  let token = void 0;
  const api = {
    renderSession: session,
    synchronizeLifeCycle(lifeCycle) {
      api.onAttach(() => lifeCycle.onAttach());
      api.onDetach(() => lifeCycle.onDetach());
    },
    onAttach: (cb) => {
      session.attachCalls.push(cb);
    },
    onDetach: (cb) => {
      if (!token) {
        token = new CancellationToken();
        session.tokens.push(token);
      }
      token.addCancellable(cb);
    },
    get cancellationToken() {
      if (!token) {
        token = new CancellationToken();
        session.tokens.push(token);
      }
      return token;
    },
    prerender(target, lifeCycle) {
      const lc = lifeCycle;
      const subSession = createRenderSession();
      const result = renderInternal(target, subSession, true);
      lc.attach.subscribeOnce(() => {
        subSession.attachCalls.forEach((cb) => cb());
      });
      lc.detach.subscribeOnce(() => {
        lc.attach.cancelAll();
        subSession.sessionToken.cancel();
      });
      return result;
    }
  };
  return api;
}
var ArrayAurumElement = class extends AurumElement {
  constructor(dataSource, api) {
    super(dataSource, api);
    __publicField(this, "renderSessions");
    __publicField(this, "dataSource");
    this.renderSessions = /* @__PURE__ */ new WeakMap();
    this.dataSource = dataSource;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    this.api.cancellationToken.cancel();
    super.dispose();
  }
  attachToDom(node, index) {
    super.attachToDom(node, index);
    this.contentStartMarker.dataSource = this.dataSource;
    this.contentEndMarker.dataSource = this.dataSource;
  }
  render(dataSource) {
    dataSource.listenAndRepeat((n) => {
      if (!this.disposed) {
        this.handleNewContent(n);
      }
    }, this.api.cancellationToken);
  }
  spliceChildren(index, amount, ...newItems) {
    var _a;
    let removed;
    if (newItems) {
      removed = this.children.splice(index, amount, ...newItems);
    } else {
      removed = this.children.splice(index, amount);
    }
    for (const item of removed) {
      (_a = this.renderSessions.get(item)) == null ? void 0 : _a.sessionToken.cancel();
    }
  }
  handleNewContent(change) {
    if (this.hostNode === void 0) {
      throw new Error("illegal state: Aurum element was not attched to anything");
    }
    let optimized = false;
    const ac = [];
    switch (change.operationDetailed) {
      case "merge":
        const source = change.previousState.slice();
        for (let i = 0; i < change.newState.length; i++) {
          if (this.children.length <= i) {
            const rendered2 = this.renderItem(change.newState[i], ac);
            if (Array.isArray(rendered2)) {
              this.children.push(...rendered2);
            } else {
              this.children.push(rendered2);
            }
            source.push(change.newState[i]);
          } else if (source[i] !== change.newState[i]) {
            const index2 = source.indexOf(change.newState[i], i);
            if (index2 !== -1) {
              const a = this.children[i];
              const b = this.children[index2];
              this.children[i] = b;
              this.children[index2] = a;
              const c = source[i];
              const d = source[index2];
              source[i] = d;
              source[index2] = c;
            } else {
              const rendered2 = this.renderItem(change.newState[i], ac);
              if (Array.isArray(rendered2)) {
                this.spliceChildren(i, 0, ...rendered2);
              } else {
                this.spliceChildren(i, 0, rendered2);
              }
              source.splice(i, 0, change.newState[i]);
            }
          }
        }
        if (this.children.length > change.newState.length) {
          this.spliceChildren(change.newState.length, this.children.length - change.newState.length);
        }
        break;
      case "remove":
      case "removeLeft":
      case "removeRight":
        this.spliceChildren(flattenIndex(change.newState, change.index), flattenIndex(change.items, change.items.length));
        break;
      case "append":
        let targetIndex = this.getLastIndex();
        optimized = true;
        for (const item of change.items) {
          const rendered2 = this.renderItem(item, ac);
          if (Array.isArray(rendered2)) {
            this.children = this.children.concat(rendered2);
            for (let i = 0; i <= rendered2.length; i++) {
              if (rendered2[i]) {
                if (rendered2[i] instanceof AurumElement) {
                  rendered2[i].attachToDom(this.hostNode, targetIndex);
                  this.lastEndIndex = this.getLastIndex();
                  targetIndex = this.lastEndIndex;
                } else {
                  this.hostNode.insertBefore(rendered2[i], this.hostNode.childNodes[targetIndex]);
                  this.lastEndIndex++;
                  targetIndex++;
                }
              }
            }
          } else {
            this.children.push(rendered2);
            if (rendered2) {
              if (rendered2 instanceof AurumElement) {
                rendered2.attachToDom(this.hostNode, targetIndex);
                this.lastEndIndex = this.getLastIndex();
                targetIndex = this.lastEndIndex;
              } else {
                this.hostNode.insertBefore(rendered2, this.hostNode.childNodes[targetIndex]);
                this.lastEndIndex++;
                targetIndex++;
              }
            }
          }
        }
        break;
      case "replace":
        const rendered = this.renderItem(change.items[0], ac);
        if (Array.isArray(rendered)) {
          throw new Error("illegal state");
        } else {
          this.children[change.index] = rendered;
        }
        break;
      case "swap":
        const itemA = this.children[change.index];
        const itemB = this.children[change.index2];
        if (itemA instanceof HTMLElement && itemB instanceof HTMLElement || itemA instanceof SVGElement && itemB instanceof SVGElement) {
          optimized = true;
          if (itemA.parentElement === itemB.parentElement) {
            if (itemA.nextSibling === itemB) {
              itemB.parentNode.insertBefore(itemB, itemA);
              this.children[change.index2] = itemA;
              this.children[change.index] = itemB;
              break;
            }
            if (itemB.nextSibling === itemA) {
              itemB.parentNode.insertBefore(itemA, itemB);
              this.children[change.index2] = itemA;
              this.children[change.index] = itemB;
              break;
            }
          }
          const parentA = itemA.parentNode;
          const siblingA = itemA.nextSibling === itemB ? itemB : itemA.nextSibling;
          itemB.parentNode.insertBefore(itemA, itemB);
          parentA.insertBefore(itemB, siblingA);
        }
        this.children[change.index2] = itemA;
        this.children[change.index] = itemB;
        break;
      case "prepend":
        for (let i = change.items.length - 1; i >= 0; i--) {
          const item = change.items[i];
          const rendered2 = this.renderItem(item, ac);
          if (Array.isArray(rendered2)) {
            throw new Error("illegal state");
          } else {
            this.children.unshift(rendered2);
          }
        }
        break;
      case "insert":
        let index = change.index;
        for (const item of change.items) {
          const rendered2 = this.renderItem(item, ac);
          if (Array.isArray(rendered2)) {
            throw new Error("illegal state");
          } else {
            this.children.splice(index, 0, rendered2);
            index += 1;
          }
        }
        break;
      case "clear":
        this.spliceChildren(0, this.children.length);
        this.renderSessions = /* @__PURE__ */ new WeakMap();
        break;
      default:
        throw new Error(`DOM updates from ${change.operationDetailed} are not supported`);
    }
    if (!optimized) {
      this.updateDom();
    }
    for (const c of ac) {
      c();
    }
  }
  renderItem(item, attachCalls) {
    if (item === null || item === void 0) {
      return;
    }
    const s = createRenderSession();
    const rendered = renderInternal(item, s);
    if (rendered === void 0 || rendered === null) {
      return;
    }
    if (rendered instanceof AurumElement) {
      s.sessionToken.addCancellable(() => rendered.dispose());
    }
    this.renderSessions.set(rendered, s);
    attachCalls.push(...s.attachCalls);
    return rendered;
  }
};
function flattenIndex(source, index) {
  let flatIndex = 0;
  for (let i = 0; i < index; i++) {
    if (Array.isArray(source[i])) {
      flatIndex += flattenIndex(source[i], source[i].length);
    } else {
      flatIndex++;
    }
  }
  return flatIndex;
}
var SingularAurumElement = class extends AurumElement {
  constructor(dataSource, api) {
    super(dataSource, api);
    __publicField(this, "renderSession");
    __publicField(this, "lastValue");
    __publicField(this, "dataSource");
    this.api.cancellationToken.addCancellable(() => {
      var _a;
      return (_a = this.renderSession) == null ? void 0 : _a.sessionToken.cancel();
    });
    this.dataSource = dataSource;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    this.api.cancellationToken.cancel();
    super.dispose();
  }
  attachToDom(node, index) {
    super.attachToDom(node, index);
    this.contentStartMarker.dataSource = this.dataSource;
    this.contentEndMarker.dataSource = this.dataSource;
  }
  render(dataSource) {
    dataSource.listenAndRepeat((n) => {
      if (!this.disposed) {
        this.handleNewContent(n);
      }
    }, this.api.cancellationToken);
  }
  handleNewContent(newValue) {
    if (this.lastValue === newValue) {
      return;
    }
    let optimized = false;
    if (this.children.length === 1 && this.children[0] instanceof Text) {
      const type = typeof newValue;
      if (type === "string" || type === "bigint" || type === "number" || type === "boolean") {
        this.children[0].nodeValue = newValue;
        optimized = true;
      }
    }
    if (!optimized) {
      this.fullRebuild(newValue);
      this.updateDom();
      for (const cb of this.renderSession.attachCalls) {
        cb();
      }
    }
    this.lastValue = newValue;
  }
  fullRebuild(newValue) {
    this.clearContent();
    this.endSession();
    this.renderSession = createRenderSession();
    let rendered = renderInternal(newValue, this.renderSession);
    if (rendered === void 0) {
      this.children = [];
      return;
    }
    if (!Array.isArray(rendered)) {
      rendered = [rendered];
    }
    for (const item of rendered) {
      if (item instanceof AurumElement) {
        this.renderSession.sessionToken.addCancellable(() => {
          item.dispose();
        });
      }
    }
    if (Array.isArray(rendered)) {
      this.children = rendered;
    }
  }
  endSession() {
    if (this.renderSession) {
      this.renderSession.sessionToken.cancel();
      this.renderSession = void 0;
    }
  }
};

// node_modules/aurumjs/prebuilt/esnext/rendering/renderers/dom_adapter.js
var defaultEvents = {
  drag: "onDrag",
  dragstart: "onDragStart",
  dragend: "onDragEnd",
  dragexit: "onDragExit",
  dragover: "onDragOver",
  dragenter: "onDragEnter",
  dragleave: "onDragLeave",
  drop: "onDrop",
  blur: "onBlur",
  focus: "onFocus",
  click: "onClick",
  dblclick: "onDblClick",
  keydown: "onKeyDown",
  keyhit: "onKeyHit",
  keyup: "onKeyUp",
  contextmenu: "onContextMenu",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mousemove: "onMouseMove",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  mousewheel: "onMouseWheel",
  load: "onLoad",
  error: "onError"
};
var defaultAttributes = ["id", "name", "draggable", "tabindex", "role", "contenteditable", "slot", "title"];
function DomNodeCreator(nodeName, extraAttributes, extraEvents, extraLogic, svg = false) {
  return function(props, children, api) {
    let node;
    if (svg) {
      node = document.createElementNS("http://www.w3.org/2000/svg", nodeName);
    } else {
      node = document.createElement(nodeName);
    }
    if (props) {
      processHTMLNode(node, props, api.cancellationToken, extraAttributes, extraEvents);
    }
    const renderedChildren = renderInternal(children, api.renderSession);
    connectChildren(node, renderedChildren);
    if (props) {
      if (props.onAttach) {
        api.onAttach(() => props.onAttach(node));
      }
      if (props.onDetach) {
        api.onDetach(() => {
          if (node.isConnected) {
            node.parentElement.removeChild(node);
          }
          props.onDetach(node);
        });
      }
    }
    extraLogic == null ? void 0 : extraLogic(node, props, api.cancellationToken);
    return node;
  };
}
function connectChildren(target, children) {
  if (children === void 0 || children === null || children.length === 0) {
    return;
  }
  for (const child of children) {
    if (!child) {
      continue;
    }
    if (child instanceof Text || child instanceof HTMLElement || child instanceof SVGElement) {
      target.appendChild(child);
    } else if (child instanceof AurumElement) {
      child.attachToDom(target, target.childNodes.length);
    } else {
      if (typeof child === "function") {
        throw new Error("Unexpected child type passed to DOM Node: function. Did you mean to use a component? To use a component use JSX syntax such as <MyComponent/> it works even with function references. <props.myReference/>");
      }
      throw new Error(`Unexpected child type passed to DOM Node: ${children}`);
    }
  }
}
function processHTMLNode(node, props, cleanUp, extraAttributes, extraEvents) {
  createEventHandlers(node, defaultEvents, props);
  if (extraEvents) {
    createEventHandlers(node, extraEvents, props);
  }
  const dataProps = Object.keys(props).filter((e) => e.includes("-"));
  bindProps(node, defaultAttributes, props, cleanUp, dataProps);
  if (extraAttributes) {
    bindProps(node, extraAttributes, props, cleanUp);
  }
  if (props.style) {
    const result = handleStyle(props.style, cleanUp);
    if (result instanceof DataSource) {
      result.listenAndRepeat((v) => {
        node.setAttribute("style", v);
      }, cleanUp);
    } else {
      node.setAttribute("style", result);
    }
  }
  if (props.class) {
    const result = handleClass(props.class, cleanUp);
    if (result instanceof DataSource) {
      result.listenAndRepeat((v) => {
        node.className = v;
      }, cleanUp);
    } else {
      node.className = result;
    }
  }
}
function createEventHandlers(node, events, props) {
  for (const key in events) {
    if (props[events[key]]) {
      if (props[events[key]] instanceof DataSource) {
        node.addEventListener(key, (e) => props[events[key]].update(e));
      } else if (props[events[key]] instanceof DuplexDataSource) {
        node.addEventListener(key, (e) => props[events[key]].updateDownstream(e));
      } else if (typeof props[events[key]] === "function") {
        node.addEventListener(key, (e) => props[events[key]](e));
      }
    }
  }
}
function bindProps(node, keys, props, cleanUp, dynamicProps) {
  for (const key of keys) {
    if (props[key]) {
      assignStringSourceToAttribute(node, props[key], key, cleanUp);
    }
  }
  if (dynamicProps) {
    for (const key of dynamicProps) {
      if (props[key]) {
        assignStringSourceToAttribute(node, props[key], key, cleanUp);
      }
    }
  }
}
function aurumToHTML(content, syncLifecycle) {
  const rs = createRenderSession();
  const renderedContent = renderInternal(content, rs);
  if (syncLifecycle) {
    syncLifecycle.onAttach(() => rs.attachCalls.forEach((c) => c()));
    syncLifecycle.onDetach(() => rs.sessionToken.cancel());
  }
  return {
    content: renderedContent,
    fireOnAttach: () => rs.attachCalls.forEach((c) => c()),
    dispose: () => rs.sessionToken.cancel()
  };
}
function assignStringSourceToAttribute(node, data, key, cleanUp) {
  if (typeof data === "string") {
    node.setAttribute(key, data);
  } else if (typeof data === "boolean") {
    if (data) {
      node.setAttribute(key, "");
    }
  } else if (data instanceof DataSource || data instanceof DuplexDataSource) {
    if (typeof data.value === "string") {
      node.setAttribute(key, data.value);
    } else if (typeof data.value === "boolean") {
      if (data.value) {
        node.setAttribute(key, "");
      }
    }
    data.transform(dsUnique(), cleanUp).listen((v) => {
      if (typeof v === "string") {
        node.setAttribute(key, v);
      } else if (typeof v === "boolean") {
        if (v) {
          node.setAttribute(key, "");
        } else {
          node.removeAttribute(key);
        }
      }
    });
  } else {
    throw new Error("Attributes only support types boolean, string, number and data sources");
  }
}

// node_modules/aurumjs/prebuilt/esnext/nodes/input.js
var inputEvents = { input: "onInput", change: "onChange" };
var inputProps = [
  "placeholder",
  "readonly",
  "disabled",
  "accept",
  "alt",
  "autocomplete",
  "autofocus",
  "checked",
  "defaultChecked",
  "formAction",
  "formEnctype",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "max",
  "maxLength",
  "min",
  "minLength",
  "pattern",
  "multiple",
  "required",
  "type",
  "step",
  "list"
];
var Input = DomNodeCreator("input", inputProps, inputEvents, (node, props, cleanUp) => {
  const input = node;
  if (props.value) {
    if (props.value instanceof DataSource) {
      props.value.listenAndRepeat((v) => {
        input.value = v ?? "";
      }, cleanUp);
      input.addEventListener("input", () => {
        props.value.update(input.value);
      });
    } else if (props.value instanceof DuplexDataSource) {
      props.value.listenAndRepeat((v) => {
        input.value = v ?? "";
      }, cleanUp);
      input.addEventListener("input", () => {
        props.value.updateUpstream(input.value);
      });
    } else {
      input.value = props.value;
    }
  }
  if (props.checked) {
    if (props.checked instanceof DataSource) {
      props.checked.listenAndRepeat((v) => {
        input.checked = v ?? false;
      }, cleanUp);
      input.addEventListener("change", () => {
        props.checked.update(input.checked);
      });
    } else if (props.checked instanceof DuplexDataSource) {
      props.checked.listenAndRepeat((v) => {
        input.checked = v ?? false;
      }, cleanUp);
      input.addEventListener("change", () => {
        props.checked.updateUpstream(input.checked);
      });
    } else {
      input.checked = props.checked;
    }
  }
});

// node_modules/aurumjs/prebuilt/esnext/nodes/select.js
var selectEvents = { change: "onChange" };
var Select = DomNodeCreator("select", void 0, selectEvents, (node, props, cleanUp) => {
  const select = node;
  if ((props == null ? void 0 : props.value) || (props == null ? void 0 : props.selectedIndex)) {
    if (props.value instanceof DataSource || props.value instanceof DuplexDataSource) {
      const mo = new MutationObserver(() => {
        select.value = props.value.value;
      });
      mo.observe(select, {
        childList: true
      });
      cleanUp.addCancellable(() => {
        mo.disconnect();
      });
    }
    if (props.selectedIndex instanceof DataSource || props.selectedIndex instanceof DuplexDataSource) {
      const mo = new MutationObserver(() => {
        select.selectedIndex = props.selectedIndex.value;
      });
      mo.observe(select, {
        childList: true
      });
      cleanUp.addCancellable(() => {
        mo.disconnect();
      });
    }
    if (props.value instanceof DataSource) {
      props.value.listenAndRepeat((v) => {
        select.value = v;
      }, cleanUp);
      select.addEventListener("change", () => {
        props.value.update(select.value);
      });
    } else if (props.value instanceof DuplexDataSource) {
      props.value.listenAndRepeat((v) => {
        select.value = v;
      }, cleanUp);
      select.addEventListener("change", () => {
        props.value.updateUpstream(select.value);
      });
    } else {
      select.value = props.value;
    }
    if (props == null ? void 0 : props.selectedIndex) {
      if (props.selectedIndex instanceof DataSource) {
        props.selectedIndex.listenAndRepeat((v) => {
          select.selectedIndex = v;
        }, cleanUp);
        select.addEventListener("change", () => {
          props.selectedIndex.update(select.selectedIndex);
        });
      } else if (props.selectedIndex instanceof DuplexDataSource) {
        props.selectedIndex.listenAndRepeat((v) => {
          select.selectedIndex = v;
        }, cleanUp);
        select.addEventListener("change", () => {
          props.selectedIndex.updateUpstream(select.selectedIndex);
        });
      } else {
        select.selectedIndex = props.selectedIndex;
      }
    }
  }
});

// node_modules/aurumjs/prebuilt/esnext/nodes/simple_dom_nodes.js
var Code = DomNodeCreator("code");
var Div = DomNodeCreator("div");
var A = DomNodeCreator("a", ["href", "target", "hreflang", "media", "download", "ping", "referrerpolicy", "rel", "type"]);
var Abbr = DomNodeCreator("abbr");
var Address = DomNodeCreator("address");
var H1 = DomNodeCreator("h1");
var H2 = DomNodeCreator("h2");
var H3 = DomNodeCreator("h3");
var H4 = DomNodeCreator("h4");
var H5 = DomNodeCreator("h5");
var H6 = DomNodeCreator("h6");
var Area = DomNodeCreator("area", [
  "alt",
  "coors",
  "download",
  "href",
  "hreflang",
  "media",
  "rel",
  "shape",
  "target",
  "type",
  "ping",
  "referrerpolicy"
]);
var Article = DomNodeCreator("article");
var Aside = DomNodeCreator("aside");
var Span = DomNodeCreator("span");
var NoScript = DomNodeCreator("noscript");
var Video = DomNodeCreator("video", [
  "controls",
  "autoplay",
  "loop",
  "muted",
  "preload",
  "src",
  "poster",
  "width",
  "height",
  "autopictureinpicture",
  "controlslist",
  "crossorigin",
  "disablepictureinpicture",
  "disableremoteplayback",
  "playsinline"
], {
  canPlay: "onCanPlay",
  canplaythrough: "onCanPlayThrough",
  complete: "onComplete",
  durationchange: "onDurationChange",
  emptied: "onEmptied",
  ended: "onEnded",
  loadeddata: "onLoadedData",
  loadedmetadata: "onLoadedMetadata",
  pause: "onPause",
  play: "onPlay",
  playing: "onPlaying",
  progress: "onProgress",
  ratechange: "onRateChange",
  seeked: "onSeeked",
  seeking: "onSeeking",
  stalled: "onStalled",
  suspend: "onSuspend",
  timeupdate: "onTimeUpdate",
  volumechange: "onVolumeChange",
  waiting: "onWaiting"
});
var Ul = DomNodeCreator("ul");
var Ol = DomNodeCreator("ol");
var Li = DomNodeCreator("li");
var B = DomNodeCreator("b");
var Body = DomNodeCreator("body");
var Title = DomNodeCreator("title");
var Summary = DomNodeCreator("summary");
var THead = DomNodeCreator("thead");
var Template = DomNodeCreator("template");
var Q = DomNodeCreator("q");
var Pre = DomNodeCreator("pre");
var P = DomNodeCreator("p");
var Hr = DomNodeCreator("hr");
var Audio = DomNodeCreator("audio", ["controls", "autoplay", "loop", "muted", "preload", "src", "crossorigin"], {
  audioprocess: "onAudioProcess",
  canplay: "onCanPlay",
  canplaythrough: "onCanPlayThrough",
  complete: "onComplete",
  durationchange: "onDurationChange",
  emptied: "onEmptied",
  ended: "onEnded",
  loadeddata: "onLoadedData",
  loadedmetadata: "onLoadedMetadata",
  pause: "onPause",
  play: "onPlay",
  playing: "onPlaying",
  ratechange: "onRateChange",
  seeked: "onSeeked",
  seeking: "onSeeking",
  stalled: "onStalled",
  suspend: "onSuspend",
  timeupdate: "onTimeUpdate",
  volumechange: "onVolumeChange",
  waiting: "onWaiting"
});
var Br = DomNodeCreator("br");
var Button = DomNodeCreator("button", [
  "disabled",
  "autofocus",
  "form",
  "formaction",
  "formenctype",
  "formmethod",
  "formnovalidate",
  "formtarget",
  "type"
]);
var Canvas = DomNodeCreator("canvas", ["width", "height"]);
var Data = DomNodeCreator("data", ["value"]);
var Details = DomNodeCreator("details");
var Em = DomNodeCreator("em");
var Footer = DomNodeCreator("footer");
var Form = DomNodeCreator("form", ["action", "method", "rel", "enctype", "novalidate", "target", "accept-charset", "autocomplete"]);
var Meta = DomNodeCreator("meta", ["http-equiv", "charset", "content"]);
var Html = DomNodeCreator("html", ["lang", "xmlns"]);
var Head = DomNodeCreator("head");
var Header = DomNodeCreator("header");
var Heading = DomNodeCreator("heading");
var I = DomNodeCreator("i");
var IFrame = DomNodeCreator("iframe", [
  "src",
  "srcdoc",
  "width",
  "height",
  "allow",
  "allowfullscreen",
  "allowpaymentrequest",
  "loading",
  "sandbox",
  "frameborder",
  "csp",
  "referrerpolicy"
]);
var Img = DomNodeCreator("img", [
  "src",
  "alt",
  "width",
  "height",
  "referrerpolicy",
  "sizes",
  "srcset",
  "usemap",
  "crossorigin",
  "decoding",
  "ismap",
  "loading"
]);
var Label = DomNodeCreator("label", ["for"]);
var Link = DomNodeCreator("link", [
  "href",
  "rel",
  "media",
  "as",
  "disabled",
  "type",
  "crossorigin",
  "hreflang",
  "referrerpolicy",
  "sizes",
  "integrity",
  "imagesizes",
  "prefetch"
]);
var Nav = DomNodeCreator("nav");
var Sub = DomNodeCreator("sub");
var Sup = DomNodeCreator("sup");
var Table = DomNodeCreator("table");
var TBody = DomNodeCreator("tbody");
var TFoot = DomNodeCreator("tfoot");
var Col = DomNodeCreator("col", ["span"]);
var Colgroup = DomNodeCreator("colgroup", ["span"]);
var Caption = DomNodeCreator("caption");
var Tr = DomNodeCreator("tr");
var Td = DomNodeCreator("td", ["colspan", "headers", "rowspan"]);
var Th = DomNodeCreator("th", ["scope", "abbr", "colspan", "headers", "rowspan"]);
var Time = DomNodeCreator("time", ["datetime"]);
var Style = DomNodeCreator("style", ["media", "type", "nonce"]);
var Source = DomNodeCreator("source", ["src", "srcset", "media", "sizes", "type"]);
var Track = DomNodeCreator("track", ["src", "srclang", "label", "kind", "default"]);
var Param = DomNodeCreator("param", ["value"]);
var Script = DomNodeCreator("script", [
  "src",
  "async",
  "defer",
  "integrity",
  "nomodule",
  "type",
  "crossorigin",
  "referrerpolicy",
  "text",
  "nonce"
]);
var commonSvgProps = [
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-rendering",
  "cursor",
  "display",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "mask",
  "opacity",
  "pointer-events",
  "shape-rendering",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "transform",
  "vector-effect",
  "visibility"
];
var Svg = DomNodeCreator("svg", [
  "width",
  "height",
  "xmlns",
  "version",
  "x",
  "y",
  "x1",
  "y1",
  "x2",
  "y2",
  "cx",
  "cy",
  "r",
  "rx",
  "ry",
  "d",
  "path",
  "points",
  "viewBox",
  "preserveAspectRatio",
  "xmlns:xlink",
  "xml:space",
  ...commonSvgProps
], void 0, void 0, true);
var Circle = DomNodeCreator("circle", ["cx", "cy", "r", ...commonSvgProps], void 0, void 0, true);
var Ellipse = DomNodeCreator("ellipse", ["cx", "cy", "rx", "ry", ...commonSvgProps], void 0, void 0, true);
var Line = DomNodeCreator("line", ["x1", "y1", "x2", "y2", ...commonSvgProps], void 0, void 0, true);
var Polygon = DomNodeCreator("polygon", ["points", ...commonSvgProps], void 0, void 0, true);
var Polyline = DomNodeCreator("polyline", ["points", ...commonSvgProps], void 0, void 0, true);
var Path = DomNodeCreator("path", ["d", ...commonSvgProps], void 0, void 0, true);
var Rect = DomNodeCreator("rect", ["x", "y", "width", "height", ...commonSvgProps], void 0, void 0, true);
var Text2 = DomNodeCreator("text", ["dx", "dy", "rotate", "textLength", "x", "y", ...commonSvgProps], void 0, void 0, true);
var Tspan = DomNodeCreator("tspan", ["dx", "dy", "rotate", "textLength", "x", "y", ...commonSvgProps], void 0, void 0, true);
var Image = DomNodeCreator("image", ["x", "y", "width", "height", "href", ...commonSvgProps], void 0, void 0, true);
var G = DomNodeCreator("g", [...commonSvgProps], void 0, void 0, true);
var Defs = DomNodeCreator("defs", [...commonSvgProps], void 0, void 0, true);
var Symbol2 = DomNodeCreator("symbol", ["viewBox", "preserveAspectRatio", ...commonSvgProps], void 0, void 0, true);
var Use = DomNodeCreator("use", ["href", "x", "y", "width", "height", ...commonSvgProps], void 0, void 0, true);
var Marker = DomNodeCreator("marker", ["viewBox", "preserveAspectRatio", "refX", "refY", "markerWidth", "markerHeight", "orient", ...commonSvgProps], void 0, void 0, true);
var Mask = DomNodeCreator("mask", ["x", "y", "width", "height", ...commonSvgProps], void 0, void 0, true);
var LinearGradient = DomNodeCreator("linearGradient", ["x1", "y1", "x2", "y2", ...commonSvgProps], void 0, void 0, true);
var RadialGradient = DomNodeCreator("radialGradient", ["cx", "cy", "r", "fx", "fy", "fr", ...commonSvgProps], void 0, void 0, true);
var Stop = DomNodeCreator("stop", ["offset", "stop-color", "stop-opacity", ...commonSvgProps], void 0, void 0, true);
var ClipPath = DomNodeCreator("clipPath", ["clipPathUnits", ...commonSvgProps], void 0, void 0, true);
var ForeignObject = DomNodeCreator("foreignObject", ["x", "y", "width", "height", ...commonSvgProps], void 0, void 0, true);
var Pattern = DomNodeCreator("pattern", ["x", "y", "width", "height", "patternUnits", "patternContentUnits", "patternTransform", "viewBox", "preserveAspectRatio", ...commonSvgProps], void 0, void 0, true);
var Progress = DomNodeCreator("progress", ["max", "value"]);
var Option = DomNodeCreator("option", ["value", "label", "disabled", "selected"]);
var OptGroup = DomNodeCreator("optgroup", ["label", "disabled"]);
var Slot = DomNodeCreator("slot");
var Strong = DomNodeCreator("strong");
var Samp = DomNodeCreator("samp");
var Kbd = DomNodeCreator("kbd");
var Var = DomNodeCreator("var");
var Wbr = DomNodeCreator("wbr");
var Picture = DomNodeCreator("picture");
var Output = DomNodeCreator("output", ["for", "form"]);
var Object2 = DomNodeCreator("object", ["data", "width", "height", "form", "type", "usemap"]);

// node_modules/aurumjs/prebuilt/esnext/nodes/textarea.js
var textAreaEvents = { input: "onInput", change: "onChange" };
var textAreaProps = [
  "placeholder",
  "readonly",
  "disabled",
  "form",
  "cols",
  "rows",
  "wrap",
  "autocomplete",
  "autofocus",
  "max",
  "maxLength",
  "min",
  "spellcheck",
  "minLength",
  "required",
  "type"
];
var TextArea = DomNodeCreator("textArea", textAreaProps, textAreaEvents, (node, props, cleanUp) => {
  const textArea = node;
  if (props.value) {
    if (props.value instanceof DataSource) {
      props.value.listenAndRepeat((v) => {
        textArea.value = v;
      }, cleanUp);
      textArea.addEventListener("input", () => {
        props.value.update(textArea.value);
      });
    } else if (props.value instanceof DuplexDataSource) {
      props.value.listenAndRepeat((v) => {
        textArea.value = v;
      }, cleanUp);
      textArea.addEventListener("input", () => {
        props.value.updateUpstream(textArea.value);
      });
    } else {
      textArea.value = props.value;
    }
  }
});

// node_modules/aurumjs/prebuilt/esnext/utilities/aurum.js
var nodeMap = {
  address: Address,
  kbd: Kbd,
  samp: Samp,
  object: Object2,
  optgroup: OptGroup,
  picture: Picture,
  output: Output,
  param: Param,
  strong: Strong,
  track: Track,
  var: Var,
  wbr: Wbr,
  button: Button,
  code: Code,
  hr: Hr,
  div: Div,
  input: Input,
  li: Li,
  span: Span,
  style: Style,
  ul: Ul,
  p: P,
  img: Img,
  link: Link,
  canvas: Canvas,
  a: A,
  article: Article,
  br: Br,
  form: Form,
  label: Label,
  ol: Ol,
  pre: Pre,
  progress: Progress,
  table: Table,
  td: Td,
  tr: Tr,
  th: Th,
  textarea: TextArea,
  h1: H1,
  h2: H2,
  h3: H3,
  h4: H4,
  h5: H5,
  h6: H6,
  html: Html,
  head: Head,
  header: Header,
  footer: Footer,
  nav: Nav,
  b: B,
  i: I,
  script: Script,
  abbr: Abbr,
  area: Area,
  aside: Aside,
  audio: Audio,
  em: Em,
  heading: Heading,
  iframe: IFrame,
  noscript: NoScript,
  option: Option,
  q: Q,
  select: Select,
  source: Source,
  title: Title,
  video: Video,
  tbody: TBody,
  tfoot: TFoot,
  meta: Meta,
  body: Body,
  thead: THead,
  summary: Summary,
  details: Details,
  sub: Sub,
  sup: Sup,
  svg: Svg,
  data: Data,
  time: Time,
  template: Template,
  slot: Slot,
  col: Col,
  colgroup: Colgroup,
  caption: Caption,
  line: Line,
  rect: Rect,
  defs: Defs,
  g: G,
  text: Text2,
  tspan: Tspan,
  circle: Circle,
  ellipse: Ellipse,
  polygon: Polygon,
  polyline: Polyline,
  path: Path,
  image: Image,
  symbol: Symbol2,
  use: Use,
  stop: Stop,
  lineargradient: LinearGradient,
  radialgradient: RadialGradient,
  clippath: ClipPath,
  pattern: Pattern,
  mask: Mask,
  foreignobject: ForeignObject,
  marker: Marker
};
var Aurum = class _Aurum {
  static rehydrate(aurumRenderable, dom) {
    const target = dom.parentElement;
    dom.remove();
    return _Aurum.attach(aurumRenderable, target);
  }
  static attach(aurumRenderable, dom) {
    const session = createRenderSession();
    const content = renderInternal(aurumRenderable, session);
    if (content instanceof AurumElement) {
      content.attachToDom(dom, dom.childNodes.length);
      session.sessionToken.addCancellable(() => content.dispose());
    } else if (Array.isArray(content)) {
      const root = new ArrayAurumElement(new ArrayDataSource(content), createAPI(session));
      session.sessionToken.addCancellable(() => root.dispose());
      root.attachToDom(dom, dom.childNodes.length);
    } else {
      dom.appendChild(content);
      session.sessionToken.addCancellable(() => {
        if (content.isConnected) {
          dom.removeChild(content);
        }
      });
    }
    for (let i = session.attachCalls.length - 1; i >= 0; i--) {
      session.attachCalls[i]();
    }
    return session.sessionToken;
  }
  /**
   * Fragment works through factory by checking if the node is equal to this function
   */
  static fragment() {
  }
  static factory(node, args, ...innerNodes) {
    if (node === _Aurum.fragment) {
      return innerNodes;
    }
    let name;
    let intrinsic = false;
    if (typeof node === "string") {
      intrinsic = true;
      name = node;
      const type = node;
      node = nodeMap[node];
      if (node === void 0) {
        throw new Error(`Node ${type} does not exist or is not supported`);
      }
    } else {
      name = node.name;
    }
    let model = {
      [aurumElementModelIdentitiy]: true,
      name,
      isIntrinsic: intrinsic,
      factory: node,
      props: args,
      children: innerNodes
    };
    if (args != void 0 && args.decorate != void 0) {
      if (Array.isArray(args.decorate)) {
        for (const decorate of args.decorate) {
          model = decorate(model);
        }
      } else if (typeof args.decorate === "function") {
        model = args.decorate(model);
      } else {
        throw new Error("Decorate must be a function or an array of functions");
      }
    }
    return model;
  }
};

// node_modules/aurumjs/prebuilt/esnext/rendering/webcomponent.js
function Webcomponent(config, logic) {
  customElements.define(config.name, class extends (config.baseClass ?? HTMLElement) {
    constructor() {
      super();
      __publicField(this, "api");
      __publicField(this, "session");
      __publicField(this, "props");
      if (config.observedAttributes === void 0) {
        config.observedAttributes = [];
      }
      this.props = {};
      for (const attr of config.observedAttributes) {
        this.props[attr] = new DataSource();
      }
    }
    static get observedAttributes() {
      return config.observedAttributes;
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue !== newValue) {
        this.props[name].update(newValue);
      }
    }
    connectedCallback() {
      const template = document.createDocumentFragment();
      this.session = createRenderSession();
      this.api = createAPI(this.session);
      const content = logic(this.props, this.api);
      for (const cb of this.session.attachCalls) {
        cb();
      }
      Aurum.attach(content, template);
      this.attachShadow({
        mode: config.shadowRootMode ?? "open",
        delegatesFocus: config.shadowRootDelegatesFocus
      }).appendChild(template);
    }
    disconnectedCallback() {
      this.session.sessionToken.cancel();
    }
  });
  return DomNodeCreator(config.name, config.observedAttributes, void 0, (node, props) => {
    for (const key in props) {
      if (!(key in node.props)) {
        node.props[key] = props[key];
      }
    }
  });
}

// node_modules/aurumjs/prebuilt/esnext/rendering/renderers/string_adapter.js
async function aurumToString(content, config = {}) {
  if (content === void 0 || content === null) {
    return "";
  }
  if (Array.isArray(content)) {
    const result = [];
    for (const item of content) {
      result.push(await aurumToString(item));
    }
    return result.join("");
  }
  if (content instanceof Promise) {
    return aurumToString(await content);
  }
  if (["number", "string", "bigint", "boolean"].includes(typeof content)) {
    return content.toString();
  } else if (content instanceof DataSource) {
    return aurumToString(content.value);
  } else if (content instanceof DuplexDataSource) {
    return aurumToString(content.value);
  } else if (content instanceof ArrayDataSource) {
    return aurumToString(content.getData());
  } else {
    const item = content;
    if (!item.isIntrinsic) {
      return aurumToString(item.factory(item.props, item.children, createAPI({
        attachCalls: [],
        sessionToken: new CancellationToken(),
        tokens: []
      })));
    }
    if (config.tagBlacklist && config.tagBlacklist.includes(item.name)) {
      return "";
    }
    if (config.tagWhitelist && !config.tagWhitelist.includes(item.name)) {
      return "";
    }
    let propString = " ";
    let children = "";
    if (item.children) {
      children = await aurumToString(item.children);
    }
    for (const prop in item.props) {
      if (config.attributeBlacklist && config.attributeBlacklist.includes(prop)) {
        continue;
      }
      if (config.attributeWhitelist && !config.attributeWhitelist.includes(prop)) {
        continue;
      }
      if (item.props[prop] != void 0) {
        propString += `${prop}="${item.props[prop].toString()}" `;
      }
    }
    return `<${item.name}${propString.trimEnd()}>${children}</${item.name}>`;
  }
}

// node_modules/aurumjs/prebuilt/esnext/rendering/renderers/vdom_adapter.js
var VDOM = class {
  constructor(args) {
    __publicField(this, "roots");
    __publicField(this, "onChange");
    __publicField(this, "sessionToken");
    this.roots = args.vdom;
    this.sessionToken = args.sessionToken;
    this.onChange = new EventEmitter();
  }
  *[Symbol.iterator]() {
    for (const node of this.roots) {
      yield* this.iterateVDOM(node, void 0);
    }
  }
  *iterateVDOM(node, parent) {
    if (node.type === "virtual") {
      for (const child of node.children) {
        yield* this.iterateVDOM(child, parent);
      }
      return;
    }
    yield { node, parent };
    if (node.children) {
      for (const child of node.children) {
        yield* this.iterateVDOM(child, node);
      }
    }
  }
};
function aurumToVDOM(content, sessionToken) {
  const root = new VDOM({
    vdom: [],
    sessionToken
  });
  let renderToken = new CancellationToken();
  sessionToken.addCancellable(() => {
    if (renderToken) {
      renderToken.cancel();
    }
  });
  const virtualRoot = {
    type: "virtual",
    children: []
  };
  aurumToVDOMInternal(content, renderToken, root.onChange, virtualRoot);
  root.roots = virtualRoot.children;
  return root;
}
function aurumToVDOMInternal(content, renderToken, change, parent) {
  var _a, _b;
  if (content === void 0 || content === null) {
    return {
      tokens: []
    };
  }
  if (Array.isArray(content)) {
    const result = {
      insertAt: -1,
      insertCount: 0,
      tokens: []
    };
    for (const item of content) {
      const output = aurumToVDOMInternal(item, renderToken, change, parent);
      result.tokens.push(...output.tokens);
    }
    return result;
  }
  if (content instanceof Promise) {
    const virtualNode = {
      type: "virtual",
      children: []
    };
    content.then((c) => {
      aurumToVDOMInternal(c, renderToken, change, virtualNode);
      change.fire({
        changedNode: parent
      });
    });
    parent.children.push(virtualNode);
    return {
      tokens: []
    };
  }
  if (["number", "string", "bigint", "boolean"].includes(typeof content)) {
    parent.children.push({
      type: "text",
      text: content.toString()
    });
    return {
      tokens: []
    };
  } else if (content instanceof DataSource || content instanceof DuplexDataSource) {
    const virtualNode = {
      type: "virtual",
      children: []
    };
    content.listen((v) => {
      virtualNode.children = [];
      insertStats.tokens.forEach((t) => t.cancel());
      insertStats = aurumToVDOMInternal(v, renderToken, change, virtualNode);
      change.fire({
        changedNode: parent
      });
    }, renderToken);
    parent.children.push(virtualNode);
    let insertStats = aurumToVDOMInternal(content.value, renderToken, change, virtualNode);
    return insertStats;
  } else if (content instanceof ArrayDataSource) {
    const virtualNode = {
      type: "virtual",
      children: []
    };
    content.listen(() => {
      virtualNode.children = [];
      insertStats.tokens.forEach((t) => t.cancel());
      insertStats = aurumToVDOMInternal(content.getData(), renderToken, change, virtualNode);
      change.fire({
        changedNode: parent
      });
    }, renderToken);
    parent.children.push(virtualNode);
    let insertStats = aurumToVDOMInternal(content.getData(), renderToken, change, virtualNode);
    return insertStats;
  } else {
    const item = content;
    if (!item.isIntrinsic) {
      const sessionToken = new CancellationToken();
      const session = {
        attachCalls: [],
        sessionToken,
        tokens: []
      };
      const api = createAPI(session);
      renderToken.addCancellable(() => {
        sessionToken.cancel();
      });
      sessionToken.addCancellable(() => {
        for (const token of session.tokens) {
          token.cancel();
        }
      });
      const data = aurumToVDOMInternal(item.factory(item.props, item.children, api), sessionToken, change, parent);
      for (const call of session.attachCalls) {
        call();
      }
      return {
        tokens: [...data.tokens, sessionToken]
      };
    }
    const element = {
      type: "element",
      tag: item.name,
      children: []
    };
    element.attributes = item.props ? observeAttributes(element, item.props, renderToken, change) : void 0;
    parent.children.push(element);
    if ((_a = item.props) == null ? void 0 : _a.onAttach) {
      item.props.onAttach();
    }
    if ((_b = item.props) == null ? void 0 : _b.onDetach) {
      renderToken.addCancellable(() => {
        item.props.onDetach();
      });
    }
    if (item.children) {
      aurumToVDOMInternal(item.children, renderToken, change, element);
    }
    return {
      tokens: []
    };
  }
}
function observeAttributes(node, props, renderToken, change) {
  const result = {};
  for (const key in props) {
    let element;
    if (props.hasOwnProperty(key)) {
      if (key === "style") {
        element = handleStyle(props[key], renderToken);
      } else if (key === "class") {
        element = handleClass(props[key], renderToken);
      } else {
        element = props[key];
      }
      if (element instanceof DataSource) {
        element.listen(() => {
          result[key] = element.value;
          change.fire({
            changedNode: node
          });
        }, renderToken);
        result[key] = element.value;
      } else if (element instanceof DuplexDataSource) {
        element.listen(() => {
          result[key] = element.value;
          change.fire({
            changedNode: node
          });
        }, renderToken);
        result[key] = element.value;
      } else if (element instanceof ArrayDataSource) {
        element.listen(() => {
          result[key] = element.getData().join(";");
          change.fire({
            changedNode: node
          });
        }, renderToken);
        result[key] = element.getData().join(";");
      } else {
        result[key] = element;
      }
    }
  }
  return result;
}

// node_modules/aurumjs/prebuilt/esnext/stream/emitters.js
function intervalEmitter(target, interval, value, cancellationToken) {
  (cancellationToken ?? new CancellationToken()).setInterval(() => {
    updateSource(target, value);
  }, interval);
}
function updateSource(target, value) {
  if (target instanceof ArrayDataSource) {
    target.push(value);
  } else if (target instanceof DuplexDataSource) {
    target.updateDownstream(value);
  } else {
    target.update(value);
  }
}
function urlHashEmitter(target, stripInHashParameters = false, cancellationToken) {
  updateSource(target, stripInHashParameters ? getUrlHash() : location.hash);
  (cancellationToken ?? new CancellationToken()).registerDomEvent(window, "hashchange", () => {
    updateSource(target, stripInHashParameters ? getUrlHash() : location.hash);
  });
}
function getUrlHash() {
  const hash = location.hash.substring(1);
  if (hash.includes("?")) {
    return hash.substring(0, hash.indexOf("?"));
  } else if (hash.includes("#")) {
    return hash.substring(0, hash.indexOf("#"));
  } else {
    return hash;
  }
}
function windowSizeEmitter(target, debounce = 100, cancellationToken) {
  cancellationToken ?? (cancellationToken = new CancellationToken());
  const updateStream = new DataSource();
  cancellationToken.registerDomEvent(window, "resize", () => {
    updateStream.update();
  });
  target.assign({
    width: window.innerWidth,
    height: window.innerHeight
  });
  updateStream.transform(dsDebounce(debounce), dsTap(() => target.assign({
    width: window.innerWidth,
    height: window.innerHeight
  })));
}
function animate(cb, time, cancellationToken) {
  return new Promise((resolve) => {
    const animationToken = new CancellationToken();
    if (cancellationToken) {
      cancellationToken.chain(animationToken);
    }
    animationToken.addCancellable(resolve);
    let start = Date.now();
    registerAnimationLoop(() => {
      const progress = Math.min(1, (Date.now() - start) / time);
      cb(progress);
      if (progress === 1) {
        animationToken.cancel();
      }
    }, animationToken);
  });
}
function tweenEmitter(target, duration, startValue, endValue, interpolation, cancellationToken) {
  if (target instanceof DataSource || target instanceof DuplexDataSource || target instanceof Stream) {
    if (startValue === endValue) {
      return new Promise((res) => setTimeout(res, duration));
    }
  }
  return animate((progress) => {
    if (interpolation) {
      progress = interpolation(progress);
    }
    const value = startValue + (endValue - startValue) * progress;
    if (target instanceof ArrayDataSource) {
      target.push(value);
    } else if (target instanceof DuplexDataSource) {
      target.updateDownstream(value);
    } else {
      target.update(value);
    }
  }, duration, cancellationToken);
}

// node_modules/aurumjs/prebuilt/esnext/utilities/transclusion.js
function resolveChildren(children, cancellationToken, validation) {
  const chunks = process(children);
  const result = ArrayDataSource.fromMultipleSources(chunks, cancellationToken);
  if (validation) {
    result.listen((c) => {
      switch (c.operation) {
        case "add":
        case "replace":
        case "merge":
          for (const item of c.items) {
            validation(item);
          }
          break;
      }
    }, cancellationToken);
  }
  return result;
}
function process(children) {
  const chunks = [];
  let currentChunk = [];
  for (const child of children) {
    if (child instanceof ArrayDataSource) {
      if (currentChunk.length) {
        chunks.push(currentChunk);
        currentChunk.length = 0;
      }
      chunks.push(child);
    } else if (child instanceof DataSource) {
      currentChunk.push(child);
    } else if (child instanceof DataSource) {
      currentChunk.push(child);
    } else if (child instanceof DataSource) {
      currentChunk.push(child);
    } else if (Array.isArray(child)) {
      chunks.push(...process(child));
    } else {
      currentChunk.push(child);
    }
  }
  if (currentChunk.length) {
    chunks.push(currentChunk);
  }
  return chunks;
}

// node_modules/aurumjs/prebuilt/esnext/builtin_components/router.js
function AurumRouter(props, children, api) {
  const resolvedChildren = resolveChildren(children, api.cancellationToken, (c) => {
    if (c.factory !== Route && c.factory !== DefaultRoute) {
      throw new Error("Aurum Router only accepts Route and DefaultRoute instances as children");
    }
  }).filter(Boolean);
  resolvedChildren.reduce((acc, c) => {
    if (c.factory === DefaultRoute) {
      return acc + 1;
    } else {
      return acc;
    }
  }, 0, api.cancellationToken).listenAndRepeat((count) => {
    if (count > 1) {
      throw new Error(`Too many default routes only 0 or 1 allowed. Found ${count}`);
    }
  });
  const urlDataSource = new DataSource();
  if (typeof window !== "undefined") {
    urlHashEmitter(urlDataSource, true, api.cancellationToken);
  }
  const activeRoute = new DataSource();
  activeRoute.transform(dsUnique(), dsDiff(), dsTap(({ newValue, oldValue }) => {
    var _a, _b, _c, _d;
    if (oldValue) {
      (_b = (_a = oldValue.props) == null ? void 0 : _a.onNavigateFrom) == null ? void 0 : _b.call(_a);
    }
    if (newValue) {
      (_d = (_c = newValue.props) == null ? void 0 : _c.onNavigateTo) == null ? void 0 : _d.call(_c);
    }
  }));
  return urlDataSource.transform(dsUnique(), api.cancellationToken).withInitial(urlDataSource.value).transform(dsMap((p) => selectRoute(p, resolvedChildren, activeRoute)));
}
function selectRoute(url, routes, activeRoute) {
  let selected;
  if (url === void 0 || url === null) {
    selected = routes.find((r) => r.factory === DefaultRoute);
  } else {
    if (routes.find((r) => {
      var _a;
      return ((_a = r.props) == null ? void 0 : _a.href) === url;
    })) {
      selected = routes.find((r) => {
        var _a;
        return ((_a = r.props) == null ? void 0 : _a.href) === url;
      });
    } else {
      const segments = url.split("/");
      segments.pop();
      while (segments.length) {
        const path = segments.join("/");
        if (routes.find((r) => {
          var _a;
          return ((_a = r.props) == null ? void 0 : _a.href) === path;
        })) {
          selected = routes.find((r) => {
            var _a;
            return ((_a = r.props) == null ? void 0 : _a.href) === path;
          });
          break;
        }
        segments.pop();
      }
      if (!selected) {
        selected = routes.find((r) => r.factory === DefaultRoute);
      }
    }
  }
  if (selected) {
    activeRoute.update(selected);
    return selected.children;
  } else {
    activeRoute.update(void 0);
    return void 0;
  }
}
function Route(props, children) {
  return void 0;
}
function DefaultRoute(props, children) {
  return void 0;
}

// node_modules/aurumjs/prebuilt/esnext/builtin_components/error_boundary.js
function ErrorBoundary(props, children, api) {
  const data = new DataSource(props == null ? void 0 : props.suspenseFallback);
  const renderFallbackError = typeof (props == null ? void 0 : props.errorFallback) === "function" ? props.errorFallback : (error) => props == null ? void 0 : props.errorFallback;
  const lc = createLifeCycle();
  api.onDetach(() => lc.onDetach());
  function onDone(res) {
    if (!api.cancellationToken.isCancelled) {
      data.update(res);
      lc.onAttach();
    }
  }
  function onError(error) {
    console.error(error);
    if (!api.cancellationToken.isCancelled) {
      data.update(renderFallbackError(error));
    }
  }
  async function handleRenderedChildren(res) {
    if (res instanceof Promise) {
      res.then(handleRenderedChildren, onError);
    } else {
      const nestedRendered = api.prerender(res, lc);
      if (nestedRendered.some((s) => s instanceof Promise)) {
        await Promise.all(nestedRendered).then(handleRenderedChildren, onError);
      } else {
        onDone(nestedRendered);
      }
    }
  }
  async function renderChildren() {
    try {
      const rendered = api.prerender(children, lc);
      await handleRenderedChildren(rendered);
    } catch (error) {
      onError(error);
    }
  }
  renderChildren();
  return data;
}

// node_modules/aurumjs/prebuilt/esnext/builtin_components/suspense.js
function Suspense(props, children, api) {
  return Aurum.factory(ErrorBoundary, { suspenseFallback: props == null ? void 0 : props.fallback, errorFallback: (error) => {
    throw error;
  } }, children);
}

// node_modules/aurumjs/prebuilt/esnext/builtin_components/switch.js
function Switch(props, children, api) {
  children = [].concat.apply([], children.filter((c) => !!c));
  if (children.some((c) => !c[aurumElementModelIdentitiy] || !(c.factory === SwitchCase || c.factory === DefaultSwitchCase))) {
    throw new Error("Switch only accepts SwitchCase as children");
  }
  if (children.filter((c) => c.factory === DefaultSwitchCase).length > 1) {
    throw new Error("Too many default switch cases only 0 or 1 allowed");
  }
  const cleanUp = new CancellationToken();
  api.onDetach(() => {
    cleanUp.cancel();
  });
  const u = props.state.transform(dsUnique(), cleanUp);
  return u.withInitial(props.state.value).transform(dsMap((state) => selectCase(state, children)));
}
function selectCase(state, children) {
  var _a, _b;
  return ((_a = children.find((c) => {
    var _a2;
    return ((_a2 = c.props) == null ? void 0 : _a2.when) === state;
  })) == null ? void 0 : _a.children) ?? ((_b = children.find((p) => p.factory === DefaultSwitchCase)) == null ? void 0 : _b.children);
}
function SwitchCase(props, children) {
  return void 0;
}
function DefaultSwitchCase(props, children) {
  return void 0;
}

// node_modules/aurumjs/prebuilt/esnext/stream/tree_data_source.js
var TreeDataSource = class _TreeDataSource {
  constructor(childrenKey, roots) {
    __publicField(this, "childrenKey");
    __publicField(this, "roots");
    __publicField(this, "updateEvent");
    __publicField(this, "watchCount", 0);
    __publicField(this, "watchToken");
    this.childrenKey = childrenKey;
    this.roots = ArrayDataSource.toArrayDataSource(roots);
    this.updateEvent = new EventEmitter();
  }
  watch(cancellationToken) {
    this.watchCount++;
    cancellationToken.addCancellable(() => {
      this.watchCount--;
      if (this.watchCount === 0) {
        this.watchToken.cancel();
        this.watchToken = void 0;
      }
    });
    if (!this.watchToken) {
      this.watchToken = new CancellationToken();
      const watchMap = /* @__PURE__ */ new Map();
      if (this.roots instanceof ArrayDataSource) {
        this.roots.listen((change) => {
          this.watchHandleChange(change, void 0, watchMap);
        }, this.watchToken);
      }
      for (const root of this.roots) {
        for (const { node } of this.iterateLevelWithMetaData(root, this.roots.length.value)) {
          if (node[this.childrenKey] instanceof ArrayDataSource) {
            watchMap.set(node, new CancellationToken());
            this.watchToken.chain(watchMap.get(node));
            node[this.childrenKey].listenAndRepeat((change) => {
              this.watchHandleChange(change, node, watchMap);
            }, watchMap.get(node));
          }
        }
      }
    }
  }
  watchHandleChange(change, parent, watchMap) {
    var _a;
    switch (change.operation) {
      case "add":
        let i = 0;
        for (const item of change.items) {
          this.updateEvent.fire({
            changedNode: item,
            index: change.index + i++,
            parentNode: parent,
            operation: "added"
          });
          if (item[this.childrenKey] instanceof ArrayDataSource) {
            watchMap.set(item, new CancellationToken());
            this.watchToken.chain(watchMap.get(item));
            item[this.childrenKey].listenAndRepeat((change2) => {
              this.watchHandleChange(change2, item, watchMap);
            }, watchMap.get(item));
          }
        }
        break;
      case "remove":
        let j = 0;
        for (const item of change.items) {
          (_a = watchMap.get(item)) == null ? void 0 : _a.cancel();
          this.updateEvent.fire({
            changedNode: item,
            index: change.index + j++,
            parentNode: parent,
            operation: "deleted"
          });
        }
        break;
      case "merge":
        throw new Error("Not implemented");
      case "replace":
        this.updateEvent.fire({
          changedNode: change.target,
          index: change.index,
          parentNode: parent,
          operation: "deleted"
        });
        this.updateEvent.fire({
          changedNode: change.items[0],
          index: change.index,
          parentNode: parent,
          operation: "added"
        });
        break;
    }
  }
  listen(callback, cancellationToken) {
    this.watch(cancellationToken);
    return this.updateEvent.subscribe(callback, cancellationToken).cancel;
  }
  listenAndRepeat(callback, cancellationToken) {
    for (const { parent, node, index } of this.iterateLevelWithMetaData(this.roots, 0)) {
      callback({
        changedNode: node,
        index,
        parentNode: parent,
        operation: "added"
      });
    }
    return this.listen(callback, cancellationToken);
  }
  adaptNodeList(nodes, token, nodeList = new ArrayDataSource()) {
    const adaptMap = /* @__PURE__ */ new Map();
    nodes.listenAndRepeat((change) => {
      switch (change.operation) {
        case "add":
          for (const item of change.items) {
            this.addItem(adaptMap, token, item, nodeList);
          }
          break;
        case "remove":
          for (const item of change.items) {
            this.removeItem(nodeList, adaptMap, item);
          }
          break;
        case "merge":
          throw new Error("Not implemented");
        case "replace":
          this.removeItem(nodeList, adaptMap, change.target);
          this.addItem(adaptMap, token, change.items[0], nodeList);
          break;
      }
    }, token);
    return nodeList;
  }
  adaptNodeTree(parent, nodes, mapper, newKey, token) {
    nodes = ArrayDataSource.toArrayDataSource(nodes);
    const newRoots = nodes.map(mapper);
    if (parent) {
      parent[newKey] = newRoots;
    }
    nodes.listenAndRepeat((change) => {
      switch (change.operation) {
        case "add":
          let i = change.index;
          for (const item of change.items) {
            this.adaptNodeTree(newRoots.get(i++), item[newKey], mapper, newKey, token);
          }
          break;
        case "merge":
          throw new Error("Not implemented");
        case "replace":
          this.adaptNodeTree(newRoots[change.index], change.items[0][newKey], mapper, newKey, token);
          break;
      }
    }, token);
    return newRoots;
  }
  map(mapper, newKey = this.childrenKey, cancellationToken) {
    return new _TreeDataSource(newKey, this.adaptNodeTree(void 0, this.roots, mapper, newKey, cancellationToken));
  }
  addItem(adaptMap, parentToken, item, nodeList) {
    nodeList.push(item);
    adaptMap.set(item, new CancellationToken());
    parentToken.chain(adaptMap.get(item));
    const list = ArrayDataSource.toArrayDataSource(item[this.childrenKey]);
    this.adaptNodeList(list, adaptMap.get(item), nodeList);
  }
  removeItem(nodeList, adaptMap, item) {
    adaptMap.get(item).cancel();
    nodeList.remove(item);
  }
  createArrayDataSourceOfNodes(cancellationToken) {
    return this.adaptNodeList(this.roots, cancellationToken);
  }
  *[Symbol.iterator]() {
    for (const root of this.roots) {
      yield* this.iterateLevel(root);
    }
    return;
  }
  *iterateWithMetaData() {
    let i = 0;
    for (const root of this.roots) {
      yield* this.iterateLevelWithMetaData(root, this.roots.length.value, void 0, i);
    }
    return;
  }
  *iterateLevelWithMetaData(node, lastIndex, parent, index = 0, level = 0) {
    yield { node, parent, index, level, lastIndex };
    let i = 0;
    for (const child of node[this.childrenKey]) {
      yield* this.iterateLevelWithMetaData(child, getValueOf(node[this.childrenKey].length), node, i++, level + 1);
    }
  }
  *iterateLevel(level) {
    yield level;
    for (const child of level[this.childrenKey]) {
      yield* this.iterateLevel(child);
    }
  }
};

// node_modules/aurumjs/prebuilt/esnext/utilities/url_storage.js
var UrlStorage = class {
  constructor() {
    __publicField(this, "state");
    __publicField(this, "originalReplaceState");
    __publicField(this, "updating", false);
    this.state = {};
    this.observeUrl();
    window.addEventListener("hashchange", () => this.checkUpdate());
    this.checkUpdate();
  }
  observeUrl() {
    this.originalReplaceState = history.replaceState.bind(history);
    history.replaceState = (...args) => {
      this.originalReplaceState.apply(history, args);
      this.checkUpdate();
    };
  }
  get length() {
    return Object.keys(this.state).length;
  }
  clear() {
    this.state = {};
    this.applyStateToUrl();
  }
  getItem(key) {
    return this.state[key];
  }
  key(index) {
    return Object.keys(this.state)[index];
  }
  removeItem(key) {
    delete this.state[key];
    if (!this.updating) {
      this.applyStateToUrl();
    }
  }
  setItem(key, value) {
    this.state[key] = value;
    if (!this.updating) {
      this.applyStateToUrl();
    }
  }
  applyStateToUrl() {
    const url = new URL(location.href);
    for (const param of url.searchParams.entries()) {
      url.searchParams.delete(param[0]);
    }
    for (const key in this.state) {
      url.searchParams.set(key, this.state[key]);
    }
    this.originalReplaceState({}, "", url.href);
  }
  /**
   * For url changes that are not observable such as parent window changes
   */
  refresh() {
    this.checkUpdate();
  }
  checkUpdate() {
    const result = Object.fromEntries(new URL(location.href).searchParams);
    this.updating = true;
    try {
      for (const key in result) {
        if (result[key] !== this.state[key]) {
          this.setItem(key, result[key]);
        }
      }
      for (const key in this.state) {
        if (result[key] === void 0) {
          this.removeItem(key);
        }
      }
    } finally {
      this.updating = false;
    }
  }
};

// node_modules/aurumjs/prebuilt/esnext/utilities/storage_stream.js
var StorageStream = class {
  constructor(storageAPI) {
    __publicField(this, "storageAPI");
    __publicField(this, "onChange");
    __publicField(this, "originalSetItem");
    __publicField(this, "originalRemoveItem");
    this.onChange = new EventEmitter();
    this.storageAPI = storageAPI;
    this.observeStorageAPI(storageAPI);
  }
  observeStorageAPI(storageAPI) {
    this.originalSetItem = storageAPI.setItem.bind(storageAPI);
    storageAPI.setItem = (key, value) => {
      this.originalSetItem(key, value);
      this.onChange.fire({ key, value });
    };
    this.originalRemoveItem = storageAPI.removeItem.bind(storageAPI);
    storageAPI.removeItem = (key) => {
      this.originalRemoveItem(key);
      this.onChange.fire({ key, value: void 0 });
    };
    const originalClear = storageAPI.clear.bind(storageAPI);
    storageAPI.clear = () => {
      originalClear();
      this.onChange.fire({ key: "*", value: void 0 });
    };
  }
  listenAsString(key, defaultValue, cancellationToken) {
    const stream = new DuplexDataSource().withInitial(this.storageAPI.getItem(key) ?? defaultValue);
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.updateDownstream(e.value ?? defaultValue);
      }
    }, cancellationToken);
    stream.listenUpstream((v) => {
      if (v === void 0 || v === defaultValue) {
        this.originalRemoveItem(key);
      } else {
        this.originalSetItem(key, v);
      }
    }, cancellationToken);
    return stream;
  }
  listenAsNumber(key, defaultValue, cancellationToken, radix = 10) {
    const stream = new DuplexDataSource().withInitial(this.storageAPI.getItem(key) ? parseInt(this.storageAPI.getItem(key), radix) : defaultValue);
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.updateDownstream(e.value != void 0 ? parseInt(e.value, radix) : defaultValue);
      }
    }, cancellationToken);
    stream.listenUpstream((v) => {
      if (v === void 0 || v === defaultValue) {
        this.originalRemoveItem(key);
      } else {
        this.originalSetItem(key, v.toString());
      }
    }, cancellationToken);
    return stream;
  }
  listenAsDate(key, defaultValue, cancellationToken) {
    const stream = new DuplexDataSource().withInitial(this.storageAPI.getItem(key) ? new Date(this.storageAPI.getItem(key)) : defaultValue);
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.updateDownstream(e.value != void 0 ? new Date(e.value) : defaultValue);
      }
    }, cancellationToken);
    stream.listenUpstream((v) => {
      if (v === void 0 || v === defaultValue) {
        this.originalRemoveItem(key);
      } else {
        this.originalSetItem(key, v.toJSON());
      }
    }, cancellationToken);
    return stream;
  }
  listenAsBoolean(key, defaultValue, cancellationToken) {
    const stream = new DuplexDataSource().withInitial(this.storageAPI.getItem(key) ? this.storageAPI.getItem(key) === "true" : defaultValue);
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.updateDownstream(e.value != void 0 ? e.value === "true" : defaultValue);
      }
    }, cancellationToken);
    stream.listenUpstream((v) => {
      if (v === void 0 || v === defaultValue) {
        this.originalRemoveItem(key);
      } else {
        this.originalSetItem(key, v.toString());
      }
    }, cancellationToken);
    return stream;
  }
  // Since objects can be mutable a provider can be used to regenerate the object on each use of the default value
  listenAsObject(key, defaultValueOrProvider, cancellationToken) {
    const stream = new DuplexDataSource().withInitial(this.storageAPI.getItem(key) ? JSON.parse(this.storageAPI.getItem(key)) : typeof defaultValueOrProvider === "function" ? defaultValueOrProvider() : defaultValueOrProvider);
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.updateDownstream(e.value != void 0 ? JSON.parse(e.value) : typeof defaultValueOrProvider === "function" ? defaultValueOrProvider() : defaultValueOrProvider);
      }
    }, cancellationToken);
    stream.listenUpstream((v) => {
      if (v === void 0) {
        this.originalRemoveItem(key);
      } else {
        this.originalSetItem(key, JSON.stringify(v));
      }
    }, cancellationToken);
    return stream;
  }
  listenAsEnum(key, defaultValue, cancellationToken) {
    const stream = new DuplexDataSource().withInitial(this.storageAPI.getItem(key) ?? defaultValue);
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.updateDownstream(e.value != void 0 ? e.value : defaultValue);
      }
    }, cancellationToken);
    stream.listenUpstream((v) => {
      if (v === void 0 || v === defaultValue) {
        this.originalRemoveItem(key);
      } else {
        this.originalSetItem(key, v.toString());
      }
    }, cancellationToken);
    return stream;
  }
  listenAsArray(key, cancellationToken) {
    const stream = new ArrayDataSource(JSON.parse(this.storageAPI.getItem(key) ?? "[]"));
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.merge(e.value != void 0 ? JSON.parse(e.value) : []);
      }
    }, cancellationToken);
    stream.listen((v) => {
      this.originalSetItem(key, JSON.stringify(v.newState));
    }, cancellationToken);
    return stream;
  }
  listenAsSet(key, cancellationToken) {
    const stream = new SetDataSource(JSON.parse(this.storageAPI.getItem(key) ?? "[]"));
    this.onChange.subscribe((e) => {
      if (e.key === key || e.key === "*") {
        stream.merge(e.value != void 0 ? JSON.parse(e.value) : []);
      }
    }, cancellationToken);
    stream.listen((v) => {
      this.originalSetItem(key, JSON.stringify(stream.toArray()));
    }, cancellationToken);
    return stream;
  }
};
var localStorageStream;
if (typeof localStorage !== "undefined") {
  localStorageStream = new StorageStream(localStorage);
}
var sessionStorageStream;
if (typeof sessionStorage !== "undefined") {
  sessionStorageStream = new StorageStream(sessionStorage);
}
var urlStorageStream;
if (typeof location !== "undefined") {
  urlStorageStream = new StorageStream(new UrlStorage());
}

// node_modules/aurumjs/prebuilt/esnext/decorators/attach_notifier.js
function attachNotifier(onAttach, onDetach) {
  return function(model) {
    function Wrapper(props, children, api) {
      api.onAttach(() => {
        onAttach == null ? void 0 : onAttach();
      });
      api.onDetach(() => {
        onDetach == null ? void 0 : onDetach();
      });
      return children;
    }
    return Aurum.factory(Wrapper, null, model);
  };
}

export {
  CancellationToken,
  registerAnimationLoop,
  RemoteProtocol,
  getRemoteFunction,
  EventEmitter,
  debugMode,
  enableDebugMode,
  OperationType,
  transformAsyncIterator,
  promiseIterator,
  Stream,
  dsMap,
  dsFork,
  dsMapAsync,
  dsDiff,
  dsUpdateToken,
  dsFilter,
  dsFilterAsync,
  dsEven,
  dsOdd,
  dsMin,
  dsMax,
  dsSkipDynamic,
  dsSkip,
  dsCutOff,
  dsCutOffDynamic,
  dsSemaphore,
  dsUnique,
  dsAwait,
  dsAwaitOrdered,
  dsAwaitLatest,
  dsReduce,
  dsStringJoin,
  dsDelay,
  dsDebounce,
  dsMicroDebounce,
  dsThrottleFrame,
  dsLock,
  dsThrottle,
  dsBuffer,
  dsPick,
  dsPipe,
  dsPipeUp,
  dsHistory,
  dsThroughputMeter,
  dsTap,
  dsLoadBalance,
  dsLog,
  dsPipeAll,
  dsAccumulate,
  DataFlow,
  DataFlowBoth,
  ddsMap,
  ddsDebounce,
  ddsOneWayFlow,
  ddsFilter,
  ddsUnique,
  DuplexDataSource,
  processTransformDuplex,
  ObjectDataSource,
  getValueOf,
  unwrapObjectRecursive,
  DataSource,
  ArrayDataSource,
  FlattenedArrayView,
  MappedArrayView,
  ReversedArrayView,
  SlicedArrayView,
  UniqueArrayView,
  SortedArrayView,
  FilteredArrayView,
  LimitedArrayView,
  processTransform,
  MapDataSource,
  SetDataSource,
  dsCriticalSection,
  dsForkInline,
  aurumClassName,
  combineClass,
  combineAttribute,
  combineStyle,
  camelCaseToKebabCase,
  createRenderSession,
  aurumElementModelIdentitiy,
  createLifeCycle,
  AurumElement,
  createAPI,
  ArrayAurumElement,
  SingularAurumElement,
  aurumToHTML,
  Aurum,
  Webcomponent,
  aurumToString,
  VDOM,
  aurumToVDOM,
  intervalEmitter,
  urlHashEmitter,
  windowSizeEmitter,
  animate,
  tweenEmitter,
  resolveChildren,
  AurumRouter,
  Route,
  DefaultRoute,
  ErrorBoundary,
  Suspense,
  Switch,
  SwitchCase,
  DefaultSwitchCase,
  TreeDataSource,
  UrlStorage,
  StorageStream,
  localStorageStream,
  sessionStorageStream,
  urlStorageStream,
  attachNotifier
};
//# sourceMappingURL=chunk-TFLE55A7.js.map
