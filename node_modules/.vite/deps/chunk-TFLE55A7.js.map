{
  "version": 3,
  "sources": ["../../aurumjs/src/utilities/cancellation_token.ts", "../../aurumjs/src/aurum_server/aurum_server_client.ts", "../../aurumjs/src/utilities/event_emitter.ts", "../../aurumjs/src/debug_mode.ts", "../../aurumjs/src/stream/operator_model.ts", "../../aurumjs/src/utilities/iteration.ts", "../../aurumjs/src/stream/stream.ts", "../../aurumjs/src/stream/data_source_operators.ts", "../../aurumjs/src/stream/duplex_data_source_operators.ts", "../../aurumjs/src/stream/duplex_data_source.ts", "../../aurumjs/src/stream/object_data_source.ts", "../../aurumjs/src/utilities/sources.ts", "../../aurumjs/src/stream/data_source.ts", "../../aurumjs/src/utilities/classname.ts", "../../aurumjs/src/nodes/rendering_helpers.ts", "../../aurumjs/src/rendering/aurum_element.ts", "../../aurumjs/src/rendering/renderers/dom_adapter.ts", "../../aurumjs/src/nodes/input.ts", "../../aurumjs/src/nodes/select.ts", "../../aurumjs/src/nodes/simple_dom_nodes.ts", "../../aurumjs/src/nodes/textarea.ts", "../../aurumjs/src/utilities/aurum.ts", "../../aurumjs/src/rendering/webcomponent.ts", "../../aurumjs/src/rendering/renderers/string_adapter.ts", "../../aurumjs/src/rendering/renderers/vdom_adapter.ts", "../../aurumjs/src/stream/emitters.ts", "../../aurumjs/src/utilities/transclusion.ts", "../../aurumjs/src/builtin_components/router.ts", "../../aurumjs/src/builtin_components/error_boundary.ts", "../../aurumjs/src/builtin_components/suspense.tsx", "../../aurumjs/src/builtin_components/switch.ts", "../../aurumjs/src/stream/tree_data_source.ts", "../../aurumjs/src/utilities/url_storage.ts", "../../aurumjs/src/utilities/storage_stream.ts", "../../aurumjs/src/decorators/attach_notifier.tsx"],
  "sourcesContent": ["import { Delegate, Callback } from './common.js';\n\nexport class CancellationToken {\n    private cancelables: Delegate[];\n    private _isCancelled: boolean;\n\n    public get isCancelled(): boolean {\n        return this._isCancelled;\n    }\n\n    constructor(...cancellables: Delegate[]) {\n        this.cancelables = cancellables ?? [];\n        this._isCancelled = false;\n    }\n\n    public static forever = new CancellationToken();\n\n    public static fromMultiple(tokens: CancellationToken[]): CancellationToken {\n        const result = new CancellationToken();\n\n        for (const token of tokens) {\n            token.chain(result);\n        }\n\n        return result;\n    }\n\n    public hasCancellables(): boolean {\n        return this.cancelables.length > 0;\n    }\n\n    /**\n     * Attaches a new cancelable to this token\n     * @param delegate\n     */\n    public addCancellable(delegate: Delegate): this {\n        this.throwIfCancelled('attempting to add cancellable to token that is already cancelled');\n\n        this.cancelables.push(delegate);\n\n        if (this.cancelables.length === 200) {\n            console.log('potential memory leak: cancellation token has over 200 clean up calls');\n        }\n\n        return this;\n    }\n\n    public removeCancellable(delegate: Delegate): this {\n        this.throwIfCancelled('attempting to remove cancellable from token that is already cancelled');\n\n        const index = this.cancelables.indexOf(delegate);\n        if (index !== -1) {\n            this.cancelables.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    public setTimeout(cb: Delegate, time: number = 0): void {\n        const id = setTimeout(() => {\n            this.removeCancellable(cancelable);\n            cb();\n        }, time);\n        const cancelable = () => clearTimeout(id);\n        this.addCancellable(cancelable);\n    }\n\n    public setInterval(cb: Delegate, time: number): void {\n        const id = setInterval(cb, time);\n        this.addCancellable(() => clearInterval(id));\n    }\n\n    public requestAnimationFrame(cb: Callback<number>): void {\n        const id: number = requestAnimationFrame(() => {\n            this.removeCancellable(cancelable);\n            cb();\n        });\n        const cancelable = () => cancelAnimationFrame(id);\n        this.addCancellable(cancelable);\n    }\n\n    public animationLoop(cb: Callback<number>): void {\n        registerAnimationLoop(cb, this);\n    }\n\n    public throwIfCancelled(msg: string): void {\n        if (this.isCancelled) {\n            throw new Error(msg || 'cancellation token is cancelled');\n        }\n    }\n\n    public chain(target: CancellationToken, twoWays: boolean = false): CancellationToken {\n        const cancelable = () => target.cancel();\n        if (twoWays) {\n            target.chain(this, false);\n        } else {\n            target.addCancellable(() => {\n                if (!this.isCancelled) {\n                    this.removeCancellable(cancelable);\n                }\n            });\n        }\n\n        this.addCancellable(cancelable);\n\n        return this;\n    }\n\n    /**\n     * Registers an event using addEventListener and if you cancel the token the event will be canceled as well\n     */\n    public registerDomEvent(eventEmitter: HTMLElement | Document | Window, event: string, callback: (e: Event) => void): this {\n        (eventEmitter as HTMLElement).addEventListener(event, callback);\n        this.addCancellable(() => eventEmitter.removeEventListener(event, callback));\n\n        return this;\n    }\n\n    /**\n     * Registers an event using on and if you cancel the token the event will be canceled using off as well\n     */\n    public registerEmitterEvent<T>(\n        eventEmitter: { on: (event: string, cb: (e: T) => void) => void; off: (event: string, cb: (e: T) => void) => void },\n        event: string,\n        callback: (e: T) => void\n    ): this {\n        eventEmitter.on(event, callback);\n        this.addCancellable(() => eventEmitter.off(event, callback));\n\n        return this;\n    }\n\n    /**\n     * Cancels everything attached to this token\n     */\n    public cancel(): void {\n        if (this.isCancelled) {\n            return;\n        }\n        this._isCancelled = true;\n        this.cancelables.forEach((c) => c());\n        this.cancelables = undefined;\n    }\n}\n\nconst animationCbs = [];\nlet looping = false;\n\nexport function registerAnimationLoop(callback: (time: number) => void, token: CancellationToken): void {\n    animationCbs.push(callback);\n    token.addCancellable(() => {\n        animationCbs.splice(animationCbs.indexOf(callback), 1);\n    });\n    if (!looping) {\n        looping = true;\n        requestAnimationFrame(loop);\n    }\n}\n\nfunction loop(time: number): void {\n    for (const cb of animationCbs) {\n        try {\n            cb(time);\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    if (animationCbs.length === 0) {\n        looping = false;\n    }\n\n    if (looping) {\n        requestAnimationFrame(loop);\n    }\n}\n\nCancellationToken.forever.addCancellable = () => void 0;\nCancellationToken.forever.cancel = () => {\n    throw new Error('Cannot cancel forever token');\n};\n", "import { ArrayDataSource, CollectionChange, DataSource, MapDataSource, SetDataSource } from '../stream/data_source.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { ObjectDataSource } from '../stream/object_data_source.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\n\nexport enum RemoteProtocol {\n    HEARTBEAT,\n    LISTEN_DATASOURCE,\n    LISTEN_DATASOURCE_ERR,\n    UPDATE_DATASOURCE,\n    UPDATE_DATASOURCE_ERR,\n    CANCEL_DATASOURCE,\n\n    PERFORM_RPC,\n    PERFORM_RPC_ERR,\n    PERFORM_RPC_RESULT,\n    PERFORM_RPC_RESULT_ERR,\n\n    LISTEN_DUPLEX_DATASOURCE_ERR,\n    LISTEN_DUPLEX_DATASOURCE,\n    UPDATE_DUPLEX_DATASOURCE,\n    UPDATE_DUPLEX_DATASOURCE_ERR,\n    CANCEL_DUPLEX_DATASOURCE,\n\n    LISTEN_ARRAY_DATASOURCE,\n    LISTEN_ARRAY_DATASOURCE_ERR,\n    UPDATE_ARRAY_DATASOURCE,\n    UPDATE_ARRAY_DATASOURCE_ERR,\n    CANCEL_ARRAY_DATASOURCE,\n\n    LISTEN_MAP_DATASOURCE,\n    LISTEN_MAP_DATASOURCE_ERR,\n    UPDATE_MAP_DATASOURCE,\n    UPDATE_MAP_DATASOURCE_ERR,\n    CANCEL_MAP_DATASOURCE,\n\n    LISTEN_OBJECT_DATASOURCE,\n    LISTEN_OBJECT_DATASOURCE_ERR,\n    UPDATE_OBJECT_DATASOURCE,\n    UPDATE_OBJECT_DATASOURCE_ERR,\n    CANCEL_OBJECT_DATASOURCE,\n\n    LISTEN_SET_DATASOURCE,\n    LISTEN_SET_DATASOURCE_ERR,\n    UPDATE_SET_DATASOURCE,\n    UPDATE_SET_DATASOURCE_ERR,\n    CANCEL_SET_DATASOURCE\n}\n\nexport interface AurumServerInfo {\n    protocol?: 'wss' | 'ws';\n    host?: string;\n    id: string;\n    authenticationToken?: string;\n}\n\nconst pendingRPCResponses: Map<string, { resolve(value: any); reject(error: any) }> = new Map();\n\nexport function getRemoteFunction<I, O = void>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): (input: I) => Promise<O> {\n    return syncFunction(aurumServerInfo, cancellation);\n}\n\nfunction syncFunction(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): (input: any) => Promise<any> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n\n    return async (input) => {\n        await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n        return new Promise<any>((resolve, reject) => {\n            const client = connections.get(key);\n            if (!client) {\n                throw new Error('Client not connected');\n            }\n            return client.performRPC(input, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation).then(resolve, reject);\n        });\n    };\n}\n\nexport async function syncSetDataSource(source: SetDataSource<any>, aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): Promise<void> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n    connections.get(key).syncSetDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);\n}\n\nexport async function syncObjectDataSource(source: ObjectDataSource<any>, aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): Promise<void> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n    connections.get(key).syncObjectDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);\n}\n\nexport async function syncMapDataSource(source: MapDataSource<any, any>, aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): Promise<void> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n    connections.get(key).syncMapDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);\n}\n\nexport async function syncDataSource(source: DataSource<any>, aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): Promise<void> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n    connections.get(key).syncDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);\n}\n\nfunction makeKey(protocol: 'wss' | 'ws', host: string): string {\n    return `${resolveProtocol(protocol)}://${resolveHost(host)}`;\n}\n\nexport async function syncArrayDataSource(source: ArrayDataSource<any>, aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): Promise<void> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n    connections.get(key).syncArrayDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);\n}\n\nexport async function syncDuplexDataSource(source: DuplexDataSource<any>, aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): Promise<void> {\n    const key = makeKey(aurumServerInfo.protocol, aurumServerInfo.host);\n    await ensureConnection(key, aurumServerInfo.protocol, aurumServerInfo.host);\n    connections.get(key).syncDuplexDataSource(source, aurumServerInfo.id, aurumServerInfo.authenticationToken, cancellation);\n}\n\nconst connections: Map<string, AurumServerClient> = new Map();\nconst pendingConnections = new Map<string, Promise<AurumServerClient>>();\n\nclass AurumServerClient {\n    private masterToken: CancellationToken;\n    private readonly connection: WebSocket;\n    private synchedDataSources: Map<string, Map<string, { source: DataSource<any>; listeners: { source: DataSource<any>; token: CancellationToken }[] }>>;\n    private synchedDuplexDataSources: Map<\n        string,\n        Map<string, { source: DuplexDataSource<any>; listeners: { source: DuplexDataSource<any>; token: CancellationToken }[] }>\n    >;\n    private synchedArrayDataSources: Map<\n        string,\n        Map<string, { source: ArrayDataSource<any>; listeners: { source: ArrayDataSource<any>; token: CancellationToken }[] }>\n    >;\n    private synchedMapDataSources: Map<\n        string,\n        Map<string, { source: MapDataSource<any, any>; listeners: { source: MapDataSource<any, any>; token: CancellationToken }[] }>\n    >;\n    private synchedObjectDataSources: Map<\n        string,\n        Map<string, { source: ObjectDataSource<any>; listeners: { source: ObjectDataSource<any>; token: CancellationToken }[] }>\n    >;\n    private synchedSetDataSources: Map<\n        string,\n        Map<string, { source: SetDataSource<any>; listeners: { source: SetDataSource<any>; token: CancellationToken }[] }>\n    >;\n\n    private constructor(connection: WebSocket) {\n        this.masterToken = new CancellationToken();\n        this.connection = connection;\n        this.synchedDataSources = new Map();\n        this.synchedDuplexDataSources = new Map();\n        this.synchedArrayDataSources = new Map();\n        this.synchedMapDataSources = new Map();\n        this.synchedObjectDataSources = new Map();\n        this.synchedSetDataSources = new Map();\n    }\n\n    public syncDataSource(source: DataSource<any>, id: string, authenticationToken: string, cancellation: CancellationToken): void {\n        this.syncSource(\n            cancellation,\n            id,\n            authenticationToken,\n            source,\n            this.synchedDataSources,\n            RemoteProtocol.LISTEN_DATASOURCE,\n            RemoteProtocol.CANCEL_DATASOURCE\n        );\n    }\n\n    public syncObjectDataSource(source: ObjectDataSource<any>, id: string, authenticationToken: string, cancellation: CancellationToken): void {\n        this.syncSource(\n            cancellation,\n            id,\n            authenticationToken,\n            source,\n            this.synchedObjectDataSources,\n            RemoteProtocol.LISTEN_OBJECT_DATASOURCE,\n            RemoteProtocol.CANCEL_OBJECT_DATASOURCE\n        );\n    }\n\n    public performRPC(input, endpointId: string, authenticationToken: string, cancellation: CancellationToken): Promise<any> {\n        return new Promise((resolve, reject) => {\n            const uuid = Math.random().toString();\n            pendingRPCResponses.set(uuid, { resolve, reject });\n\n            this.connection.send(\n                JSON.stringify({\n                    type: RemoteProtocol.PERFORM_RPC,\n                    token: authenticationToken,\n                    id: endpointId,\n                    value: input,\n                    uuid\n                })\n            );\n        });\n    }\n\n    public syncSetDataSource(source: SetDataSource<any>, id: string, authenticationToken: string, cancellation: CancellationToken): void {\n        this.syncSource(\n            cancellation,\n            id,\n            authenticationToken,\n            source,\n            this.synchedSetDataSources,\n            RemoteProtocol.LISTEN_SET_DATASOURCE,\n            RemoteProtocol.CANCEL_SET_DATASOURCE\n        );\n    }\n\n    public syncMapDataSource(source: MapDataSource<any, any>, id: string, authenticationToken: string, cancellation: CancellationToken): void {\n        this.syncSource(\n            cancellation,\n            id,\n            authenticationToken,\n            source,\n            this.synchedMapDataSources,\n            RemoteProtocol.LISTEN_MAP_DATASOURCE,\n            RemoteProtocol.CANCEL_MAP_DATASOURCE\n        );\n    }\n\n    public syncArrayDataSource(source: ArrayDataSource<any>, id: string, authenticationToken: string, cancellation: CancellationToken): void {\n        this.syncSource(\n            cancellation,\n            id,\n            authenticationToken,\n            source,\n            this.synchedArrayDataSources,\n            RemoteProtocol.LISTEN_ARRAY_DATASOURCE,\n            RemoteProtocol.CANCEL_ARRAY_DATASOURCE\n        );\n    }\n\n    public syncDuplexDataSource(source: DuplexDataSource<any>, id: string, authenticationToken: string, cancellation: CancellationToken): void {\n        this.syncSource(\n            cancellation,\n            id,\n            authenticationToken,\n            source,\n            this.synchedDuplexDataSources,\n            RemoteProtocol.LISTEN_DUPLEX_DATASOURCE,\n            RemoteProtocol.CANCEL_DUPLEX_DATASOURCE\n        );\n\n        source.listenUpstream((v) => {\n            this.connection.send(\n                JSON.stringify({\n                    type: RemoteProtocol.UPDATE_DUPLEX_DATASOURCE,\n                    token: authenticationToken,\n                    value: v,\n                    id\n                })\n            );\n        }, CancellationToken.fromMultiple([cancellation, this.masterToken]));\n    }\n\n    private syncSource(\n        cancellation: CancellationToken,\n        id: string,\n        authenticationToken: string,\n        source: any,\n        syncedSources: Map<string, Map<string, { source: any; listeners: { source: any; token: CancellationToken }[] }>>,\n        listenMessage: RemoteProtocol,\n        cancelMessage: RemoteProtocol\n    ) {\n        cancellation.addCancellable(() => {\n            const listenersByAuth = syncedSources.get(id);\n            const listeners = listenersByAuth.get(authenticationToken);\n            listeners.listeners.splice(listeners.listeners.findIndex((s) => s.source === source));\n            if (listeners.listeners.length === 0) {\n                listenersByAuth.delete(authenticationToken);\n                listeners.source.cancelAll();\n                this.connection.send(\n                    JSON.stringify({\n                        type: cancelMessage,\n                        id,\n                        token: authenticationToken\n                    })\n                );\n            }\n        });\n\n        if (!syncedSources.has(id)) {\n            syncedSources.set(id, new Map());\n        }\n        if (!syncedSources.get(id).has(authenticationToken)) {\n            this.connection.send(\n                JSON.stringify({\n                    type: listenMessage,\n                    id,\n                    token: authenticationToken\n                })\n            );\n            syncedSources.get(id).set(authenticationToken, { source, listeners: [] });\n        }\n        syncedSources.get(id).get(authenticationToken).listeners.push({\n            source,\n            token: cancellation\n        });\n    }\n\n    public static connect(host: string, protocol?: 'ws' | 'wss'): Promise<AurumServerClient> {\n        let pendingToken = new CancellationToken();\n        let started = false;\n        let latency = [0, 0, 0, 0, 0];\n        let cycle = 0;\n        let latencyTs;\n        let lastBeat;\n        return new Promise((resolve, reject) => {\n            protocol = resolveProtocol(protocol);\n            host = resolveHost(host);\n            const connection = new WebSocket(`${protocol}://${host}`);\n            const client = new AurumServerClient(connection);\n            client.masterToken.addCancellable(() => {\n                connections.delete(makeKey(protocol, host));\n            });\n\n            pendingToken.setTimeout(() => {\n                connection.close(4001, 'no response');\n                reject();\n                client.masterToken.cancel();\n            }, 5000);\n\n            connection.addEventListener('message', (m) => {\n                lastBeat = Date.now();\n                try {\n                    const msg = JSON.parse(m.data);\n                    switch (msg.type) {\n                        case RemoteProtocol.HEARTBEAT:\n                            latency[cycle] = Date.now() - latencyTs;\n                            if ((cycle + 1) % latency.length === 0) {\n                                console.log(`AurumServer latency: ${(latency.reduce((p, c) => p + c) / latency.length).toFixed(1)}ms`);\n                                cycle = 0;\n                            } else {\n                                cycle++;\n                            }\n                            break;\n                        case RemoteProtocol.PERFORM_RPC_RESULT_ERR:\n                        case RemoteProtocol.PERFORM_RPC_ERR:\n                            pendingRPCResponses.get(msg.uuid).reject(new Error(msg.error));\n                            pendingRPCResponses.delete(msg.uuid);\n                            break;\n                        case RemoteProtocol.PERFORM_RPC_RESULT:\n                            pendingRPCResponses.get(msg.uuid).resolve(msg.result);\n                            pendingRPCResponses.delete(msg.uuid);\n                            break;\n                        case RemoteProtocol.UPDATE_DATASOURCE:\n                            if (client.synchedDataSources.has(msg.id)) {\n                                const byAuth = client.synchedDataSources.get(msg.id);\n                                for (const dss of byAuth.values()) {\n                                    dss.source.update(msg.value);\n                                }\n                            }\n                            break;\n                        case RemoteProtocol.UPDATE_ARRAY_DATASOURCE:\n                            if (client.synchedArrayDataSources.has(msg.id)) {\n                                const byAuth = client.synchedArrayDataSources.get(msg.id);\n                                for (const dss of byAuth.values()) {\n                                    const change: CollectionChange<any> = msg.change;\n                                    dss.source.applyCollectionChange(change);\n                                }\n                            }\n                            break;\n                        case RemoteProtocol.UPDATE_DUPLEX_DATASOURCE:\n                            if (client.synchedDuplexDataSources.has(msg.id)) {\n                                const byAuth = client.synchedDuplexDataSources.get(msg.id);\n                                for (const dss of byAuth.values()) {\n                                    dss.source.updateDownstream(msg.value);\n                                }\n                            }\n                            break;\n                        case RemoteProtocol.UPDATE_MAP_DATASOURCE:\n                            if (client.synchedMapDataSources.has(msg.id)) {\n                                const byAuth = client.synchedMapDataSources.get(msg.id);\n                                for (const dss of byAuth.values()) {\n                                    dss.source.applyMapChange(msg.change);\n                                }\n                            }\n                            break;\n                    }\n                } catch (e) {\n                    console.warn('Recieved malformed message from server');\n                    console.warn(e);\n                }\n            });\n            connection.addEventListener('error', (e) => {\n                client.masterToken.cancel();\n                reject(e);\n            });\n            connection.addEventListener('open', () => {\n                pendingToken.cancel();\n                pendingToken = undefined;\n                started = true;\n                lastBeat = Date.now();\n                client.masterToken.setInterval(() => {\n                    if (Date.now() - lastBeat > 10000) {\n                        connection.close(4000, 'timeout');\n                        return;\n                    }\n                    latencyTs = Date.now();\n                    connection.send(\n                        JSON.stringify({\n                            type: RemoteProtocol.HEARTBEAT\n                        })\n                    );\n                }, 2500);\n\n                resolve(client);\n            });\n            connection.addEventListener('close', () => {\n                client.masterToken.cancel();\n                if (started) {\n                    ensureConnection(makeKey(protocol, host), protocol, host).then((newClient) => {\n                        newClient.migrate(client);\n                    });\n                } else {\n                    reject();\n                }\n            });\n        });\n    }\n\n    private migrate(client: AurumServerClient) {\n        for (const id of client.synchedDataSources.keys()) {\n            for (const auth of client.synchedDataSources.get(id).keys()) {\n                for (const { source, token } of client.synchedDataSources.get(id).get(auth).listeners) {\n                    this.syncDataSource(source, id, auth, token);\n                }\n            }\n        }\n        for (const id of client.synchedArrayDataSources.keys()) {\n            for (const auth of client.synchedArrayDataSources.get(id).keys()) {\n                for (const { source, token } of client.synchedArrayDataSources.get(id).get(auth).listeners) {\n                    this.syncArrayDataSource(source, id, auth, token);\n                }\n            }\n        }\n        for (const id of client.synchedDuplexDataSources.keys()) {\n            for (const auth of client.synchedDuplexDataSources.get(id).keys()) {\n                for (const { source, token } of client.synchedDuplexDataSources.get(id).get(auth).listeners) {\n                    this.syncDuplexDataSource(source, id, auth, token);\n                }\n            }\n        }\n        for (const id of client.synchedMapDataSources.keys()) {\n            for (const auth of client.synchedMapDataSources.get(id).keys()) {\n                for (const { source, token } of client.synchedMapDataSources.get(id).get(auth).listeners) {\n                    this.syncMapDataSource(source, id, auth, token);\n                }\n            }\n        }\n        for (const id of client.synchedObjectDataSources.keys()) {\n            for (const auth of client.synchedObjectDataSources.get(id).keys()) {\n                for (const { source, token } of client.synchedObjectDataSources.get(id).get(auth).listeners) {\n                    this.syncObjectDataSource(source, id, auth, token);\n                }\n            }\n        }\n        for (const id of client.synchedSetDataSources.keys()) {\n            for (const auth of client.synchedSetDataSources.get(id).keys()) {\n                for (const { source, token } of client.synchedSetDataSources.get(id).get(auth).listeners) {\n                    this.syncSetDataSource(source, id, auth, token);\n                }\n            }\n        }\n\n        this.synchedDataSources = new Map();\n        this.synchedDuplexDataSources = new Map();\n        this.synchedArrayDataSources = new Map();\n        this.synchedMapDataSources = new Map();\n        this.synchedObjectDataSources = new Map();\n        this.synchedSetDataSources = new Map();\n    }\n}\n\nfunction resolveProtocol(protocol: 'ws' | 'wss'): 'ws' | 'wss' {\n    if (!protocol) {\n        if (typeof location === 'undefined') {\n            throw new Error('Protocol is not optional in non browser environments');\n        }\n        if (location.protocol.startsWith('https')) {\n            protocol = 'wss';\n        } else {\n            protocol = 'ws';\n        }\n    }\n    return protocol;\n}\n\nfunction resolveHost(host: string): string {\n    if (!host) {\n        if (typeof location === 'undefined') {\n            throw new Error('Host is not optional in non browser environments');\n        }\n        return location.host;\n    }\n    return host;\n}\n\nasync function ensureConnection(key: string, protocol: 'ws' | 'wss', host: string): Promise<AurumServerClient> {\n    if (connections.has(key)) {\n        return connections.get(key);\n    }\n\n    let backoff = 1000;\n    if (pendingConnections.has(key)) {\n        return pendingConnections.get(key);\n    } else {\n        const pendingConnection = new Promise<AurumServerClient>((resolve) => {\n            async function tryConnect() {\n                const p = AurumServerClient.connect(host, protocol);\n                try {\n                    const client = await p;\n                    connections.set(key, client);\n                    pendingConnections.delete(key);\n                    resolve(client);\n                    backoff = 1000;\n                } catch (e) {\n                    setTimeout(() => {\n                        backoff += 1000;\n                        tryConnect();\n                    }, backoff);\n                }\n            }\n            tryConnect();\n        });\n        pendingConnections.set(key, pendingConnection);\n        return pendingConnection;\n    }\n}\n", "import { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback } from './common.js';\n\n/**\n * @internal\n */\nexport interface EventSubscriptionFacade {\n    cancel(): void;\n}\n\n/**\n * @internal\n */\nexport type EventCallback<T> = (data: T) => void;\n\ninterface EventSubscription<T> {\n    callback: EventCallback<T>;\n}\n\n/**\n * Event emitter is at the core of aurums stream system. It's a basic pub sub style typesafe event system optimized for high update throughput\n */\nexport class EventEmitter<T> {\n    private isFiring: boolean;\n    private onAfterFire: Array<() => void>;\n    /**\n     * Callback that if set is called when all subscriptions are removed\n     */\n    public onEmpty: Callback<void>;\n\n    private static leakWarningThreshold: number;\n\n    /**\n     * Set a number of subscriptions that any event can have at most before emitting warnings. The subscriptions will continue working but the warnings can be used\n     * to track potential subscription memory leaks\n     */\n    public static setSubscriptionLeakWarningThreshold(limit: number) {\n        EventEmitter.leakWarningThreshold = limit;\n    }\n\n    /**\n     * returns the count of subscriptions both one time and regular\n     */\n    public get subscriptions(): number {\n        return this.subscribeChannel.length + this.subscribeOnceChannel.length;\n    }\n\n    private subscribeChannel: EventSubscription<T>[];\n    private subscribeOnceChannel: EventSubscription<T>[];\n\n    constructor() {\n        this.subscribeChannel = [];\n        this.subscribeOnceChannel = [];\n        this.onAfterFire = [];\n    }\n\n    public toAsyncIterator(cancellationToken?: CancellationToken): AsyncIterableIterator<T> {\n        const buffer = new Array<IteratorResult<T>>();\n        let sink: (value: IteratorResult<T>) => void;\n\n        cancellationToken?.addCancellable(() => {\n            if (sink) {\n                sink({\n                    done: true,\n                    value: undefined\n                });\n            } else {\n                buffer.push({\n                    done: true,\n                    value: undefined\n                });\n            }\n        });\n\n        this.subscribe((value) => {\n            if (sink) {\n                sink({\n                    done: false,\n                    value\n                });\n                sink = undefined;\n            } else {\n                buffer.push({\n                    done: false,\n                    value\n                });\n            }\n        }, cancellationToken);\n\n        return {\n            [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n                return this;\n            },\n            async next(): Promise<IteratorResult<T>> {\n                if (buffer.length > 0) {\n                    return buffer.shift();\n                }\n\n                return new Promise<IteratorResult<T>>((resolve) => {\n                    sink = resolve;\n                });\n            }\n        };\n    }\n\n    /**\n     * Subscribe to the event. The callback will be called whenever the event fires an update\n     */\n    public subscribe(callback: EventCallback<T>, cancellationToken?: CancellationToken): EventSubscriptionFacade {\n        const { facade } = this.createSubscription(callback, this.subscribeChannel, cancellationToken);\n        if (EventEmitter.leakWarningThreshold && this.subscribeChannel.length > EventEmitter.leakWarningThreshold) {\n            console.warn(`Observable has ${this.subscribeChannel.length} subscriptions. This could potentially indicate a memory leak`);\n        }\n\n        return facade;\n    }\n\n    /**\n     * Subscribe to the event. The callback will be called when the event next fires an update after which the subscription is cancelled\n     */\n    public subscribeOnce(callback: Callback<T>, cancellationToken?: CancellationToken) {\n        const { facade } = this.createSubscription(callback, this.subscribeOnceChannel, cancellationToken);\n\n        if (EventEmitter.leakWarningThreshold && this.subscribeOnceChannel.length > EventEmitter.leakWarningThreshold) {\n            console.warn(`Observable has ${this.subscribeOnceChannel.length} one time subscriptions. This could potentially indicate a memory leak`);\n        }\n\n        return facade;\n    }\n\n    /**\n     * Whether the event has any subscriptions\n     */\n    public hasSubscriptions(): boolean {\n        return this.subscriptions > 0;\n    }\n\n    /**\n     * Removes all currently active subscriptions. If called in the callback of a subscription will be defered until after the fire event finished\n     */\n    public cancelAll(): void {\n        if (!this.isFiring) {\n            this.subscribeChannel.length = 0;\n            this.subscribeOnceChannel.length = 0;\n            this.onEmpty?.();\n        } else {\n            this.onAfterFire.push(() => {\n                this.subscribeChannel.length = 0;\n                this.subscribeOnceChannel.length = 0;\n                this.onEmpty?.();\n            });\n        }\n    }\n\n    private afterFire() {\n        if (this.onAfterFire.length > 0) {\n            this.onAfterFire.forEach((cb) => cb());\n            this.onAfterFire.length = 0;\n        }\n    }\n\n    /**\n     * Publishes a new value all subscribers will be called\n     * Errors in the callbacks are caught and deferred until after fire finishes before throwing to avoid interrupting the propagation of the event\n     * to all subscribers simply because of one faulty subscriber\n     */\n    public fire(data?: T): void {\n        const length = this.subscribeChannel.length;\n        const lengthOnce = this.subscribeOnceChannel.length;\n        if (length === 0 && lengthOnce === 0) {\n            //Cut some overhead in the case nothing is listening\n            return;\n        }\n\n        this.isFiring = true;\n        let error = undefined;\n\n        for (let i = 0; i < length; i++) {\n            try {\n                this.subscribeChannel[i].callback(data);\n            } catch (e) {\n                error = e;\n                console.error(e);\n            }\n        }\n\n        if (this.subscribeOnceChannel.length > 0) {\n            for (let i = 0; i < lengthOnce; i++) {\n                try {\n                    this.subscribeOnceChannel[i].callback(data);\n                } catch (e) {\n                    error = e;\n                    console.error(e);\n                }\n            }\n            this.subscribeOnceChannel.length = 0;\n        }\n\n        this.isFiring = false;\n        this.afterFire();\n\n        if (error) {\n            throw error;\n        }\n    }\n\n    private createSubscription(\n        callback: EventCallback<T>,\n        channel: EventSubscription<T>[],\n        cancellationToken?: CancellationToken\n    ): { subscription: EventSubscription<T>; facade: EventSubscriptionFacade } {\n        const that: this = this;\n\n        const subscription: EventSubscription<T> = {\n            callback\n        };\n\n        const facade: EventSubscriptionFacade = {\n            cancel() {\n                that.cancel(subscription, channel);\n            }\n        };\n\n        if (cancellationToken !== undefined) {\n            cancellationToken.addCancellable(() => that.cancel(subscription, channel));\n        }\n        if (this.isFiring) {\n            this.onAfterFire.push(() => channel.push(subscription));\n        } else {\n            channel.push(subscription);\n        }\n\n        return { subscription, facade };\n    }\n\n    private cancel(subscription: EventSubscription<T>, channel: EventSubscription<T>[]): void {\n        let index: number = channel.indexOf(subscription);\n        if (index >= 0) {\n            if (!this.isFiring) {\n                channel.splice(index, 1);\n                if (!this.hasSubscriptions()) {\n                    this.onEmpty?.();\n                }\n            } else {\n                this.onAfterFire.push(() => this.cancel(subscription, channel));\n            }\n        }\n    }\n}\n", "import { DataSource } from './stream/data_source.js';\nimport { EventEmitter } from './utilities/event_emitter.js';\n\nexport let debugMode: boolean = false;\n\nconst customWindow: Window & {\n    __debugUpdates: EventEmitter<{\n        source: SerializedStreamData;\n        newValue: any;\n        stack: string;\n    }>;\n    __debugNewSource: EventEmitter<{\n        source: SerializedStreamData;\n    }>;\n    __debugLinked: EventEmitter<{\n        parent: SerializedStreamData;\n        child: SerializedStreamData;\n    }>;\n    __debugUnlinked: EventEmitter<{\n        parent: SerializedStreamData;\n        child: SerializedStreamData;\n    }>;\n    __debugGetStreamData: () => SerializedStreamData[];\n} = globalThis as any;\n\nlet debugStreamData;\n\n/**\n * Initializes the debug features of aurum. Required for the use of aurum devtools\n * Run this function before creating any streams or any aurum components for best results\n * Enabling this harms performance and breaks backwards compatibility with some browsers\n * Do not enable in production\n */\nexport function enableDebugMode(): void {\n    debugStreamData = [];\n    debugMode = true;\n    setInterval(() => garbageCollect(), 60000);\n    customWindow.__debugUpdates = new EventEmitter();\n    customWindow.__debugNewSource = new EventEmitter();\n    customWindow.__debugLinked = new EventEmitter();\n    customWindow.__debugUnlinked = new EventEmitter();\n    customWindow.__debugGetStreamData = () => debugStreamData.map(serializeStreamData);\n}\n\nfunction serializeStreamData(ref: StreamData): SerializedStreamData {\n    let serializedValue: string;\n\n    try {\n        serializedValue = JSON.stringify(ref.value);\n    } catch (e) {\n        serializedValue = '[Unserializable]';\n    }\n\n    return {\n        name: ref.name,\n        value: serializedValue,\n        children: ref.children,\n        consumers: ref.consumers,\n        id: ref.id,\n        parents: ref.parents,\n        stack: ref.stack,\n        timestamp: ref.timestamp\n    };\n}\n\nexport function debugRegisterStream(stream: DataSource<any>, stack: string) {\n    const ref: StreamData = {\n        name: stream.name,\n        value: stream.value,\n        id: Math.random(),\n        children: [],\n        parents: [],\n        stack,\n        timestamp: Date.now(),\n        reference: new WeakRef(stream),\n        consumers: []\n    };\n    debugStreamData.push(ref);\n    customWindow.__debugNewSource.fire({\n        source: serializeStreamData(ref)\n    });\n}\n\nexport function debugRegisterLink(parent: DataSource<any>, child: DataSource<any>) {\n    let pref = findDataByRef(parent);\n    let cref = findDataByRef(child);\n\n    if (!pref) {\n        throw new Error('illegal state');\n    }\n    if (!cref) {\n        throw new Error('illegal state');\n    }\n\n    pref.children.push(cref.id);\n    cref.parents.push(pref.id);\n    customWindow.__debugLinked.fire({\n        child: serializeStreamData(cref),\n        parent: serializeStreamData(pref)\n    });\n}\n\nexport function debugRegisterUnlink(parent: DataSource<any>, child: DataSource<any>) {\n    let pref = findDataByRef(parent);\n    let cref = findDataByRef(child);\n\n    if (!pref) {\n        throw new Error('illegal state');\n    }\n    if (!cref) {\n        throw new Error('illegal state');\n    }\n\n    const cindex = pref.children.indexOf(cref.id);\n    if (cindex === -1) {\n        throw new Error('illegal state');\n    }\n    pref.children.splice(cindex, 1);\n\n    const pindex = cref.parents.indexOf(pref.id);\n    if (pindex === -1) {\n        throw new Error('illegal state');\n    }\n    cref.parents.splice(cindex, 1);\n\n    customWindow.__debugUnlinked.fire({\n        child: serializeStreamData(cref),\n        parent: serializeStreamData(pref)\n    });\n}\n\nexport function debugDeclareUpdate(source: DataSource<any>, value: any, stack: string): void {\n    let ref = findDataByRef(source);\n    if (!ref) {\n        throw new Error('illegal state');\n    }\n\n    ref.value = source.value;\n    customWindow.__debugUpdates.fire({\n        newValue: value,\n        source: serializeStreamData(ref),\n        stack\n    });\n}\n\nexport function debugRegisterConsumer(stream: DataSource<any>, consumer: string, consumerStack: string) {\n    let ref = findDataByRef(stream);\n\n    if (!ref) {\n        throw new Error('illegal state');\n    }\n\n    ref.consumers.push({\n        code: consumer,\n        stack: consumerStack\n    });\n}\n\nfunction garbageCollect(): void {\n    debugStreamData = debugStreamData.filter((dsd) => dsd.reference.deref() !== undefined);\n}\n\nfunction findDataByRef(target: DataSource<any>): StreamData {\n    return debugStreamData.find((dsd) => dsd.reference.deref() === target);\n}\n\nexport type SerializedStreamData = Omit<StreamData, 'reference'>;\nexport interface StreamData {\n    name: string;\n    id: number;\n    value: any;\n    reference: WeakRef<DataSource<any>>;\n    parents: number[];\n    stack: string;\n    timestamp: number;\n    children: number[];\n    consumers: {\n        code: string;\n        stack: string;\n    }[];\n}\n\ndeclare class WeakRef<T> {\n    constructor(item: T);\n    public deref(): T | undefined;\n}\n", "export enum OperationType {\n    FILTER,\n    NOOP,\n    MAP,\n    DELAY,\n    MAP_DELAY,\n    DELAY_FILTER,\n    MAP_DELAY_FILTER\n}\n\ninterface SourceOperator {\n    operationType: OperationType;\n    name: string;\n}\n\nexport interface DataSourceOperator<T, M> extends SourceOperator {\n    //Inference only works if the types are used despite the fact that the generic types are only used to indicate what type goes in and what type comes out which cannot be described in a way that typescript understands\n    typescriptLimitationWorkaround?: (value: T) => M;\n}\n\nexport interface DuplexDataSourceOperator<T, M> extends SourceOperator {\n    //Inference only works if the types are used despite the fact that the generic types are only used to indicate what type goes in and what type comes out which cannot be described in a way that typescript understands\n    typescriptLimitationWorkaround?: (value: T) => M;\n}\n\nexport interface DataSourceFilterOperator<T> extends DataSourceOperator<T, T> {\n    operationType: OperationType.FILTER;\n    operation: (value: T) => boolean;\n}\n\nexport interface DuplexDataSourceFilterOperator<T> extends DuplexDataSourceOperator<T, T> {\n    operationType: OperationType.FILTER;\n    operationDown: (value: T) => boolean;\n    operationUp: (value: T) => boolean;\n}\n\nexport interface DuplexDataSourceMapOperator<T, M> extends DuplexDataSourceOperator<T, M> {\n    operationType: OperationType.MAP;\n    operationDown: (value: T) => M;\n    operationUp: (value: M) => T;\n}\n\nexport interface DataSourceMapOperator<T, M> extends DataSourceOperator<T, M> {\n    operationType: OperationType.MAP;\n    operation: (value: T) => M;\n}\n\nexport interface DataSourceNoopOperator<T> extends DataSourceOperator<T, T> {\n    operationType: OperationType.NOOP;\n    operation: (value: T) => T;\n}\n\nexport interface DataSourceDelayOperator<T> extends DataSourceOperator<T, T> {\n    operationType: OperationType.DELAY;\n    operation: (value: T) => Promise<T>;\n}\n\nexport interface DataSourceMapDelayOperator<T, M> extends DataSourceOperator<T, M> {\n    operationType: OperationType.MAP_DELAY;\n    operation: (value: T) => Promise<M>;\n}\n\nexport interface DataSourceMapDelayFilterOperator<T, M> extends DataSourceOperator<T, M> {\n    operationType: OperationType.MAP_DELAY_FILTER;\n    operation: (value: T) => Promise<{ item: M; cancelled: boolean }>;\n}\n\nexport interface DuplexDataSourceMapDelayFilterOperator<T, M> extends DuplexDataSourceOperator<T, M> {\n    operationType: OperationType.MAP_DELAY_FILTER;\n    operationDown: (value: T) => Promise<{ item: M; cancelled: boolean }>;\n    operationUp: (value: T) => Promise<{ item: M; cancelled: boolean }>;\n}\n\nexport interface DataSourceDelayFilterOperator<T> extends DataSourceOperator<T, T> {\n    operationType: OperationType.DELAY_FILTER;\n    operation: (value: T) => Promise<boolean>;\n}\n\nexport interface DuplexDataSourceDelayFilterOperator<T> extends DuplexDataSourceOperator<T, T> {\n    operationType: OperationType.DELAY_FILTER;\n    operationDown: (value: T) => Promise<boolean>;\n    operationUp: (value: T) => Promise<boolean>;\n}\n", "import { DataSource } from '../stream/data_source.js';\nimport {\n    DataSourceDelayFilterOperator,\n    DataSourceFilterOperator,\n    DataSourceMapDelayFilterOperator,\n    DataSourceMapOperator,\n    DataSourceOperator,\n    OperationType\n} from '../stream/operator_model.js';\nimport { CancellationToken } from './cancellation_token.js';\n\nconst FILTERED = Symbol('filtered');\nexport async function* transformAsyncIterator<T, A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n    asyncIterator: AsyncGenerator<T>,\n    operationA: DataSourceOperator<T, A>,\n    operationB?: DataSourceOperator<A, B> | CancellationToken,\n    operationC?: DataSourceOperator<B, C> | CancellationToken,\n    operationD?: DataSourceOperator<C, D> | CancellationToken,\n    operationE?: DataSourceOperator<D, E> | CancellationToken,\n    operationF?: DataSourceOperator<E, F> | CancellationToken,\n    operationG?: DataSourceOperator<F, G> | CancellationToken,\n    operationH?: DataSourceOperator<G, H> | CancellationToken,\n    operationI?: DataSourceOperator<H, I> | CancellationToken,\n    operationJ?: DataSourceOperator<I, J> | CancellationToken,\n    operationK?: DataSourceOperator<J, K> | CancellationToken,\n    cancellationToken?: CancellationToken\n): AsyncGenerator<K> {\n    let token: CancellationToken;\n    const operations: DataSourceOperator<any, any>[] = [\n        operationA,\n        operationB,\n        operationC,\n        operationD,\n        operationE,\n        operationF,\n        operationG,\n        operationH,\n        operationI,\n        operationJ,\n        operationK\n    ].filter((e) => e && (e instanceof CancellationToken ? ((token = e), false) : true)) as DataSourceOperator<any, any>[];\n    if (cancellationToken) {\n        token = cancellationToken;\n    }\n\n    const transform = async (v: any) => {\n        try {\n            for (const operation of operations) {\n                switch (operation.operationType) {\n                    case OperationType.NOOP:\n                    case OperationType.MAP:\n                        v = (operation as DataSourceMapOperator<any, any>).operation(v);\n                        break;\n                    case OperationType.MAP_DELAY_FILTER:\n                        const tmp = await (operation as DataSourceMapDelayFilterOperator<any, any>).operation(v);\n                        if (tmp.cancelled) {\n                            return;\n                        } else {\n                            v = await tmp.item;\n                        }\n                        break;\n                    case OperationType.DELAY:\n                    case OperationType.MAP_DELAY:\n                        v = await (operation as DataSourceMapOperator<any, any>).operation(v);\n                        break;\n                    case OperationType.DELAY_FILTER:\n                        if (!(await (operation as DataSourceDelayFilterOperator<any>).operation(v))) {\n                            return FILTERED;\n                        }\n                        break;\n                    case OperationType.FILTER:\n                        if (!(operation as DataSourceFilterOperator<any>).operation(v)) {\n                            return FILTERED;\n                        }\n                        break;\n                }\n            }\n\n            return v;\n        } catch (e) {\n            throw e;\n        }\n    };\n\n    for await (const v of asyncIterator) {\n        if (token?.isCancelled) {\n            return;\n        }\n        const i = await transform(v);\n        if (i !== FILTERED) {\n            yield i;\n        }\n    }\n\n    return;\n}\n\nexport function promiseIterator<T>(promises: Promise<T>[], cancellation?: CancellationToken): AsyncIterableIterator<PromiseSettledResult<T>> {\n    let pendingCount = promises.length;\n    const output = new DataSource<PromiseSettledResult<T>>();\n    cancellation = cancellation ?? new CancellationToken();\n\n    for (const promise of promises) {\n        promise.then(\n            (v) => {\n                pendingCount--;\n\n                output.update({\n                    status: 'fulfilled',\n                    value: v\n                });\n\n                if (pendingCount === 0) {\n                    cancellation.cancel();\n                }\n            },\n            (e) => {\n                pendingCount--;\n                output.update({\n                    status: 'rejected',\n                    reason: e\n                });\n                if (pendingCount === 0) {\n                    cancellation.cancel();\n                }\n            }\n        );\n    }\n\n    return output.toAsyncIterator(cancellation);\n}\n", "import { DataSourceOperator } from './operator_model.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback } from '../utilities/common.js';\nimport { DataSource, processTransform, ReadOnlyDataSource } from './data_source.js';\n\n/**\n * Lets you logically combine 2 data sources so that update calls go through the input source and listen goes to the output source\n */\nexport class Stream<I, O = I> {\n    private input: DataSource<I>;\n    private output: DataSource<O>;\n    public get name(): string {\n        return `IN:${this.input.name} OUT:${this.output.name}`;\n    }\n    /**\n     * The current value of this data source, can be changed through update\n     */\n    public get value(): O {\n        return this.output.value;\n    }\n\n    private constructor() {}\n\n    public static fromFunction<I, O>(func: (value: I) => O): Stream<I, O> {\n        const result = new Stream<I, O>();\n        result.input = new DataSource<I>();\n        result.output = new DataSource<O>();\n\n        result.input.listen((value) => {\n            result.output.update(func(value));\n        });\n\n        return result;\n    }\n\n    public static fromFetchRaw(url: string): Stream<void | RequestInit, Promise<Response>> {\n        const input = new DataSource<void | RequestInit>();\n        const output = new DataSource<Promise<Response>>();\n\n        input.listen((value) => {\n            output.update(fetch(url, value as RequestInit));\n        });\n\n        return Stream.fromPreconnectedSources(input, output);\n    }\n\n    public static fromPreconnectedSources<I, O>(inputSource?: DataSource<I>, outputSource?: DataSource<O>): Stream<I, O> {\n        const result = new Stream<I, O>();\n        result.input = inputSource ?? new DataSource();\n        result.output = outputSource ?? (result.input as any);\n\n        return result;\n    }\n\n    /**\n     * Combines two sources into a third source that listens to updates from both parent sources.\n     * @param otherSource Second parent for the new source\n     * @param combinator Method allowing you to combine the data from both parents on update. Called each time a parent is updated with the latest values of both parents\n     * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources\n     */\n    public aggregate<R, A>(otherSources: [ReadOnlyDataSource<A>], combinator: (self: O, other: A) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    public aggregate<R, A, B>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>],\n        combinator: (self: O, second: A, third: B) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>],\n        combinator: (self: O, second: A, third: B, fourth: C) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D, sixth: E) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>\n        ],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>\n        ],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H, I>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H, I>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>,\n            ReadOnlyDataSource<I>\n        ],\n        combinator: (self: O, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H, tenth: I) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R>(otherSources: ReadOnlyDataSource<any>[], combinator: (...data: any[]) => R, cancellationToken?: CancellationToken): DataSource<R> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n\n        const aggregatedSource = new DataSource<R>(combinator(this.value, ...otherSources.map((s) => s.value)));\n\n        for (let i = 0; i < otherSources.length; i++) {\n            otherSources[i].listen(() => {\n                aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s.value)));\n            }, cancellationToken);\n        }\n\n        this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s.value))), cancellationToken);\n\n        return aggregatedSource;\n    }\n\n    public static fromStreamTransformation<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, Z = H, J = Z, K = J>(\n        operationA?: DataSourceOperator<A, B>,\n        operationB?: DataSourceOperator<B, C>,\n        operationC?: DataSourceOperator<C, D>,\n        operationD?: DataSourceOperator<D, E>,\n        operationE?: DataSourceOperator<E, F>,\n        operationF?: DataSourceOperator<F, G>,\n        operationG?: DataSourceOperator<G, H>,\n        operationH?: DataSourceOperator<H, Z>,\n        operationI?: DataSourceOperator<Z, J>,\n        operationJ?: DataSourceOperator<J, K>\n    ): Stream<A, K> {\n        const result = new Stream<A, K>();\n\n        result.input = new DataSource<A>();\n        result.output = result.input.transform(\n            operationA,\n            operationB,\n            operationC,\n            operationD,\n            operationE,\n            operationF,\n            operationG,\n            operationH,\n            operationI,\n            operationJ\n        );\n\n        return result;\n    }\n\n    public static fromFetchPostJson<I, O>(url: string, baseRequestData?: RequestInit): Stream<I, O> {\n        const input = new DataSource<I>();\n        const output = new DataSource<O>();\n\n        input.listen(async (value) => {\n            output.update(\n                await fetch(\n                    url,\n                    Object.assign(\n                        {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            }\n                        } as RequestInit,\n                        baseRequestData,\n                        {\n                            body: JSON.stringify(value)\n                        } as RequestInit\n                    )\n                ).then((s) => s.json())\n            );\n        });\n\n        return Stream.fromPreconnectedSources(input, output);\n    }\n\n    public static fromFetchGetJson<O>(url: string, baseRequestData?: RequestInit): Stream<void, O> {\n        const input = new DataSource<void>();\n        const output = new DataSource<O>();\n\n        input.listen(async () => {\n            output.update(await fetch(url).then((s) => s.json()));\n        });\n\n        return Stream.fromPreconnectedSources(input, output);\n    }\n\n    public update(data: I): void {\n        this.input.update(data);\n    }\n\n    public transform<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, Z = H, J = Z, K = J>(\n        operationA: DataSourceOperator<O, A>,\n        operationB?: DataSourceOperator<A, B> | CancellationToken,\n        operationC?: DataSourceOperator<B, C> | CancellationToken,\n        operationD?: DataSourceOperator<C, D> | CancellationToken,\n        operationE?: DataSourceOperator<D, E> | CancellationToken,\n        operationF?: DataSourceOperator<E, F> | CancellationToken,\n        operationG?: DataSourceOperator<F, G> | CancellationToken,\n        operationH?: DataSourceOperator<G, H> | CancellationToken,\n        operationI?: DataSourceOperator<H, Z> | CancellationToken,\n        operationJ?: DataSourceOperator<Z, J> | CancellationToken,\n        operationK?: DataSourceOperator<J, K> | CancellationToken,\n        cancellationToken?: CancellationToken\n    ): Stream<I, K> {\n        let token;\n        const operations: DataSourceOperator<any, any>[] = [\n            operationA,\n            operationB,\n            operationC,\n            operationD,\n            operationE,\n            operationF,\n            operationG,\n            operationH,\n            operationI,\n            operationJ,\n            operationK\n        ].filter((e) => e && (e instanceof CancellationToken ? ((token = e), false) : true)) as DataSourceOperator<any, any>[];\n        if (cancellationToken) {\n            token = cancellationToken;\n        }\n        const result = new DataSource<K>(undefined, this.output.name + ' ' + operations.map((v) => v.name).join(' '));\n        this.listen(processTransform<O, K>(operations as any, result), token);\n\n        return Stream.fromPreconnectedSources(this.input, result);\n    }\n\n    public getInput(): DataSource<I> {\n        return this.input;\n    }\n\n    public getOutput(): DataSource<O> {\n        return this.output;\n    }\n\n    public listen(callback: Callback<O>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.output.listen(callback, cancellationToken);\n    }\n\n    public listenAndRepeat(callback: Callback<O>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.output.listenAndRepeat(callback, cancellationToken);\n    }\n\n    public listenOnce(callback: Callback<O>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.output.listenOnce(callback, cancellationToken);\n    }\n\n    public awaitNextUpdate(cancellationToken?: CancellationToken): Promise<O> {\n        return this.output.awaitNextUpdate(cancellationToken);\n    }\n\n    public cancelAll(): void {\n        this.input.cancelAll();\n        this.output.cancelAll();\n    }\n}\n", "import { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback, ThenArg } from '../utilities/common.js';\nimport { EventEmitter } from '../utilities/event_emitter.js';\nimport { ArrayDataSource, DataSource } from './data_source.js';\nimport { DuplexDataSource } from './duplex_data_source.js';\nimport {\n    DataSourceDelayFilterOperator,\n    DataSourceDelayOperator,\n    DataSourceFilterOperator,\n    DataSourceMapDelayFilterOperator,\n    DataSourceMapDelayOperator,\n    DataSourceMapOperator,\n    DataSourceNoopOperator,\n    OperationType\n} from './operator_model.js';\nimport { Stream } from './stream.js';\n\n/**\n * Mutates an update\n */\nexport function dsMap<T, M>(mapper: (value: T) => M): DataSourceMapOperator<T, M> {\n    return {\n        name: 'map',\n        operationType: OperationType.MAP,\n        operation: (v) => mapper(v)\n    };\n}\n\n/**\n * Forwards an update to one of two possible sources based on a condition\n */\nexport function dsFork<T>(\n    condition: (value: T) => boolean,\n    truthyPath: { update(value: T): void },\n    falsyPath: { update(value: T): void }\n): DataSourceNoopOperator<T> {\n    return {\n        name: 'fork',\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            if (condition(v)) {\n                truthyPath.update(v);\n            } else {\n                falsyPath.update(v);\n            }\n            return v;\n        }\n    };\n}\n\n/**\n * Same as map but with an async mapper function\n */\nexport function dsMapAsync<T, M>(mapper: (value: T) => Promise<M>): DataSourceMapDelayOperator<T, M> {\n    return {\n        name: 'mapAsync',\n        operationType: OperationType.MAP_DELAY,\n        operation: (v) => mapper(v)\n    };\n}\n\n/**\n * Changes updates to contain the value of the previous update as well as the current\n */\nexport function dsDiff<T>(): DataSourceMapOperator<T, { newValue: T; oldValue: T }> {\n    let lastValue = undefined;\n    return {\n        name: 'diff',\n        operationType: OperationType.MAP,\n        operation: (v) => {\n            let result = {\n                oldValue: lastValue,\n                newValue: v\n            };\n            lastValue = v;\n            return result;\n        }\n    };\n}\n\n/**\n * Changes updates to contain the value of the previous update as well as the current\n */\nexport function dsUpdateToken<T>(): DataSourceMapOperator<T, { value: T; token: CancellationToken }> {\n    let token: CancellationToken;\n    return {\n        name: 'diff',\n        operationType: OperationType.MAP,\n        operation: (v) => {\n            if (token) {\n                token.cancel();\n            }\n            token = new CancellationToken();\n            return {\n                token,\n                value: v\n            };\n        }\n    };\n}\n\n/**\n * Blocks updates that don't pass the filter predicate\n */\nexport function dsFilter<T>(predicate: (value: T) => boolean): DataSourceFilterOperator<T> {\n    return {\n        name: 'filter',\n        operationType: OperationType.FILTER,\n        operation: (v) => predicate(v)\n    };\n}\n\n/**\n * Same as filter but with an async predicate function\n */\nexport function dsFilterAsync<T>(predicate: (value: T) => Promise<boolean>): DataSourceDelayFilterOperator<T> {\n    return {\n        name: 'filterAsync',\n        operationType: OperationType.DELAY_FILTER,\n        operation: (v) => predicate(v)\n    };\n}\n\n/**\n * Only propagate an update if the value is even\n */\nexport function dsEven(): DataSourceFilterOperator<number> {\n    return {\n        name: 'even',\n        operationType: OperationType.FILTER,\n        operation: (v) => v % 2 === 0\n    };\n}\n\n/**\n * Only propagate an update if the value is odd\n */\nexport function dsOdd(): DataSourceFilterOperator<number> {\n    return {\n        name: 'odd',\n        operationType: OperationType.FILTER,\n        operation: (v) => v % 2 !== 0\n    };\n}\n\n/**\n * Only propagate an update if the value is lower than the previous update\n */\nexport function dsMin(): DataSourceFilterOperator<number> {\n    let last = Number.MAX_SAFE_INTEGER;\n    return {\n        name: 'min',\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (v < last) {\n                last = v;\n                return true;\n            } else {\n                return false;\n            }\n        }\n    };\n}\n\n/**\n * Only propagate an update if the value is higher than the previous update\n */\nexport function dsMax(): DataSourceFilterOperator<number> {\n    let last = Number.MIN_SAFE_INTEGER;\n    return {\n        name: 'max',\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (v > last) {\n                last = v;\n                return true;\n            } else {\n                return false;\n            }\n        }\n    };\n}\n\n/**\n * Ignore the first N updates where N depends on an external source\n */\nexport function dsSkipDynamic<T>(amountLeft: DataSource<number>): DataSourceFilterOperator<T> {\n    return {\n        operationType: OperationType.FILTER,\n        name: 'skipDynamic',\n        operation: (v) => {\n            if (amountLeft.value === 0) {\n                return true;\n            } else {\n                amountLeft.update(amountLeft.value - 1);\n                return false;\n            }\n        }\n    };\n}\n\n/**\n * Ignore the first N updates\n */\nexport function dsSkip<T>(amount: number): DataSourceFilterOperator<T> {\n    return {\n        operationType: OperationType.FILTER,\n        name: `skip ${amount}`,\n        operation: (v) => {\n            if (amount === 0) {\n                return true;\n            } else {\n                amount--;\n                return false;\n            }\n        }\n    };\n}\n\n/**\n * Allows only a certain number of updates to pass decreasing a counter on each pass\n * If the counter reaches 0 the updates are lost\n */\nexport function dsCutOff<T>(amount: number): DataSourceFilterOperator<T> {\n    return {\n        name: `cutoff ${amount}`,\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (amount === 0) {\n                return false;\n            } else {\n                amount--;\n                return true;\n            }\n        }\n    };\n}\n\n/**\n * Allows only a certain number of updates to pass decreasing a counter on each pass, the counter being an external\n * datasource can be changed externally.\n * If the counter reaches 0 the updates are lost\n */\nexport function dsCutOffDynamic<T>(amountLeft: DataSource<number>): DataSourceFilterOperator<T> {\n    return {\n        name: 'cutoffDynamic',\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (amountLeft.value === 0) {\n                return false;\n            } else {\n                amountLeft.update(amountLeft.value - 1);\n                return true;\n            }\n        }\n    };\n}\n\n/**\n * Allows only a certain number of updates to pass decreasing a counter on each pass, the counter being an external\n * datasource can be changed externally.\n * If the counter reaches 0 the updates are buffered until they are unlocked again\n */\nexport function dsSemaphore<T>(state: DataSource<number>): DataSourceDelayOperator<T> {\n    return {\n        operationType: OperationType.DELAY,\n        name: 'semaphore',\n        operation: (v) => {\n            return new Promise((resolve) => {\n                if (state.value > 0) {\n                    state.update(state.value - 1);\n                    resolve(v);\n                } else {\n                    const cancel = state.listen(() => {\n                        if (state.value > 0) {\n                            cancel();\n                            state.update(state.value - 1);\n                            resolve(v);\n                        }\n                    });\n                }\n            });\n        }\n    };\n}\n\n/**\n * Filters out updates if they have the same value as the previous update, uses reference equality by default\n */\nexport function dsUnique<T>(isEqual?: (valueA: T, valueB: T) => boolean): DataSourceFilterOperator<T> {\n    let primed: boolean = false;\n    let last: T;\n    return {\n        name: 'unique',\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (primed && (isEqual ? isEqual(last, v) : v === last)) {\n                return false;\n            } else {\n                primed = true;\n                last = v;\n                return true;\n            }\n        }\n    };\n}\n\n/**\n * Takes promises and updates with the resolved value, if multiple promises come in processes updates as promises resolve in any order\n */\nexport function dsAwait<T>(): DataSourceMapDelayOperator<T, ThenArg<T>> {\n    return {\n        name: 'await',\n        operationType: OperationType.MAP_DELAY,\n        operation: (v) => {\n            return v as any;\n        }\n    };\n}\n\n/**\n * Takes promises and updates with the resolved value, if multiple promises come in makes sure the updates fire in the same order that the promises came in\n */\nexport function dsAwaitOrdered<T>(): DataSourceMapDelayOperator<T, ThenArg<T>> {\n    const queue: any[] = [];\n    const onDequeue = new EventEmitter();\n\n    return {\n        operationType: OperationType.MAP_DELAY,\n        name: 'awaitOrdered',\n        operation: async (v) => {\n            queue.push(v);\n            if (queue.length === 1) {\n                return processItem();\n            } else {\n                const unsub = onDequeue.subscribe(async () => {\n                    if (queue[0] === v) {\n                        unsub.cancel();\n                        return processItem();\n                    }\n                });\n            }\n        }\n    };\n\n    async function processItem() {\n        await queue[0];\n        const item = queue.shift();\n        onDequeue.fire();\n        return item;\n    }\n}\n\n/**\n * awaits promise and forwards the resolved value, if a new promise comes in while the first isn't resolved then the first\n * promise will be ignored even if it resolves first and instead we focus on the newest promise. This is useful for cancellable\n * async operations where we only care about the result if it's the latest action\n */\nexport function dsAwaitLatest<T>(): DataSourceMapDelayFilterOperator<T, ThenArg<T>> {\n    let freshnessToken: number;\n\n    return {\n        operationType: OperationType.MAP_DELAY_FILTER,\n        name: 'awaitLatest',\n        operation: async (v) => {\n            freshnessToken = Date.now();\n            const timestamp = freshnessToken;\n            const resolved = await (v as any);\n            if (freshnessToken === timestamp) {\n                return {\n                    item: resolved as any,\n                    cancelled: false\n                };\n            } else {\n                return {\n                    item: undefined,\n                    cancelled: true\n                };\n            }\n        }\n    };\n}\n\n/**\n * Reduces all updates down to a value\n */\nexport function dsReduce<T, M = T>(reducer: (p: M, c: T) => M, initialValue: M): DataSourceMapOperator<T, M> {\n    let last = initialValue;\n    return {\n        name: 'reduce',\n        operationType: OperationType.MAP,\n        operation: (v) => {\n            last = reducer(last, v);\n            return last;\n        }\n    };\n}\n\n/**\n * Builds a string where each update is appened to the string optionally with a seperator\n */\nexport function dsStringJoin(seperator: string = ', '): DataSourceMapOperator<string, string> {\n    let last: string;\n    return {\n        name: `stringJoin ${seperator}`,\n        operationType: OperationType.MAP,\n        operation: (v: string) => {\n            if (last) {\n                last += seperator + v;\n            } else {\n                last = v;\n            }\n            return last;\n        }\n    };\n}\n\n/**\n * Adds a fixed amount of lag to updates\n */\nexport function dsDelay<T>(time: number): DataSourceDelayOperator<T> {\n    return {\n        name: `delay ${time}ms`,\n        operationType: OperationType.DELAY,\n        operation: (v) => {\n            return new Promise((resolve) => {\n                setTimeout(() => {\n                    resolve(v);\n                }, time);\n            });\n        }\n    };\n}\n\n/**\n * Starts a timer when an update occurs, delays the update until the timer passed if a new update arrives the initial\n * update is cancelled and the process starts again\n */\nexport function dsDebounce<T>(time: number): DataSourceDelayFilterOperator<T> {\n    let timeout;\n    let cancelled = new EventEmitter();\n    return {\n        operationType: OperationType.DELAY_FILTER,\n        name: `debounce ${time}ms`,\n        operation: (v) => {\n            return new Promise((resolve) => {\n                clearTimeout(timeout);\n                cancelled.fire();\n                cancelled.subscribeOnce(() => {\n                    resolve(false);\n                });\n                timeout = setTimeout(() => {\n                    resolve(true);\n                    cancelled.cancelAll();\n                }, time);\n            });\n        }\n    };\n}\n\n/**\n * Only allow up to 1 update to propagate per frame makes update run as a microtask\n */\nexport function dsMicroDebounce<T>(): DataSourceDelayFilterOperator<T> {\n    let scheduled;\n    return {\n        operationType: OperationType.DELAY_FILTER,\n        name: `microDebounce`,\n        operation: (v) => {\n            return new Promise((resolve) => {\n                if (!scheduled) {\n                    scheduled = true;\n                    queueMicrotask(() => {\n                        scheduled = false;\n                        resolve(true);\n                    });\n                } else {\n                    resolve(false);\n                }\n            });\n        }\n    };\n}\n\n/**\n * Debounce update to occur at most one per animation frame\n */\nexport function dsThrottleFrame<T>(): DataSourceDelayFilterOperator<T> {\n    let timeout;\n    let cancelled = new EventEmitter();\n    return {\n        operationType: OperationType.DELAY_FILTER,\n        name: `throttle frame`,\n        operation: (v) => {\n            return new Promise((resolve) => {\n                clearTimeout(timeout);\n                cancelled.fire();\n                cancelled.subscribeOnce(() => {\n                    resolve(false);\n                });\n                timeout = requestAnimationFrame(() => {\n                    resolve(true);\n                    cancelled.cancelAll();\n                });\n            });\n        }\n    };\n}\n\n/**\n * May or may not block all updates based on the state provided by another source\n * lock state\n * false => updates pass through\n * true => updates are blocked and dropped\n * Not suitable for synchronization purposes. Use dsCriticalSection instead\n */\nexport function dsLock<T>(state: DataSource<boolean>): DataSourceFilterOperator<T> {\n    return {\n        name: 'lock',\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (!state.value) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    };\n}\n\n/**\n * Allows at most one update per N milliseconds to pass through\n */\nexport function dsThrottle<T>(time: number): DataSourceFilterOperator<T> {\n    let cooldown = false;\n    return {\n        name: `throttle ${time}ms`,\n        operationType: OperationType.FILTER,\n        operation: (v) => {\n            if (!cooldown) {\n                cooldown = true;\n                setTimeout(() => {\n                    cooldown = false;\n                }, time);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    };\n}\n\n/**\n * When an update occurs a timer is started, during that time all subsequent updates are collected in an array and then\n * once the timer runs out an update is made with all updates collected so far as an array\n */\nexport function dsBuffer<T>(time: number): DataSourceMapDelayFilterOperator<T, T[]> {\n    let buffer = [];\n    let promise;\n\n    return {\n        name: `buffer ${time}ms`,\n        operationType: OperationType.MAP_DELAY_FILTER,\n        operation: (v) => {\n            buffer.push(v);\n            if (!promise) {\n                promise = new Promise((resolve) => {\n                    setTimeout(() => {\n                        promise = undefined;\n                        resolve({\n                            cancelled: false,\n                            item: buffer\n                        });\n                        buffer = [];\n                    }, time);\n                });\n                return promise;\n            } else {\n                return Promise.resolve({\n                    cancelled: true,\n                    item: undefined\n                });\n            }\n        }\n    };\n}\n\n/**\n * Extracts only the value of a key of the update value\n */\nexport function dsPick<T, K extends keyof T>(key: K): DataSourceMapOperator<T, T[K]> {\n    return {\n        name: `pick ${key.toString()}`,\n        operationType: OperationType.MAP,\n        operation: (v) => {\n            if (v !== undefined && v !== null) {\n                return v[key];\n            } else {\n                return v as null | undefined;\n            }\n        }\n    };\n}\n\n/**\n * Forwards an event to another source\n */\nexport function dsPipe<T>(target: DataSource<T> | DuplexDataSource<T> | Stream<T, any>): DataSourceNoopOperator<T> {\n    return {\n        name: `pipe ${target.name}`,\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            if (target instanceof DataSource || target instanceof Stream) {\n                target.update(v);\n            } else {\n                target.updateDownstream(v);\n            }\n            return v;\n        }\n    };\n}\n\n/**\n * Same as pipe except for duplex data sources it pipes upstream\n */\nexport function dsPipeUp<T>(target: DataSource<T> | DuplexDataSource<T> | Stream<T, any>): DataSourceNoopOperator<T> {\n    return {\n        name: `pipeup ${target.name}`,\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            if (target instanceof DataSource || target instanceof Stream) {\n                target.update(v);\n            } else {\n                target.updateUpstream(v);\n            }\n            return v;\n        }\n    };\n}\n\n/**\n * Lets you keep a history of the updates of a source by pushing it onto an array datasource\n */\nexport function dsHistory<T>(\n    reportTarget: ArrayDataSource<T>,\n    generations?: number,\n    cancellationToken: CancellationToken = new CancellationToken()\n): DataSourceNoopOperator<T> {\n    return {\n        operationType: OperationType.NOOP,\n        name: `history`,\n        operation: (v) => {\n            if (!cancellationToken.isCancelled) {\n                if (generations) {\n                    if (reportTarget.length.value >= generations) {\n                        reportTarget.removeLeft(reportTarget.length.value - generations);\n                    }\n                }\n                reportTarget.push(v);\n            }\n            return v;\n        }\n    };\n}\n\n/**\n * Monitors the number of events per interval\n */\nexport function dsThroughputMeter<T>(\n    reportTarget: DataSource<number>,\n    interval: number,\n    cancellationToken: CancellationToken = new CancellationToken()\n): DataSourceNoopOperator<T> {\n    let amount = 0;\n    cancellationToken.setInterval(() => {\n        reportTarget.update(amount);\n        amount = 0;\n    }, interval);\n\n    return {\n        operationType: OperationType.NOOP,\n        name: `throughput meter`,\n        operation: (v) => {\n            amount++;\n            return v;\n        }\n    };\n}\n\n/**\n * Allows inserting a callback that gets called with an update\n */\nexport function dsTap<T>(cb: Callback<T>): DataSourceNoopOperator<T> {\n    return {\n        name: 'tap',\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            cb(v);\n            return v;\n        }\n    };\n}\n\n/**\n * Pipes updates to the targets in round-robin fashion\n */\nexport function dsLoadBalance<T>(targets: Array<DataSource<T> | DuplexDataSource<T> | Stream<T, any>>): DataSourceNoopOperator<T> {\n    let i = 0;\n\n    return {\n        name: `loadBalance [${targets.map((v) => v.name).join()}]`,\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            const target = targets[i++];\n            if (i >= targets.length) {\n                i = 0;\n            }\n            if (target instanceof DataSource || target instanceof Stream) {\n                target.update(v);\n            } else {\n                target.updateDownstream(v);\n            }\n\n            return v;\n        }\n    };\n}\n\n/**\n * Logs updates to the console\n */\nexport function dsLog<T>(prefix: string = '', suffix: string = ''): DataSourceNoopOperator<T> {\n    return {\n        name: `log`,\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            console.log(`${prefix}${v}${suffix}`);\n            return v;\n        }\n    };\n}\n\nexport function dsPipeAll<T>(...sources: Array<DataSource<T> | DuplexDataSource<T> | Stream<T, any>>): DataSourceNoopOperator<T> {\n    return {\n        name: `pipeAll [${sources.map((v) => v.name).join()}]`,\n        operationType: OperationType.NOOP,\n        operation: (v) => {\n            sources.forEach((source) => {\n                if (source instanceof DataSource || source instanceof Stream) {\n                    source.update(v);\n                } else {\n                    source.updateDownstream(v);\n                }\n            });\n            return v;\n        }\n    };\n}\n\nexport function dsAccumulate(initialValue: number): DataSourceMapOperator<number, number> {\n    let sum = initialValue;\n    return {\n        name: `accumulate`,\n        operationType: OperationType.MAP,\n        operation: (v) => {\n            sum += v;\n            return sum;\n        }\n    };\n}\n", "import { dsDebounce } from './data_source_operators.js';\nimport { DuplexDataSourceDelayFilterOperator, DuplexDataSourceFilterOperator, DuplexDataSourceMapOperator, OperationType } from './operator_model.js';\n\nexport enum DataFlow {\n    UPSTREAM,\n    DOWNSTREAM\n}\n\nexport enum DataFlowBoth {\n    UPSTREAM,\n    DOWNSTREAM,\n    BOTH\n}\n\nexport function ddsMap<T, M>(mapDown: (value: T) => M, mapUp: (value: M) => T): DuplexDataSourceMapOperator<T, M> {\n    return {\n        name: 'map',\n        operationType: OperationType.MAP,\n        operationDown: (v) => mapDown(v),\n        operationUp: (v) => mapUp(v)\n    };\n}\n\n/**\n * Starts a timer when an update occurs, delays the update until the timer passed if a new update arrives the initial\n * update is cancelled and the process starts again\n */\nexport function ddsDebounce<T>(time: number, direction?: DataFlowBoth): DuplexDataSourceDelayFilterOperator<T> {\n    const debounceDown = dsDebounce(time);\n    const debounceUp = dsDebounce(time);\n\n    return {\n        operationType: OperationType.DELAY_FILTER,\n        name: `debounce ${time}ms`,\n        operationDown: (v) => {\n            if (direction === undefined || direction === DataFlowBoth.DOWNSTREAM || direction === DataFlowBoth.BOTH) {\n                return debounceDown.operation(v);\n            } else {\n                return Promise.resolve(true);\n            }\n        },\n        operationUp: (v) => {\n            if (direction === undefined || direction === DataFlowBoth.UPSTREAM || direction === DataFlowBoth.BOTH) {\n                return debounceUp.operation(v);\n            } else {\n                return Promise.resolve(true);\n            }\n        }\n    };\n}\n\nexport function ddsOneWayFlow<T>(direction: DataFlow): DuplexDataSourceFilterOperator<T> {\n    if (direction === DataFlow.DOWNSTREAM) {\n        return ddsFilter(\n            () => true,\n            () => false\n        );\n    } else {\n        return ddsFilter(\n            () => false,\n            () => true\n        );\n    }\n}\n\nexport function ddsFilter<T>(predicateDown: (value: T) => boolean, predicateUp: (value: T) => boolean): DuplexDataSourceFilterOperator<T> {\n    return {\n        name: 'filter',\n        operationType: OperationType.FILTER,\n        operationDown: (v) => predicateDown(v),\n        operationUp: (v) => predicateUp(v)\n    };\n}\n\nexport function ddsUnique<T>(direction?: DataFlowBoth, isEqual?: (valueA: T, valueB: T) => boolean): DuplexDataSourceFilterOperator<T> {\n    let lastDown: T;\n    let lastUp: T;\n    let primedUp: boolean = false;\n    let primedDown: boolean = false;\n\n    return {\n        name: 'filter',\n        operationType: OperationType.FILTER,\n        operationDown: (v) => {\n            if (direction === undefined || direction === DataFlowBoth.DOWNSTREAM || direction === DataFlowBoth.BOTH) {\n                if (primedDown && (isEqual ? isEqual(lastDown, v) : v === lastDown)) {\n                    return false;\n                } else {\n                    primedDown = true;\n                    lastDown = v;\n                    return true;\n                }\n            } else {\n                return true;\n            }\n        },\n        operationUp: (v) => {\n            if (direction === undefined || direction === DataFlowBoth.UPSTREAM || direction === DataFlowBoth.BOTH) {\n                if (primedUp && (isEqual ? isEqual(lastUp, v) : v === lastUp)) {\n                    return false;\n                } else {\n                    lastUp = v;\n                    primedUp = true;\n                    return true;\n                }\n            } else {\n                return true;\n            }\n        }\n    };\n}\n", "import { AurumServerInfo, syncDuplexDataSource } from '../aurum_server/aurum_server_client.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback } from '../utilities/common.js';\nimport { EventEmitter } from '../utilities/event_emitter.js';\nimport { promiseIterator } from '../utilities/iteration.js';\nimport { DataSource, GenericDataSource, processTransform, ReadOnlyDataSource } from './data_source.js';\nimport { DataFlow, ddsOneWayFlow } from './duplex_data_source_operators.js';\nimport {\n    DataSourceOperator,\n    DuplexDataSourceDelayFilterOperator,\n    DuplexDataSourceFilterOperator,\n    DuplexDataSourceMapDelayFilterOperator,\n    DuplexDataSourceMapOperator,\n    DuplexDataSourceOperator,\n    OperationType\n} from './operator_model.js';\n\n/**\n * Same as DataSource except data can flow in both directions\n */\nexport class DuplexDataSource<T> implements GenericDataSource<T> {\n    /**\n     * The current value of this data source, can be changed through update\n     */\n    public value: T;\n    private primed: boolean;\n\n    protected errorHandler: (error: any) => T;\n    protected errorEvent: EventEmitter<Error>;\n    private updatingUpstream: boolean;\n    private updatingDownstream: boolean;\n    private updateDownstreamEvent: EventEmitter<T>;\n    private updateUpstreamEvent: EventEmitter<T>;\n    private propagateWritesToReadStream: boolean;\n    public name: string;\n\n    /**\n     * The top can be viewed as the source of truth and bottom as the derived value. UpdateDownStream means the change is propagated from top to bottom or that the source of truth changed.\n     * UpdateUpstream means the change is propagated from bottom to top or that the derived value changed.\n     * @param initialValue\n     * @param rootNode If a write is done propagate this update back down to all the consumers. Useful at the root node because in case of a tree structure changes from one branch won't propagate to the other without this\n     */\n    constructor(initialValue?: T, rootNode: boolean = true, name: string = 'RootDuplexDataSource') {\n        this.name = name;\n        this.value = initialValue;\n        this.primed = initialValue !== undefined;\n        this.updateDownstreamEvent = new EventEmitter();\n        this.updateUpstreamEvent = new EventEmitter();\n        this.propagateWritesToReadStream = rootNode;\n    }\n\n    /**\n     * Connects to an aurum-server exposed datasource view https://github.com/CyberPhoenix90/aurum-server for more information\n     * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated\n     * @param  {AurumServerInfo} aurumServerInfo\n     * @returns DataSource\n     */\n    public static fromRemoteSource<T>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): DuplexDataSource<T> {\n        const result = new DuplexDataSource<T>(undefined, false);\n\n        syncDuplexDataSource(result, aurumServerInfo, cancellation);\n\n        return result;\n    }\n\n    public static fromAsyncIterator<T>(iterator: AsyncIterableIterator<T>, cancellation?: CancellationToken): DuplexDataSource<T> {\n        const result = new DuplexDataSource<T>();\n\n        (async () => {\n            for await (const item of iterator) {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                result.updateDownstream(item);\n            }\n        })();\n\n        return result;\n    }\n\n    public static fromPromise<T>(promise: Promise<T>, cancellation?: CancellationToken): DuplexDataSource<T> {\n        const result = new DuplexDataSource<T>();\n\n        promise.then(\n            (v) => {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                result.updateDownstream(v);\n            },\n            (e) => {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                result.emitError(e, DataFlow.DOWNSTREAM);\n            }\n        );\n\n        return result;\n    }\n\n    public static fromPromiseArray<T>(promises: Promise<T>[], cancellation?: CancellationToken): DuplexDataSource<T> {\n        const result = new DuplexDataSource<T>();\n\n        (async () => {\n            for await (const promise of promiseIterator(promises, cancellation)) {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                if (promise.status === 'fulfilled') {\n                    result.updateDownstream(promise.value);\n                } else {\n                    result.emitError(promise.reason, DataFlow.DOWNSTREAM);\n                }\n            }\n        })();\n\n        return result;\n    }\n\n    public toAsyncIterator(cancellation?: CancellationToken): AsyncIterableIterator<T> {\n        return this.updateDownstreamEvent.toAsyncIterator(cancellation);\n    }\n\n    public static toDuplexDataSource<T>(value: T | DuplexDataSource<T>): DuplexDataSource<T> {\n        if (value instanceof DuplexDataSource) {\n            return value;\n        } else {\n            return new DuplexDataSource(value);\n        }\n    }\n\n    /**\n     * Makes it possible to have 2 completely separate data flow pipelines for each direction\n     * @param downStream stream to pipe downstream data to\n     * @param upstream  stream to pipe upstream data to\n     */\n    public static fromTwoDataSource<T>(\n        downStream: DataSource<T>,\n        upstream: DataSource<T>,\n        initialValue?: T,\n        propagateWritesToReadStream: boolean = true\n    ): DuplexDataSource<T> {\n        const result = new DuplexDataSource<T>(initialValue, propagateWritesToReadStream);\n        //@ts-ignore\n        result.updateDownstreamEvent = downStream.updateEvent;\n        //@ts-ignore\n        result.updateUpstreamEvent = upstream.updateEvent;\n\n        return result;\n    }\n\n    /**\n     * Updates the data source with a value if it has never had a value before\n     */\n    public withInitial(value: T): this {\n        if (!this.primed) {\n            this.updateDownstream(value);\n        }\n\n        return this;\n    }\n\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Allows creating a duplex stream that blocks data in one direction. Useful for plugging into code that uses two way flow but only one way is desired\n     * @param direction direction of the dataflow that is allowed\n     */\n    public static createOneWay<T>(direction: DataFlow = DataFlow.DOWNSTREAM, initialValue?: T): DuplexDataSource<T> {\n        return new DuplexDataSource(initialValue, false).transformDuplex(ddsOneWayFlow(direction));\n    }\n    /**\n     * Updates the value in the data source and calls the listen callback for all listeners\n     * Moves the data from the top to the bottom. Used to reflect changes in the source data to the derived data\n     * @param newValue new value for the data source\n     */\n    public updateDownstream(newValue: T): void {\n        //@ts-expect-error Typescript tries to be smart and thinks this could never happen but it can with the any type as T\n        if (newValue === this) {\n            throw new Error('Cannot update data source with itself');\n        }\n\n        if (this.updatingDownstream) {\n            throw new Error(\n                'Problem in datas source: Unstable value propagation, when updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed'\n            );\n        }\n        this.primed = true;\n        this.updatingDownstream = true;\n        this.value = newValue;\n        this.updateDownstreamEvent.fire(newValue);\n        this.updatingDownstream = false;\n    }\n\n    /**\n     * Updates the value in the data source and calls the listen callback for all listeners.\n     * Moves the data from the bottom to the top. Used to reflect changes in derived data back to the source\n     * @param newValue new value for the data source\n     */\n    public updateUpstream(newValue: T): void {\n        //@ts-expect-error Typescript tries to be smart and thinks this could never happen but it can with the any type as T\n        if (newValue === this) {\n            throw new Error('Cannot update data source with itself');\n        }\n\n        if (this.updatingUpstream) {\n            throw new Error(\n                'Problem in datas source: Unstable value propagation, when updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed'\n            );\n        }\n        this.primed = true;\n        this.updatingUpstream = true;\n        this.value = newValue;\n        this.updateUpstreamEvent.fire(newValue);\n        if (this.propagateWritesToReadStream) {\n            this.updateDownstreamEvent.fire(newValue);\n        }\n        this.updatingUpstream = false;\n    }\n\n    /**\n     * Same as listen but will immediately call the callback with the current value first\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenAndRepeat(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        if (this.primed) {\n            callback(this.value);\n        }\n        return this.listen(callback, cancellationToken);\n    }\n\n    /**\n     * alias for listenDownstream\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listen(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.listenInternal(callback, cancellationToken);\n    }\n\n    private listenInternal(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateDownstreamEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Subscribes exclusively to updates of the data stream that occur due to an update flowing upstream\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenUpstream(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateUpstreamEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Subscribes exclusively to updates of the data stream that occur due to an update flowing upstream\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenUpstreamAndRepeat(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        if (this.primed) {\n            callback(this.value);\n        }\n\n        return this.updateUpstreamEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Subscribes exclusively to one update of the data stream that occur due to an update flowing upstream\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenUpstreamOnce(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateUpstreamEvent.subscribeOnce(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Subscribes exclusively to updates of the data stream that occur due to an update flowing downstream\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenDownstream(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateDownstreamEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    public downStreamToDataSource(cancellationToken?: CancellationToken): DataSource<T> {\n        const downStreamDatasource = new DataSource<T>(this.value);\n        this.listenDownstream((newVal) => {\n            downStreamDatasource.update(newVal);\n        }, cancellationToken);\n\n        return downStreamDatasource;\n    }\n\n    /**\n     * Combines two sources into a third source that listens to updates from both parent sources.\n     * @param otherSource Second parent for the new source\n     * @param combinator Method allowing you to combine the data from both parents on update. Called each time a parent is updated with the latest values of both parents\n     * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources\n     */\n    public aggregate<R, A>(otherSources: [ReadOnlyDataSource<A>], combinator: (self: T, other: A) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    public aggregate<R, A, B>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>],\n        combinator: (self: T, second: A, third: B) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>],\n        combinator: (self: T, second: A, third: B, fourth: C) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H, I>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>,\n            ReadOnlyDataSource<I>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H, tenth: I) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R>(otherSources: ReadOnlyDataSource<any>[], combinator: (...data: any[]) => R, cancellationToken?: CancellationToken): DataSource<R> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n\n        const aggregatedSource = new DataSource<R>(combinator(this.value, ...otherSources.map((s) => s?.value)));\n\n        for (let i = 0; i < otherSources.length; i++) {\n            otherSources[i]?.listen(() => {\n                aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s?.value)));\n            }, cancellationToken);\n        }\n\n        this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s?.value))), cancellationToken);\n\n        return aggregatedSource;\n    }\n\n    public transformDuplex<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n        operationA: DuplexDataSourceOperator<T, A>,\n        operationB?: DuplexDataSourceOperator<A, B> | CancellationToken,\n        operationC?: DuplexDataSourceOperator<B, C> | CancellationToken,\n        operationD?: DuplexDataSourceOperator<C, D> | CancellationToken,\n        operationE?: DuplexDataSourceOperator<D, E> | CancellationToken,\n        operationF?: DuplexDataSourceOperator<E, F> | CancellationToken,\n        operationG?: DuplexDataSourceOperator<F, G> | CancellationToken,\n        operationH?: DuplexDataSourceOperator<G, H> | CancellationToken,\n        operationI?: DuplexDataSourceOperator<H, I> | CancellationToken,\n        operationJ?: DuplexDataSourceOperator<I, J> | CancellationToken,\n        operationK?: DuplexDataSourceOperator<J, K> | CancellationToken,\n        cancellationToken?: CancellationToken\n    ): DuplexDataSource<K> {\n        let token;\n        const operations: DuplexDataSourceOperator<any, any>[] = [\n            operationA,\n            operationB,\n            operationC,\n            operationD,\n            operationE,\n            operationF,\n            operationG,\n            operationH,\n            operationI,\n            operationJ,\n            operationK\n        ].filter((e) => e && (e instanceof CancellationToken ? ((token = e), false) : true)) as DuplexDataSourceOperator<any, any>[];\n        if (cancellationToken) {\n            token = cancellationToken;\n        }\n        const result = new DuplexDataSource<K>(undefined, false, this.name + ' ' + operations.map((v) => v.name).join(' '));\n        (this.primed ? this.listenAndRepeat : this.listen).call(this, processTransformDuplex<T, K>(operations as any, result, DataFlow.DOWNSTREAM), token);\n        result.listenUpstream.call(result, processTransformDuplex<T, K>(operations as any, this as any, DataFlow.UPSTREAM), token);\n\n        return result;\n    }\n\n    public transform<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n        operationA: DataSourceOperator<T, A>,\n        operationB?: DataSourceOperator<A, B> | CancellationToken,\n        operationC?: DataSourceOperator<B, C> | CancellationToken,\n        operationD?: DataSourceOperator<C, D> | CancellationToken,\n        operationE?: DataSourceOperator<D, E> | CancellationToken,\n        operationF?: DataSourceOperator<E, F> | CancellationToken,\n        operationG?: DataSourceOperator<F, G> | CancellationToken,\n        operationH?: DataSourceOperator<G, H> | CancellationToken,\n        operationI?: DataSourceOperator<H, I> | CancellationToken,\n        operationJ?: DataSourceOperator<I, J> | CancellationToken,\n        operationK?: DataSourceOperator<J, K> | CancellationToken,\n        cancellationToken?: CancellationToken\n    ): DataSource<K> {\n        let token;\n        const operations: DataSourceOperator<any, any>[] = [\n            operationA,\n            operationB,\n            operationC,\n            operationD,\n            operationE,\n            operationF,\n            operationG,\n            operationH,\n            operationI,\n            operationJ,\n            operationK\n        ].filter((e) => e && (e instanceof CancellationToken ? ((token = e), false) : true)) as DataSourceOperator<any, any>[];\n        if (cancellationToken) {\n            token = cancellationToken;\n        }\n        const result = new DataSource<K>(undefined, this.name + ' ' + operations.map((v) => v.name).join(' '));\n        (this.primed ? this.listenAndRepeat : this.listen).call(this, processTransform<T, K>(operations as any, result), token);\n\n        return result;\n    }\n\n    /**\n     * Like aggregate except that no combination method is needed as a result both parents must have the same type and the new stream just exposes the last update recieved from either parent\n     * @param otherSource Second parent for the new source\n     * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources\n     */\n    public combine(otherSources: ReadOnlyDataSource<T>[], cancellationToken?: CancellationToken): DataSource<T> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n\n        let combinedDataSource: DataSource<T> | DuplexDataSource<T>;\n        if (this.primed) {\n            combinedDataSource = new DataSource<T>(this.value);\n        } else {\n            combinedDataSource = new DataSource<T>();\n        }\n        this.pipe(combinedDataSource, cancellationToken);\n        for (const otherSource of otherSources) {\n            otherSource.pipe(combinedDataSource, cancellationToken);\n        }\n\n        return combinedDataSource;\n    }\n\n    /**\n     * Forwards all updates from this source to another\n     * @param targetDataSource datasource to pipe the updates to\n     * @param cancellationToken  Cancellation token to cancel the subscriptions added to the datasources by this operation\n     */\n    public pipe(targetDataSource: DataSource<T>, cancellationToken?: CancellationToken): this {\n        this.listenDownstream((newVal) => targetDataSource.update(newVal), cancellationToken);\n        targetDataSource.listen((newVal) => this.updateUpstream(newVal), cancellationToken);\n        return this;\n    }\n\n    public listenOnce(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateDownstreamEvent.subscribeOnce(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Returns a promise that resolves when the next update occurs\n     * @param cancellationToken\n     */\n    public awaitNextUpdate(cancellationToken?: CancellationToken): Promise<T> {\n        return new Promise((resolve) => {\n            this.listenOnce((value) => resolve(value), cancellationToken);\n        });\n    }\n\n    /**\n     * Remove all listeners\n     */\n    public cancelAll(): void {\n        this.updateDownstreamEvent.cancelAll();\n        this.updateUpstreamEvent.cancelAll();\n    }\n\n    public cancelAllDownstream(): void {\n        this.updateDownstreamEvent.cancelAll();\n    }\n\n    public cancelAllUpstream(): void {\n        this.updateUpstreamEvent.cancelAll();\n    }\n\n    /**\n     * Assign a function to handle errors and map them back to regular values. Rethrow the error in case you want to fallback to emitting error\n     */\n    public handleErrors(callback: (error: any) => T): this {\n        this.errorHandler = callback;\n        return this;\n    }\n\n    public onError(callback: (error: any) => void, cancellationToken?: CancellationToken): this {\n        this.errorEvent.subscribe(callback, cancellationToken);\n        return this;\n    }\n\n    public emitError(e: Error, direction: DataFlow): void {\n        if (this.errorHandler) {\n            try {\n                if (direction === DataFlow.DOWNSTREAM) {\n                    return this.updateDownstream(this.errorHandler(e));\n                } else {\n                    return this.updateUpstream(this.errorHandler(e));\n                }\n            } catch (newError) {\n                e = newError;\n            }\n        }\n        if (this.errorEvent.hasSubscriptions()) {\n            this.errorEvent.fire(e);\n        } else {\n            throw e;\n        }\n    }\n}\n\nexport function processTransformDuplex<I, O>(operations: DuplexDataSourceOperator<any, any>[], result: DuplexDataSource<O>, direction: DataFlow): Callback<I> {\n    return async (v: any) => {\n        try {\n            for (const operation of operations) {\n                switch (operation.operationType) {\n                    case OperationType.NOOP:\n                    case OperationType.MAP:\n                        v =\n                            direction === DataFlow.DOWNSTREAM\n                                ? (operation as DuplexDataSourceMapOperator<any, any>).operationDown(v)\n                                : (operation as DuplexDataSourceMapOperator<any, any>).operationUp(v);\n                        break;\n                    case OperationType.MAP_DELAY_FILTER:\n                        const tmp =\n                            direction === DataFlow.DOWNSTREAM\n                                ? await (operation as DuplexDataSourceMapDelayFilterOperator<any, any>).operationDown(v)\n                                : await (operation as DuplexDataSourceMapDelayFilterOperator<any, any>).operationUp(v);\n                        if (tmp.cancelled) {\n                            return;\n                        } else {\n                            v = await tmp.item;\n                        }\n                        break;\n                    case OperationType.DELAY:\n                    case OperationType.MAP_DELAY:\n                        v =\n                            direction === DataFlow.DOWNSTREAM\n                                ? await (operation as DuplexDataSourceMapOperator<any, any>).operationDown(v)\n                                : await (operation as DuplexDataSourceMapOperator<any, any>).operationUp(v);\n                        break;\n                    case OperationType.DELAY_FILTER:\n                        if (\n                            !(direction === DataFlow.DOWNSTREAM\n                                ? await (operation as DuplexDataSourceDelayFilterOperator<any>).operationDown(v)\n                                : await (operation as DuplexDataSourceDelayFilterOperator<any>).operationUp(v))\n                        ) {\n                            return;\n                        }\n                        break;\n                    case OperationType.FILTER:\n                        if (\n                            !(direction === DataFlow.DOWNSTREAM\n                                ? (operation as DuplexDataSourceFilterOperator<any>).operationDown(v)\n                                : (operation as DuplexDataSourceFilterOperator<any>).operationUp(v))\n                        ) {\n                            return;\n                        }\n                        break;\n                }\n            }\n            if (direction === DataFlow.DOWNSTREAM) {\n                result.updateDownstream(v);\n            } else {\n                result.updateUpstream(v);\n            }\n        } catch (e) {\n            result.emitError(e, direction);\n        }\n    };\n}\n", "import { AurumServerInfo, syncObjectDataSource } from '../aurum_server/aurum_server_client.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback } from '../utilities/common.js';\nimport { EventEmitter } from '../utilities/event_emitter.js';\nimport { ArrayDataSource, DataSource, ReadOnlyArrayDataSource, ReadOnlyDataSource } from './data_source.js';\nimport { DuplexDataSource } from './duplex_data_source.js';\n\nexport interface ObjectChange<T, K extends keyof T> {\n    key: K;\n    oldValue: T[K];\n    newValue: T[K];\n    deleted?: boolean;\n}\n\nexport interface ReadOnlyObjectDataSource<T> {\n    toString(): string;\n    pickObject<K extends keyof T>(key: K, cancellationToken?: CancellationToken): ReadOnlyObjectDataSource<T[K]>;\n    pickArray<K extends keyof T>(key: K, cancellationToken?: CancellationToken): ReadOnlyArrayDataSource<FlatArray<T[K], 1>>;\n    pick<K extends keyof T>(key: K, cancellationToken?: CancellationToken): ReadOnlyDataSource<T[K]>;\n    pickDuplex<K extends keyof T>(key: K, cancellationToken?: CancellationToken): DuplexDataSource<T[K]>;\n    listen(callback: Callback<ObjectChange<T, keyof T>>, cancellationToken?: CancellationToken): Callback<void>;\n    listenAndRepeat(callback: Callback<ObjectChange<T, keyof T>>, cancellationToken?: CancellationToken): Callback<void>;\n    map<D>(mapper: (key: keyof T) => D): ArrayDataSource<D>;\n    listenOnKey<K extends keyof T>(key: K, callback: Callback<ObjectChange<T, K>>, cancellationToken?: CancellationToken): Callback<void>;\n    listenOnKeyAndRepeat<K extends keyof T>(key: K, callback: Callback<ObjectChange<T, keyof T>>, cancellationToken?: CancellationToken): Callback<void>;\n    keys(): string[];\n    values(): any;\n    get<K extends keyof T>(key: K): T[K];\n    getData(): Readonly<T>;\n    toObject(): T;\n    toDataSource(): DataSource<T>;\n}\n\nexport class ObjectDataSource<T> implements ReadOnlyObjectDataSource<T> {\n    protected data: T;\n    private updateEvent: EventEmitter<ObjectChange<T, keyof T>>;\n    private updateEventOnKey: Map<keyof T, EventEmitter<ObjectChange<T, keyof T>>>;\n\n    constructor(initialData: T) {\n        this.data = initialData;\n        this.updateEvent = new EventEmitter();\n        this.updateEventOnKey = new Map();\n    }\n\n    /**\n     * Connects to an aurum-server exposed object datasource. View https://github.com/CyberPhoenix90/aurum-server for more information\n     * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server\n     * @param  {AurumServerInfo} aurumServerInfo\n     * @returns DataSource\n     */\n    public static fromRemoteSource<T>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): ObjectDataSource<T> {\n        const result = new ObjectDataSource<T>(undefined);\n\n        syncObjectDataSource(result, aurumServerInfo, cancellation);\n\n        return result;\n    }\n\n    public static toObjectDataSource<T>(value: T | ObjectDataSource<T>): ObjectDataSource<T> {\n        if (value instanceof ObjectDataSource) {\n            return value;\n        } else {\n            return new ObjectDataSource(value);\n        }\n    }\n\n    public toString(): string {\n        return this.data.toString();\n    }\n    /**\n     * Remove all listeners\n     */\n    public cancelAll(): void {\n        this.updateEvent.cancelAll();\n        this.updateEventOnKey.forEach((v) => v.cancelAll());\n    }\n\n    public pickObject<K extends keyof T>(key: K, cancellationToken?: CancellationToken): ObjectDataSource<T[K]> {\n        if (typeof this.data[key] === 'object') {\n            const subDataSource: ObjectDataSource<T[K]> = new ObjectDataSource(this.data[key]);\n\n            subDataSource.listen((change) => {\n                if (change.deleted) {\n                    delete this.data[key][change.key];\n                } else {\n                    this.get(key)[change.key] = change.newValue as any;\n                }\n            }, cancellationToken);\n\n            this.listenOnKey(key, (v) => {\n                if (typeof v.newValue === 'object') {\n                    if (v.newValue !== subDataSource.data) {\n                        subDataSource.merge(v.newValue);\n                    }\n                } else {\n                    subDataSource.clear();\n                }\n            });\n\n            return subDataSource;\n        } else {\n            throw new Error('Cannot pick a non object key');\n        }\n    }\n\n    public pickArray<K extends keyof T>(key: K, cancellationToken?: CancellationToken): ArrayDataSource<FlatArray<T[K], 1>> {\n        if (Array.isArray(this.data[key])) {\n            const subDataSource: ArrayDataSource<FlatArray<T[K], 1>> = new ArrayDataSource(this.data?.[key] as any);\n\n            subDataSource.listen((change) => {\n                this.set(key, change.newState as any);\n            }, cancellationToken);\n\n            this.listenOnKey(key, (v) => {\n                if (Array.isArray(v.newValue)) {\n                    if (v.newValue.length !== subDataSource.length.value || !subDataSource.getData().every((item, index) => v.newValue[index] === item)) {\n                        subDataSource.merge(v.newValue);\n                    }\n                } else {\n                    subDataSource.clear();\n                }\n            });\n\n            return subDataSource;\n        } else {\n            throw new Error('Cannot pick a non array key');\n        }\n    }\n\n    /**\n     * Creates a datasource for a single key of the object\n     * @param key\n     * @param cancellationToken\n     */\n    public pick<K extends keyof T>(key: K, cancellationToken?: CancellationToken): DataSource<T[K]> {\n        const subDataSource: DataSource<T[K]> = new DataSource(this.data?.[key]);\n\n        subDataSource.listen(() => {\n            this.set(key, subDataSource.value);\n        }, cancellationToken);\n\n        this.listenOnKey(\n            key,\n            (v) => {\n                if (subDataSource.value !== v.newValue) {\n                    subDataSource.update(v.newValue);\n                }\n            },\n            cancellationToken\n        );\n\n        return subDataSource;\n    }\n\n    /**\n     * Creates a duplexdatasource for a single key of the object\n     * @param key\n     * @param cancellationToken\n     */\n    public pickDuplex<K extends keyof T>(key: K, cancellationToken?: CancellationToken): DuplexDataSource<T[K]> {\n        const subDataSource: DuplexDataSource<T[K]> = new DuplexDataSource(this.data?.[key]);\n        subDataSource.listenUpstream((v) => {\n            this.set(key, v);\n        });\n\n        this.listenOnKey(\n            key,\n            (v) => {\n                if (subDataSource.value !== v.newValue) {\n                    subDataSource.updateDownstream(v.newValue);\n                }\n            },\n            cancellationToken\n        );\n\n        return subDataSource;\n    }\n\n    public hasKey(key: keyof T): boolean {\n        return this.data.hasOwnProperty(key);\n    }\n\n    public applyObjectChange(change: ObjectChange<T, keyof T>): void {\n        if (change.deleted && this.hasKey(change.key)) {\n            this.delete(change.key);\n        } else if (change.newValue !== this.get(change.key)) {\n            this.set(change.key, change.newValue);\n        }\n    }\n\n    /**\n     * Listen to changes of the object\n     */\n    public listen(callback: Callback<ObjectChange<T, keyof T>>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    public map<D>(mapper: (key: keyof T, value: T[keyof T]) => D): ArrayDataSource<D> {\n        const stateMap: Map<string | number | Symbol, D> = new Map<string | number | Symbol, D>();\n        const result = new ArrayDataSource<D>();\n        this.listenAndRepeat((change) => {\n            if (change.deleted && stateMap.has(change.key)) {\n                const item = stateMap.get(change.key);\n                result.remove(item);\n                stateMap.delete(change.key);\n            } else if (stateMap.has(change.key)) {\n                const newItem = mapper(change.key, change.newValue);\n                result.replace(stateMap.get(change.key), newItem);\n                stateMap.set(change.key, newItem);\n            } else if (!stateMap.has(change.key) && !change.deleted) {\n                const newItem = mapper(change.key, change.newValue);\n                result.push(newItem);\n                stateMap.set(change.key, newItem);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Same as listen but will immediately call the callback with the current value of each key\n     */\n    public listenAndRepeat(callback: Callback<ObjectChange<T, keyof T>>, cancellationToken?: CancellationToken): Callback<void> {\n        const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;\n        for (const key in this.data) {\n            callback({\n                key,\n                newValue: this.data[key],\n                oldValue: undefined,\n                deleted: false\n            });\n        }\n        return c;\n    }\n\n    /**\n     * Same as listenOnKey but will immediately call the callback with the current value first\n     */\n    public listenOnKeyAndRepeat<K extends keyof T>(\n        key: K,\n        callback: Callback<ObjectChange<T, keyof T>>,\n        cancellationToken?: CancellationToken\n    ): Callback<void> {\n        callback({\n            key,\n            newValue: this.data[key],\n            oldValue: undefined\n        });\n\n        return this.listenOnKey(key, callback, cancellationToken);\n    }\n\n    /**\n     * Listen to changes of a single key of the object\n     */\n    public listenOnKey<K extends keyof T>(key: K, callback: Callback<ObjectChange<T, K>>, cancellationToken?: CancellationToken): Callback<void> {\n        if (!this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.set(key, new EventEmitter());\n        }\n        const event = this.updateEventOnKey.get(key);\n        return event.subscribe(callback as any, cancellationToken).cancel;\n    }\n\n    /**\n     * Returns all the keys of the object in the source\n     */\n    public keys(): string[] {\n        return Object.keys(this.data);\n    }\n\n    /**\n     * Returns all the values of the object in the source\n     */\n    public values(): any {\n        return Object.values(this.data);\n    }\n\n    /**\n     * get the current value of a key of the object\n     * @param key\n     */\n    public get<K extends keyof T>(key: K): T[K] {\n        return this.data[key];\n    }\n\n    /**\n     * delete a key from the object\n     * @param key\n     * @param value\n     */\n    public delete<K extends keyof T>(key: K): void {\n        if (this.hasKey(key)) {\n            const old = this.data[key];\n            delete this.data[key];\n            this.updateEvent.fire({ oldValue: old, key, newValue: undefined, deleted: true });\n            if (this.updateEventOnKey.has(key)) {\n                this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: undefined });\n            }\n        }\n    }\n\n    /**\n     * set the value for a key of the object\n     * @param key\n     * @param value\n     */\n    public set<K extends keyof T>(key: K, value: T[K]): void {\n        if (this.data[key] === value) {\n            return;\n        }\n\n        const old = this.data[key];\n        this.data[key] = value;\n        this.updateEvent.fire({ oldValue: old, key, newValue: this.data[key] });\n        if (this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: this.data[key] });\n        }\n    }\n\n    /**\n     * Merge the key value pairs of an object into this object non recursively\n     * @param newData\n     */\n    public assign(newData: Partial<T> | ObjectDataSource<T>): void {\n        if (newData instanceof ObjectDataSource) {\n            for (const key of newData.keys()) {\n                this.set(key as keyof T, newData.data[key]);\n            }\n        } else {\n            for (const key of Object.keys(newData)) {\n                this.set(key as keyof T, newData[key]);\n            }\n        }\n    }\n\n    /**\n     * Merge the key value pairs of an object into this object non recursively and delete properties that do not exist in the newData\n     * @param newData\n     */\n    public merge(newData: Partial<T> | ObjectDataSource<T>): void {\n        const keys = new Set<string>(Object.keys(this.data ?? {}));\n        if (newData instanceof ObjectDataSource) {\n            for (const key of newData.keys()) {\n                keys.delete(key);\n                this.set(key as keyof T, newData.data[key]);\n            }\n        } else {\n            for (const key of Object.keys(newData)) {\n                keys.delete(key);\n                this.set(key as keyof T, newData[key]);\n            }\n        }\n\n        for (const key of keys) {\n            this.delete(key as keyof T);\n        }\n    }\n\n    /**\n     * Deletes all keys\n     */\n    public clear(): void {\n        if (this.data == undefined) {\n            return;\n        }\n\n        for (const key in this.data) {\n            this.delete(key);\n        }\n    }\n\n    public getData(): Readonly<T> {\n        return this.data;\n    }\n\n    /**\n     * Returns a shallow copy of the object\n     */\n    public toObject(): T {\n        return { ...this.data };\n    }\n\n    /**\n     * Returns a simplified version of this datasource\n     */\n    public toDataSource(): DataSource<T> {\n        const stream = new DataSource(this.data);\n        this.listen((s) => {\n            stream.update(this.data);\n        });\n        return stream;\n    }\n}\n", "import { DataSource, ArrayDataSource, MapDataSource } from '../stream/data_source.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { ObjectDataSource } from '../stream/object_data_source.js';\nimport { Stream } from '../stream/stream.js';\n\nexport type Data<T> = T | DataSource<T>;\nexport type DataArray<T> = T[] | ArrayDataSource<T>;\nexport type DataObject<T> = T | ObjectDataSource<T>;\nexport type DataMap<T> = Map<string, T> | MapDataSource<string, T>;\n\nexport function getValueOf<T>(sourceOrPrimitive: DataArray<T>): ReadonlyArray<T>;\nexport function getValueOf<T>(sourceOrPrimitive: Data<T> | DuplexDataSource<T> | Stream<T>): T;\nexport function getValueOf<T>(sourceOrPrimitive: Data<T> | DataArray<T> | DuplexDataSource<T> | Stream<T>): T | ReadonlyArray<T> {\n    if (sourceOrPrimitive instanceof DataSource || sourceOrPrimitive instanceof DuplexDataSource || sourceOrPrimitive instanceof Stream) {\n        return sourceOrPrimitive.value;\n    }\n    if (sourceOrPrimitive instanceof ArrayDataSource) {\n        return sourceOrPrimitive.getData();\n    }\n    return sourceOrPrimitive;\n}\n\nexport type UnwrapObjectRecursive<T> = T extends ArrayDataSource<infer U>\n    ? UnwrapObjectRecursive<U[]>\n    : T extends DataSource<infer U>\n    ? UnwrapObjectRecursive<U>\n    : T extends DuplexDataSource<infer U>\n    ? UnwrapObjectRecursive<U>\n    : T extends ObjectDataSource<infer U>\n    ? UnwrapObjectRecursive<U>\n    : T extends Stream<infer U>\n    ? UnwrapObjectRecursive<U>\n    : {\n          [K in keyof T]: T[K] extends DataSource<infer U>\n              ? UnwrapObjectRecursive<U>\n              : T[K] extends DuplexDataSource<infer U>\n              ? UnwrapObjectRecursive<U>\n              : T[K] extends Stream<infer U>\n              ? UnwrapObjectRecursive<U>\n              : T[K] extends ObjectDataSource<infer U>\n              ? UnwrapObjectRecursive<U>\n              : T[K] extends object\n              ? UnwrapObjectRecursive<T[K]>\n              : T[K];\n      };\n\nexport function unwrapObjectRecursive<T>(object: T): UnwrapObjectRecursive<T> {\n    if (object instanceof DataSource || object instanceof DuplexDataSource || object instanceof Stream) {\n        //@ts-ignore\n        return unwrapObjectRecursive(object.value);\n    }\n    if (object instanceof ArrayDataSource) {\n        //@ts-ignore\n        return unwrapObjectRecursive(object.toArray());\n    }\n    if (object instanceof ObjectDataSource) {\n        //@ts-ignore\n        return unwrapObjectRecursive(object.getData());\n    }\n    if (object instanceof DuplexDataSource) {\n        //@ts-ignore\n        return unwrapObjectRecursive(object.value);\n    }\n    if (object instanceof Stream) {\n        //@ts-ignore\n        return unwrapObjectRecursive(object.value);\n    }\n    if (Array.isArray(object)) {\n        //@ts-ignore\n        return object.map(unwrapObjectRecursive);\n    }\n    if (object instanceof Object) {\n        const result: any = {};\n        for (const key in object) {\n            result[key] = unwrapObjectRecursive(object[key]);\n        }\n        return result;\n    }\n    //@ts-ignore\n    return object;\n}\n", "import { AurumServerInfo, syncArrayDataSource, syncDataSource, syncMapDataSource, syncSetDataSource } from '../aurum_server/aurum_server_client.js';\nimport { debugDeclareUpdate, debugMode, debugRegisterConsumer, debugRegisterLink, debugRegisterStream } from '../debug_mode.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback, Predicate } from '../utilities/common.js';\nimport { EventEmitter } from '../utilities/event_emitter.js';\nimport { promiseIterator } from '../utilities/iteration.js';\nimport { getValueOf } from '../utilities/sources.js';\nimport { dsDiff, dsTap } from './data_source_operators.js';\nimport { DuplexDataSource } from './duplex_data_source.js';\nimport {\n    DataSourceDelayFilterOperator,\n    DataSourceFilterOperator,\n    DataSourceMapDelayFilterOperator,\n    DataSourceMapOperator,\n    DataSourceOperator,\n    OperationType\n} from './operator_model.js';\n\nexport interface ReadOnlyDataSource<T> {\n    readonly value: T;\n    readonly name: string;\n    listenAndRepeat(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void>;\n    listen(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void>;\n    listenOnce(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void>;\n    awaitNextUpdate(cancellationToken?: CancellationToken): Promise<T>;\n    combine(otherSources: ReadOnlyDataSource<T>[], cancellationToken?: CancellationToken): DataSource<T>;\n    aggregate<R, A>(otherSources: [ReadOnlyDataSource<A>], combinator: (self: T, other: A) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    aggregate<R, A, B>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>],\n        combinator: (self: T, second: A, third: B) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>],\n        combinator: (self: T, second: A, third: B, fourth: C) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F, G>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F, G, H>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F, G, H, I>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>,\n            ReadOnlyDataSource<I>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H, tenth: I) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R>(otherSources: ReadOnlyDataSource<any>[], combinator: (...data: any[]) => R, cancellationToken?: CancellationToken): DataSource<R>;\n\n    pipe(targetDataSource: DataSource<T>, cancellationToken?: CancellationToken): this;\n    transform<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n        operationA: DataSourceOperator<T, A>,\n        operationB?: DataSourceOperator<A, B> | CancellationToken,\n        operationC?: DataSourceOperator<B, C> | CancellationToken,\n        operationD?: DataSourceOperator<C, D> | CancellationToken,\n        operationE?: DataSourceOperator<D, E> | CancellationToken,\n        operationF?: DataSourceOperator<E, F> | CancellationToken,\n        operationG?: DataSourceOperator<F, G> | CancellationToken,\n        operationH?: DataSourceOperator<G, H> | CancellationToken,\n        operationI?: DataSourceOperator<H, I> | CancellationToken,\n        operationJ?: DataSourceOperator<I, J> | CancellationToken,\n        operationK?: DataSourceOperator<J, K> | CancellationToken,\n        cancellationToken?: CancellationToken\n    ): ReadOnlyDataSource<K>;\n}\n\nexport interface GenericDataSource<T> extends ReadOnlyDataSource<T> {\n    readonly value: T;\n    readonly name: string;\n    listenAndRepeat(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void>;\n    listen(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void>;\n    listenOnce(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void>;\n    awaitNextUpdate(cancellationToken?: CancellationToken): Promise<T>;\n    withInitial(value: T): this;\n    aggregate<R, A>(otherSources: [ReadOnlyDataSource<A>], combinator: (self: T, other: A) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    aggregate<R, A, B>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>],\n        combinator: (self: T, second: A, third: B) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>],\n        combinator: (self: T, second: A, third: B, fourth: C) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F, G>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F, G, H>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R, A, B, C, D, E, F, G, H, I>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>,\n            ReadOnlyDataSource<I>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H, tenth: I) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    aggregate<R>(otherSources: ReadOnlyDataSource<any>[], combinator: (...data: any[]) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    transform<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n        operationA: DataSourceOperator<T, A>,\n        operationB?: DataSourceOperator<A, B> | CancellationToken,\n        operationC?: DataSourceOperator<B, C> | CancellationToken,\n        operationD?: DataSourceOperator<C, D> | CancellationToken,\n        operationE?: DataSourceOperator<D, E> | CancellationToken,\n        operationF?: DataSourceOperator<E, F> | CancellationToken,\n        operationG?: DataSourceOperator<F, G> | CancellationToken,\n        operationH?: DataSourceOperator<G, H> | CancellationToken,\n        operationI?: DataSourceOperator<H, I> | CancellationToken,\n        operationJ?: DataSourceOperator<I, J> | CancellationToken,\n        operationK?: DataSourceOperator<J, K> | CancellationToken,\n        cancellationToken?: CancellationToken\n    ): DataSource<K>;\n}\n\n/**\n * Datasources wrap a value and allow you to update it in an observable way. Datasources can be manipulated like streams and can be bound directly in the JSX syntax and will update the html whenever the value changes\n */\nexport class DataSource<T> implements GenericDataSource<T>, ReadOnlyDataSource<T> {\n    /**\n     * The current value of this data source, can be changed through update\n     */\n    public value: T;\n    private primed: boolean;\n    private updating: boolean;\n    public name: string;\n    protected updateEvent: EventEmitter<T>;\n    protected errorHandler: (error: any) => T;\n    protected errorEvent: EventEmitter<Error>;\n\n    constructor(initialValue?: T, name: string = 'RootDataSource') {\n        this.name = name;\n        this.value = initialValue;\n        if (debugMode) {\n            debugRegisterStream(this, new Error().stack);\n        }\n        this.primed = initialValue !== undefined;\n        this.errorEvent = new EventEmitter();\n        this.updateEvent = new EventEmitter();\n    }\n\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    public static toDataSource<T>(value: T | DataSource<T>): DataSource<T> {\n        if (value instanceof DataSource) {\n            return value;\n        } else {\n            return new DataSource(value);\n        }\n    }\n\n    public static fromEvent<T>(event: EventEmitter<T>, cancellation: CancellationToken): DataSource<T> {\n        const result = new DataSource<T>();\n        event.subscribe((v) => result.update(v), cancellation);\n        return result;\n    }\n\n    /**\n     * Connects to an aurum-server exposed datasource. View https://github.com/CyberPhoenix90/aurum-server for more information\n     * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated\n     * @param  {AurumServerInfo} aurumServerInfo\n     * @returns DataSource\n     */\n    public static fromRemoteSource<T>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): DataSource<T> {\n        const result = new DataSource<T>();\n\n        syncDataSource(result, aurumServerInfo, cancellation);\n\n        return result;\n    }\n\n    public static fromMultipleSources<T>(sources: ReadOnlyDataSource<T>[], cancellation?: CancellationToken): DataSource<T> {\n        const result = new DataSource<T>();\n\n        for (const s of sources) {\n            if (debugMode) {\n                debugRegisterLink(s as any, result);\n            }\n            (s as any).listenInternal((v) => result.update(v), cancellation);\n        }\n\n        result.name = `Combination of [${sources.map((v) => v.name).join(' & ')}]`;\n\n        return result;\n    }\n\n    public static fromAsyncIterator<T>(iterator: AsyncIterableIterator<T>, cancellation?: CancellationToken): DataSource<T> {\n        const result = new DataSource<T>();\n\n        (async () => {\n            try {\n                for await (const item of iterator) {\n                    if (cancellation?.isCancelled) {\n                        return;\n                    }\n                    result.update(item);\n                }\n            } catch (e) {\n                result.emitError(e);\n            }\n        })();\n\n        return result;\n    }\n\n    public static fromPromise<T>(promise: Promise<T>, cancellation?: CancellationToken): DataSource<T> {\n        const result = new DataSource<T>();\n\n        promise.then((v) => {\n            if (cancellation?.isCancelled) {\n                return;\n            }\n            result.update(v);\n        }, result.emitError.bind(result));\n\n        return result;\n    }\n\n    public static fromPromiseArray<T>(promises: Promise<T>[], cancellation?: CancellationToken): DataSource<T> {\n        const result = new DataSource<T>();\n\n        (async () => {\n            for await (const promise of promiseIterator(promises, cancellation)) {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                if (promise.status === 'fulfilled') {\n                    result.update(promise.value);\n                } else {\n                    result.emitError(promise.reason);\n                }\n            }\n        })();\n\n        return result;\n    }\n\n    public toAsyncIterator(cancellation?: CancellationToken): AsyncIterableIterator<T> {\n        return this.updateEvent.toAsyncIterator(cancellation);\n    }\n\n    /**\n     * Allows tapping into the stream and calls a function for each value.\n     */\n    public tap(callback: (value: T) => void, cancellationToken?: CancellationToken): DataSource<T> {\n        this.listen((value) => {\n            callback(value);\n        }, cancellationToken);\n        return this;\n    }\n    /**\n     * Assign a function to handle errors and map them back to regular values. Rethrow the error in case you want to fallback to emitting error\n     */\n    public handleErrors(callback: (error: any) => T): this {\n        this.errorHandler = callback;\n        return this;\n    }\n\n    public onError(callback: (error: any) => void, cancellationToken?: CancellationToken): this {\n        this.errorEvent.subscribe(callback, cancellationToken);\n        return this;\n    }\n\n    public emitError(e: Error): void {\n        if (this.errorHandler) {\n            try {\n                return this.update(this.errorHandler(e));\n            } catch (newError) {\n                e = newError;\n            }\n        }\n        if (this.errorEvent.hasSubscriptions()) {\n            this.errorEvent.fire(e);\n        } else {\n            throw e;\n        }\n    }\n\n    /**\n     * Updates with the same value as the last value\n     */\n    public repeatLast(): this {\n        this.update(this.value);\n        return this;\n    }\n\n    /**\n     * Updates the value in the data source and calls the listen callback for all listeners\n     * @param newValue new value for the data source\n     */\n    public update(newValue: T): void {\n        //@ts-expect-error Typescript tries to be smart and thinks this could never happen but it can with the any type as T\n        if (newValue === this) {\n            throw new Error('Cannot update data source with itself');\n        }\n\n        this.primed = true;\n        if (this.updating) {\n            throw new Error(\n                'Problem in data source: Unstable value propagation. When updating a value the stream was updated back as a direct response. This can lead to infinite loops and is therefore not allowed'\n            );\n        }\n        this.updating = true;\n        this.value = newValue;\n        this.updateEvent.fire(newValue);\n        if (debugMode) {\n            debugDeclareUpdate(this, newValue, new Error().stack);\n        }\n        this.updating = false;\n    }\n\n    /**\n     * Updates the data source with a value if it has never had a value before\n     */\n    public withInitial(value: T): this {\n        if (!this.primed) {\n            this.update(value);\n        }\n\n        return this;\n    }\n\n    /**\n     * Same as listen but will immediately call the callback with the current value first\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenAndRepeat(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        if (this.primed) {\n            callback(this.value);\n        }\n        return this.listen(callback, cancellationToken);\n    }\n\n    private listenAndRepeatInternal(callback: Callback<T>, cancellationToken?: CancellationToken, parent?: ReadOnlyDataSource<any>): Callback<void> {\n        callback(this.value);\n        return this.listenInternal(callback, cancellationToken, parent);\n    }\n\n    /**\n     * Subscribes to the updates of the data stream\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listen(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        if (debugMode) {\n            debugRegisterConsumer(this, callback.toString(), new Error().stack);\n        }\n        return this.listenInternal(callback, cancellationToken);\n    }\n\n    private listenInternal(callback: Callback<T>, cancellationToken?: CancellationToken, parent?: ReadOnlyDataSource<any>): Callback<void> {\n        const cancel = this.updateEvent.subscribe(callback, cancellationToken).cancel;\n\n        return cancel;\n    }\n\n    /**\n     * Subscribes to the updates of the data stream for a single update\n     * @param callback Callback to call when value is updated\n     * @param cancellationToken Optional token to control the cancellation of the subscription\n     * @returns Cancellation callback, can be used to cancel subscription without a cancellation token\n     */\n    public listenOnce(callback: Callback<T>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateEvent.subscribeOnce(callback, cancellationToken).cancel;\n    }\n\n    public transform<A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n        operationA: DataSourceOperator<T, A>,\n        operationB?: DataSourceOperator<A, B> | CancellationToken,\n        operationC?: DataSourceOperator<B, C> | CancellationToken,\n        operationD?: DataSourceOperator<C, D> | CancellationToken,\n        operationE?: DataSourceOperator<D, E> | CancellationToken,\n        operationF?: DataSourceOperator<E, F> | CancellationToken,\n        operationG?: DataSourceOperator<F, G> | CancellationToken,\n        operationH?: DataSourceOperator<G, H> | CancellationToken,\n        operationI?: DataSourceOperator<H, I> | CancellationToken,\n        operationJ?: DataSourceOperator<I, J> | CancellationToken,\n        operationK?: DataSourceOperator<J, K> | CancellationToken,\n        cancellationToken?: CancellationToken\n    ): DataSource<K> {\n        let token;\n        const operations: DataSourceOperator<any, any>[] = [\n            operationA,\n            operationB,\n            operationC,\n            operationD,\n            operationE,\n            operationF,\n            operationG,\n            operationH,\n            operationI,\n            operationJ,\n            operationK\n        ].filter((e) => e && (e instanceof CancellationToken ? ((token = e), false) : true)) as DataSourceOperator<any, any>[];\n        if (cancellationToken) {\n            token = cancellationToken;\n        }\n        const result = new DataSource<K>(undefined, this.name + ' ' + operations.map((v) => v.name).join(' '));\n        if (debugMode) {\n            debugRegisterLink(this, result);\n        }\n        (this.primed ? this.listenAndRepeatInternal : this.listenInternal).call(this, processTransform<T, K>(operations as any, result), token);\n        this.onError((e) => result.emitError(e), token);\n\n        return result;\n    }\n    public static fromCombination<T>(sources: ReadOnlyDataSource<T>[], cancellationToken?: CancellationToken): DataSource<T> {\n        if (sources.length === 0) {\n            throw new Error('Cannot combine zero data sources');\n        }\n\n        return sources[0].combine(sources.slice(1), cancellationToken);\n    }\n\n    public static fromAggregation<R, A>(sources: [ReadOnlyDataSource<A>], combinator: (first: A) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    public static fromAggregation<R, A, B>(\n        sources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>],\n        combinator: (first: A, second: B) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C>(\n        sources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>],\n        combinator: (first: A, second: B, third: C) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C, D>(\n        sources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>],\n        combinator: (first: A, second: B, third: C, fourth: D) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C, D, E>(\n        sources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>],\n        combinator: (first: A, second: B, third: C, fourth: D, fifth: E) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C, D, E, F>(\n        sources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>, ReadOnlyDataSource<F>],\n        combinator: (first: A, second: B, third: C, fourth: D, fifth: E, sixth: F) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C, D, E, F, G>(\n        sources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>\n        ],\n        combinator: (first: A, second: B, third: C, fourth: D, fifth: E, sixth: F, seventh: G) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C, D, E, F, G, H>(\n        sources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (first: A, second: B, third: C, fourth: D, fifth: E, sixth: F, seventh: G, eigth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R, A, B, C, D, E, F, G, H, I>(\n        sources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>,\n            ReadOnlyDataSource<I>\n        ],\n        combinator: (first: A, second: B, third: C, fourth: D, fifth: E, sixth: F, seventh: G, eigth: H, ninth: I) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public static fromAggregation<R>(\n        sources: ReadOnlyDataSource<any>[],\n        combinator: (...data: any[]) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n\n        const aggregatedSource = new DataSource<R>(combinator(...sources.map((s) => s?.value)));\n\n        for (let i = 0; i < sources.length; i++) {\n            sources[i]?.listen(() => {\n                aggregatedSource.update(combinator(...sources.map((s) => s?.value)));\n            }, cancellationToken);\n        }\n\n        return aggregatedSource;\n    }\n\n    /**\n     * Combines two or more sources into a new source that listens to updates from both parent sources and combines them\n     * @param otherSource Second parent for the new source\n     * @param combinator Method allowing you to combine the data from both parents on update. Called each time a parent is updated with the latest values of both parents\n     * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources\n     */\n    public aggregate<R, A>(otherSources: [ReadOnlyDataSource<A>], combinator: (self: T, other: A) => R, cancellationToken?: CancellationToken): DataSource<R>;\n    public aggregate<R, A, B>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>],\n        combinator: (self: T, second: A, third: B) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>],\n        combinator: (self: T, second: A, third: B, fourth: C) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E>(\n        otherSources: [ReadOnlyDataSource<A>, ReadOnlyDataSource<B>, ReadOnlyDataSource<C>, ReadOnlyDataSource<D>, ReadOnlyDataSource<E>],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R, A, B, C, D, E, F, G, H, I>(\n        otherSources: [\n            ReadOnlyDataSource<A>,\n            ReadOnlyDataSource<B>,\n            ReadOnlyDataSource<C>,\n            ReadOnlyDataSource<D>,\n            ReadOnlyDataSource<E>,\n            ReadOnlyDataSource<F>,\n            ReadOnlyDataSource<G>,\n            ReadOnlyDataSource<H>,\n            ReadOnlyDataSource<I>\n        ],\n        combinator: (self: T, second: A, third: B, fourth: C, fifth: D, sixth: E, seventh: F, eigth: G, ninth: H, tenth: I) => R,\n        cancellationToken?: CancellationToken\n    ): DataSource<R>;\n    public aggregate<R>(otherSources: ReadOnlyDataSource<any>[], combinator: (...data: any[]) => R, cancellationToken?: CancellationToken): DataSource<R> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n\n        const aggregatedSource = new DataSource<R>(combinator(this.value, ...otherSources.map((s) => s?.value)));\n\n        for (let i = 0; i < otherSources.length; i++) {\n            otherSources[i]?.listen(() => {\n                aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s?.value)));\n            }, cancellationToken);\n        }\n\n        this.listen(() => aggregatedSource.update(combinator(this.value, ...otherSources.map((s) => s?.value))), cancellationToken);\n\n        return aggregatedSource;\n    }\n\n    /**\n     * Forwards all updates from this source to another\n     * @param targetDataSource datasource to pipe the updates to\n     * @param cancellationToken  Cancellation token to cancel the subscription the target datasource has to this datasource\n     */\n    public pipe(targetDataSource: DataSource<T>, cancellationToken?: CancellationToken): this {\n        this.listen((v) => targetDataSource.update(v), cancellationToken);\n\n        return this;\n    }\n\n    /**\n     * Like aggregate except that it aggregates an array data source of datasources\n     * @param data Second parent for the new source\n     * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources\n     */\n    public static dynamicAggregation<I, O>(\n        data: ReadOnlyArrayDataSource<ReadOnlyDataSource<I>>,\n        aggregate: (items: readonly I[]) => O,\n        cancellationToken?: CancellationToken\n    ): DataSource<O> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n        const session = new WeakMap<ReadOnlyDataSource<I>, CancellationToken>();\n\n        const result = new DataSource<O>();\n        data.listenAndRepeat((change) => {\n            for (const item of change.items) {\n                listenToSubSource(item);\n            }\n            result.update(aggregate(data.getData().map((e) => e.value)));\n        });\n\n        data.onItemsAdded.subscribe((items) => {\n            for (const item of items) {\n                listenToSubSource(item);\n            }\n        });\n\n        data.onItemsRemoved.subscribe((items) => {\n            for (const item of items) {\n                session.get(item).cancel();\n                session.delete(item);\n            }\n        });\n\n        return result;\n\n        function listenToSubSource(item: ReadOnlyDataSource<I>) {\n            session.set(item, new CancellationToken());\n            item.listen(() => {\n                result.update(aggregate(data.getData().map((e) => e.value)));\n            }, session.get(item));\n        }\n    }\n\n    /**\n     * Like aggregate except that no combination method is needed as a result both parents must have the same type and the new stream just exposes the last update recieved from either parent\n     * @param otherSource Second parent for the new source\n     * @param cancellationToken  Cancellation token to cancel the subscriptions the new datasource has to the two parent datasources\n     */\n    public combine(otherSources: ReadOnlyDataSource<T>[], cancellationToken?: CancellationToken): DataSource<T> {\n        cancellationToken = cancellationToken ?? new CancellationToken();\n\n        let combinedDataSource: DataSource<T> | DuplexDataSource<T>;\n        if (this.primed) {\n            combinedDataSource = new DataSource<T>(this.value);\n        } else {\n            combinedDataSource = new DataSource<T>();\n        }\n        this.pipe(combinedDataSource, cancellationToken);\n        for (const otherSource of otherSources) {\n            otherSource.pipe(combinedDataSource, cancellationToken);\n        }\n\n        return combinedDataSource;\n    }\n\n    /**\n     * Returns a promise that resolves when the next update occurs\n     * @param cancellationToken\n     */\n    public awaitNextUpdate(cancellationToken?: CancellationToken): Promise<T> {\n        return new Promise((resolve) => {\n            this.listenOnce((value) => resolve(value), cancellationToken);\n        });\n    }\n\n    /**\n     * Remove all listeners\n     */\n    public cancelAll(): void {\n        this.updateEvent.cancelAll();\n    }\n}\n\ntype DetailedOperations = 'replace' | 'append' | 'prepend' | 'removeRight' | 'removeLeft' | 'remove' | 'swap' | 'clear' | 'merge' | 'insert';\n\nexport interface CollectionChange<T> {\n    operation: 'replace' | 'swap' | 'add' | 'remove' | 'merge';\n    operationDetailed: DetailedOperations;\n    count?: number;\n    index: number;\n    index2?: number;\n    target?: T;\n    items: T[];\n    newState: T[];\n    previousState?: T[];\n}\n\nexport interface ReadOnlyArrayDataSource<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n    onItemsAdded: EventEmitter<T[]>;\n    onItemsRemoved: EventEmitter<T[]>;\n    listenAndRepeat(callback: Callback<CollectionChange<T>>, cancellationToken?: CancellationToken): Callback<void>;\n    listen(callback: Callback<CollectionChange<T>>, cancellationToken?: CancellationToken): Callback<void>;\n    listenOnce(callback: Callback<CollectionChange<T>>, cancellationToken?: CancellationToken): Callback<void>;\n    awaitNextUpdate(cancellationToken?: CancellationToken): Promise<CollectionChange<T>>;\n    length: ReadOnlyDataSource<number>;\n    getData(): ReadonlyArray<T>;\n    get(index: number): T;\n    pickAt(index: number, cancellationToken?: CancellationToken): ReadOnlyDataSource<T>;\n    limit(count: number, cancellationToken?: CancellationToken): ReadOnlyArrayDataSource<T>;\n    indexOf(item: T): number;\n    find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T;\n    findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;\n    lastIndexOf(item: T): number;\n    includes(item: T): boolean;\n    some(cb: (item: T, index: number, array: T[]) => boolean): boolean;\n    every(cb: (item: T, index: number, array: T[]) => boolean): boolean;\n    toArray(): T[];\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void): void;\n    reverse(cancellationToken?: CancellationToken, config?: ViewConfig): ReadOnlyArrayDataSource<T>;\n    flat(\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): T extends ReadOnlyArrayDataSource<infer U> ? ReadOnlyArrayDataSource<U> : ReadOnlyArrayDataSource<FlatArray<T, 1>>;\n    sort(\n        comparator?: (a: T, b: T) => number,\n        dependencies?: ReadOnlyDataSource<any>[],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<T>;\n    map<D>(\n        mapper: (data: T) => D,\n        dependencies?: ReadOnlyDataSource<any>[],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<D>;\n    slice(\n        start: number | DataSource<number>,\n        end?: number | DataSource<number>,\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<T>;\n    reduce<R>(reducer: (acc: R, value: T) => R, initial?: R, cancellationToken?: CancellationToken): DataSource<R>;\n    unique(cancellationToken?: CancellationToken, config?: ViewConfig): ReadOnlyArrayDataSource<T>;\n    indexBy<K extends keyof T>(key: K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<T[K], T>;\n    indexByProvider<K>(provider: (item: T) => K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<K, T>;\n    groupBy<K extends keyof T>(key: K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<T[K], ReadOnlyArrayDataSource<T>>;\n    groupByProvider<K>(provider: (item: T) => K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<K, ReadOnlyArrayDataSource<T>>;\n    groupByMultiProvider<K>(\n        provider: (item: T) => K[],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): MapDataSource<K, ReadOnlyArrayDataSource<T>>;\n    filter(\n        callback: Predicate<T>,\n        dependencies?: ReadOnlyDataSource<any>[],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<T>;\n    toSetDataSource(cancellationToken: CancellationToken): ReadOnlySetDataSource<T>;\n    pipe(target: ArrayDataSource<T>, cancellation?: CancellationToken): void;\n}\n\nexport class ArrayDataSource<T> implements ReadOnlyArrayDataSource<T> {\n    protected data: T[];\n    protected updateEvent: EventEmitter<CollectionChange<T>>;\n    private lengthSource: DataSource<number>;\n    private name: string;\n    public onItemsAdded: EventEmitter<T[]> = new EventEmitter();\n    public onItemsRemoved: EventEmitter<T[]> = new EventEmitter();\n\n    constructor(initialData?: T[], name: string = 'RootArrayDataSource') {\n        this.name = name;\n        if (initialData) {\n            this.data = initialData.slice();\n        } else {\n            this.data = [];\n        }\n        this.lengthSource = new DataSource(this.data.length, this.name + '.length');\n        this.updateEvent = new EventEmitter();\n    }\n\n    *[Symbol.iterator](): IterableIterator<T> {\n        yield* this.getData();\n        return;\n    }\n\n    /**\n     * Returns a datasource that always contains the item that is currently at the specified index\n     * @param index\n     * @param cancellationToken\n     * @returns\n     */\n    public pickAt(index: number, cancellationToken?: CancellationToken): ReadOnlyDataSource<T> {\n        if (index < 0) {\n            throw new Error('Index out of bounds');\n        }\n\n        const result = new DataSource<T>(this.data[index], this.name + `[${index}]`);\n        this.listen((change) => {\n            if (result.value !== change.newState[index]) {\n                result.update(change.newState[index]);\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public toSetDataSource(cancellationToken: CancellationToken): ReadOnlySetDataSource<T> {\n        const result = new SetDataSource<T>();\n\n        this.listenAndRepeat((change) => {\n            switch (change.operation) {\n                case 'add':\n                    for (const item of change.items) {\n                        result.add(item);\n                    }\n                    break;\n                case 'remove':\n                    for (const item of change.items) {\n                        if (!this.includes(item)) {\n                            result.delete(item);\n                        }\n                    }\n                    break;\n                case 'replace':\n                    if (!this.includes(change.target)) {\n                        result.delete(change.target);\n                    }\n\n                    for (const item of change.items) {\n                        result.add(item);\n                    }\n                    break;\n\n                case 'merge':\n                    result.clear();\n                    for (const item of change.items) {\n                        result.add(item);\n                    }\n                    break;\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public toString(): string {\n        return this.data.toString();\n    }\n\n    public static fromFetchText(\n        response: Response,\n        config: { onComplete?: () => void; itemSeperatorSequence: string } = { itemSeperatorSequence: '\\n' }\n    ): ArrayDataSource<string> {\n        const decoder = new TextDecoder('utf-8');\n        const stream = new ArrayDataSource<string>();\n        const { onComplete, itemSeperatorSequence } = config;\n\n        let buffer: string = '';\n        const readerStream = response.body.getReader();\n        function read(reader: ReadableStreamDefaultReader<Uint8Array>): void {\n            reader.read().then(({ done, value }) => {\n                if (!done) {\n                    const data = (buffer + decoder.decode(value)).split(itemSeperatorSequence);\n                    buffer = data.splice(data.length - 1, 1)[0];\n                    stream.appendArray(data);\n                    read(reader);\n                } else {\n                    if (buffer.length) {\n                        stream.push(buffer);\n                    }\n                    onComplete?.();\n                }\n            });\n        }\n        read(readerStream);\n\n        return stream;\n    }\n\n    public static fromFetchJSON<T>(\n        response: Response,\n        config: {\n            onParseError?: (item) => T;\n            onComplete?: () => void;\n            itemSeperatorSequence?: string;\n        } = {\n            itemSeperatorSequence: '\\n'\n        }\n    ): ArrayDataSource<T> {\n        const decoder = new TextDecoder('utf-8');\n        const stream = new ArrayDataSource<T>();\n        const { onParseError, onComplete, itemSeperatorSequence = '\\n' } = config;\n\n        let buffer: string = '';\n        const readerStream = response.body.getReader();\n        function read(reader: ReadableStreamDefaultReader<Uint8Array>): void {\n            reader.read().then(({ done, value }) => {\n                if (!done) {\n                    const data = (buffer + decoder.decode(value)).split(itemSeperatorSequence);\n                    buffer = data.splice(data.length - 1, 1)[0];\n\n                    for (const item of data) {\n                        parseAndPush(item);\n                    }\n\n                    read(reader);\n                } else {\n                    if (buffer.length) {\n                        parseAndPush(buffer);\n                    }\n                    onComplete?.();\n                }\n            });\n        }\n        read(readerStream);\n\n        function parseAndPush(item: string) {\n            try {\n                stream.push(JSON.parse(item));\n            } catch (e) {\n                try {\n                    stream.push(onParseError(item));\n                } catch (e) {\n                    // Ignore item if it can't be parsed and/or no error handler is provided\n                }\n            }\n        }\n\n        return stream;\n    }\n\n    /**\n     * Connects to an aurum-server exposed array datasource. View https://github.com/CyberPhoenix90/aurum-server for more information\n     * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated\n     * @param  {AurumServerInfo} aurumServerInfo\n     * @returns DataSource\n     */\n    public static fromRemoteSource<T>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): ArrayDataSource<T> {\n        const result = new ArrayDataSource<T>();\n\n        syncArrayDataSource(result, aurumServerInfo, cancellation);\n\n        return result;\n    }\n\n    public static fromMultipleSources<T>(\n        sources: Array<ReadOnlyArrayDataSource<T> | T[] | ReadOnlyDataSource<T>>,\n        cancellationToken?: CancellationToken\n    ): ReadOnlyArrayDataSource<T> {\n        const boundaries = [0];\n        const result = new ArrayDataSource<T>(\n            undefined,\n            `ArrayDataSource of (${sources.reduce((p, c) => p + (c instanceof ArrayDataSource ? c.name + ' ' : ''), '')})`\n        );\n\n        for (let i = 0; i < sources.length; i++) {\n            const item = sources[i];\n            if (Array.isArray(item)) {\n                result.appendArray(item as T[]);\n            } else if (item instanceof DataSource || item instanceof DuplexDataSource) {\n                let index = i;\n                item.transform(\n                    dsDiff(),\n                    dsTap(({ newValue, oldValue }) => {\n                        let sizeDiff = 0;\n                        let oldSize = 0;\n                        let newSize = 0;\n                        if (Array.isArray(oldValue)) {\n                            oldSize = oldValue.length;\n                            sizeDiff -= oldValue.length;\n                        } else if (oldValue !== undefined) {\n                            oldSize = 1;\n                            sizeDiff--;\n                        }\n\n                        if (Array.isArray(newValue)) {\n                            sizeDiff += newValue.length;\n                            newSize = newValue.length;\n                        } else if (newValue !== undefined) {\n                            sizeDiff++;\n                            newSize = 1;\n                        }\n\n                        if (Array.isArray(newValue)) {\n                            for (let i = 0; i < newValue.length; i++) {\n                                if (i < oldSize) {\n                                    result.set(boundaries[index] + i, newValue[i]);\n                                } else {\n                                    result.insertAt(boundaries[index] + i, newValue[i]);\n                                }\n                            }\n                        } else if (newValue !== undefined) {\n                            if (newSize <= oldSize) {\n                                result.set(boundaries[index], newValue);\n                            } else {\n                                result.insertAt(boundaries[index], newValue);\n                            }\n                        }\n                        for (let i = 0; i < oldSize - newSize; i++) {\n                            result.removeAt(boundaries[index] + newSize);\n                        }\n\n                        for (let i = index + 1; i < boundaries.length; i++) {\n                            boundaries[i] += sizeDiff;\n                        }\n                    }),\n                    cancellationToken\n                );\n            } else {\n                result.appendArray((sources[i] as ArrayDataSource<T>).data ?? []);\n                let index = i;\n                (sources[i] as ArrayDataSource<T>).listen((change) => {\n                    switch (change.operationDetailed) {\n                        case 'append':\n                        case 'prepend':\n                        case 'insert':\n                            result.insertAt(change.index + boundaries[index], ...change.items);\n                            for (let i = index + 1; i < boundaries.length; i++) {\n                                boundaries[i] += change.count;\n                            }\n                            break;\n                        case 'remove':\n                        case 'removeLeft':\n                        case 'removeRight':\n                        case 'clear':\n                            result.removeRange(change.index + boundaries[index], change.index + boundaries[index] + change.count);\n                            for (let i = index + 1; i < boundaries.length; i++) {\n                                boundaries[i] -= change.count;\n                            }\n                            break;\n                        case 'merge':\n                            const lengthDiff = change.newState.length + change.previousState.length;\n                            result.removeRange(change.index + boundaries[index], change.index + boundaries[index] + change.previousState.length);\n                            result.insertAt(change.index + boundaries[index], ...change.newState);\n                            if (lengthDiff != 0) {\n                                for (let i = index + 1; i < boundaries.length; i++) {\n                                    boundaries[i] += lengthDiff;\n                                }\n                            }\n                            break;\n                        case 'replace':\n                            result.set(change.index + boundaries[index], change.items[0]);\n                            break;\n                        case 'swap':\n                            result.swap(change.index + boundaries[index], change.index2 + boundaries[index]);\n                            break;\n                    }\n                }, cancellationToken);\n            }\n            boundaries.push(result.length.value);\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates a new array data source where the type T is no longer wrapped by a DataSource however the values of these data sources are observed on the parent\n     * array data source and changes are forwarded to the new array data source through array mutations. This makes it possible to use view methods such as map and filter\n     * on the raw data instead of on data sources to cover highly dynamic use cases\n     */\n    public static DynamicArrayDataSourceToArrayDataSource<T>(\n        arrayDataSource:\n            | ReadOnlyArrayDataSource<ReadOnlyDataSource<T> | T>\n            | ReadOnlyArrayDataSource<DataSource<T> | T>\n            | ReadOnlyArrayDataSource<DataSource<T>>\n            | ReadOnlyArrayDataSource<ReadOnlyDataSource<T>>\n            | ReadOnlyArrayDataSource<GenericDataSource<T>>\n            | ReadOnlyArrayDataSource<DuplexDataSource<T>>,\n        cancellation: CancellationToken\n    ): ReadOnlyArrayDataSource<T> {\n        const result = new ArrayDataSource<T>();\n        const session = new WeakMap<any, CancellationToken>();\n        arrayDataSource.listenAndRepeat(({ operationDetailed, index, index2, count, items, previousState, newState, target }) => {\n            switch (operationDetailed) {\n                case 'append':\n                    for (const item of items) {\n                        listenToItem(item);\n                    }\n                    result.appendArray(items.map((item) => getValueOf(item)));\n                    break;\n                case 'prepend':\n                    for (const item of items) {\n                        listenToItem(item);\n                    }\n                    result.unshift(...items.map((item) => getValueOf(item)));\n                    break;\n                case 'merge':\n                    for (const item of previousState) {\n                        stopLitenToItem(item);\n                    }\n                    for (const item of newState) {\n                        listenToItem(item);\n                    }\n                    result.merge(newState.map((i) => getValueOf(i)));\n                    break;\n                case 'insert':\n                    for (const item of items) {\n                        listenToItem(item);\n                    }\n                    result.insertAt(index, ...items.map((item) => getValueOf(item)));\n                    break;\n                case 'clear':\n                    for (const item of previousState) {\n                        stopLitenToItem(item);\n                    }\n                    result.clear();\n                    break;\n                case 'remove':\n                    for (const item of items) {\n                        stopLitenToItem(item);\n                    }\n                    result.removeRange(index, index + count);\n                    break;\n                case 'removeLeft':\n                    for (const item of items) {\n                        stopLitenToItem(item);\n                    }\n                    result.removeLeft(count);\n                    break;\n                case 'removeRight':\n                    for (const item of items) {\n                        stopLitenToItem(item);\n                    }\n                    result.removeRight(count);\n                    break;\n                case 'replace':\n                    stopLitenToItem(target);\n                    listenToItem(items[0]);\n                    result.set(index, getValueOf(items[0]));\n                    break;\n                case 'swap':\n                    result.swap(index, index2);\n                    break;\n            }\n        }, cancellation);\n        return result;\n\n        function listenToItem(item: ReadOnlyDataSource<T> | T | DataSource<T> | GenericDataSource<T> | DuplexDataSource<T>) {\n            if (typeof item !== 'object' || !('listen' in item)) {\n                return;\n            }\n\n            session.set(item, new CancellationToken());\n            cancellation.chain(session.get(item));\n            item.listen((value) => {\n                result.set(arrayDataSource.indexOf(item as any), value);\n            }, session.get(item));\n        }\n\n        function stopLitenToItem(item: ReadOnlyDataSource<T> | T) {\n            if (session.has(item)) {\n                session.get(item).cancel();\n                session.delete(item);\n            }\n        }\n    }\n\n    public static fromAsyncIterator<T>(iterator: AsyncIterableIterator<T>, cancellation?: CancellationToken): ArrayDataSource<T> {\n        const result = new ArrayDataSource<T>();\n\n        (async () => {\n            for await (const item of iterator) {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                result.push(item);\n            }\n        })();\n\n        return result;\n    }\n\n    public static fromPromiseArray<T>(promises: Promise<T>[], cancellation?: CancellationToken): ArrayDataSource<PromiseSettledResult<T>> {\n        const result = new ArrayDataSource<PromiseSettledResult<T>>();\n\n        (async () => {\n            for await (const promise of promiseIterator(promises, cancellation)) {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                result.push(promise);\n            }\n        })();\n\n        return result;\n    }\n\n    public toAsyncIterator(cancellation?: CancellationToken): AsyncIterableIterator<CollectionChange<T>> {\n        return this.updateEvent.toAsyncIterator(cancellation);\n    }\n\n    public static toArrayDataSource<T>(value: T[] | ArrayDataSource<T>): ArrayDataSource<T> {\n        if (value instanceof ArrayDataSource) {\n            return value;\n        } else {\n            return new ArrayDataSource(value);\n        }\n    }\n\n    public pipe(target: ArrayDataSource<T>, cancellation?: CancellationToken): void {\n        this.listenAndRepeat((c) => target.applyCollectionChange(c), cancellation);\n    }\n\n    /**\n     * Remove all listeners\n     */\n    public cancelAll(): void {\n        this.onItemsAdded.cancelAll();\n        this.onItemsRemoved.cancelAll();\n        this.updateEvent.cancelAll();\n    }\n\n    /**\n     * Same as listen but will immediately call the callback with an append of all existing elements first\n     */\n    public listenAndRepeat(callback: Callback<CollectionChange<T>>, cancellationToken?: CancellationToken): Callback<void> {\n        if (this.data.length) {\n            callback({\n                operation: 'add',\n                operationDetailed: 'append',\n                index: 0,\n                items: this.data,\n                newState: this.data,\n                count: this.data.length\n            });\n        }\n        return this.listen(callback, cancellationToken);\n    }\n\n    /**\n     * Sends a reset signal followed by an append with all items signal. This will force all the views of this source the synchronize can be useful in case your views rely on non pure transformation functions.\n     */\n    public repeatCurrentState(): void {\n        this.update({\n            operation: 'remove',\n            operationDetailed: 'clear',\n            count: this.data.length,\n            index: 0,\n            items: this.data,\n            newState: []\n        });\n        this.update({\n            operation: 'add',\n            operationDetailed: 'append',\n            index: 0,\n            items: this.data,\n            newState: this.data,\n            count: this.data.length\n        });\n    }\n\n    public listen(callback: Callback<CollectionChange<T>>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    public listenOnce(callback: Callback<CollectionChange<T>>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateEvent.subscribeOnce(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Applies the changes described in the colleciton change to the array. Useful for synchronizing array data sources over the network or workers by serializing the changes and sending them over\n     * @param collectionChange\n     */\n    public applyCollectionChange(collectionChange: CollectionChange<T>): void {\n        switch (collectionChange.operationDetailed) {\n            case 'append':\n                this.appendArray(collectionChange.items);\n                break;\n            case 'clear':\n                this.clear();\n                break;\n            case 'insert':\n                this.insertAt(collectionChange.index, ...collectionChange.items);\n                break;\n            case 'merge':\n                this.merge(collectionChange.items);\n                break;\n            case 'prepend':\n                this.unshift(...collectionChange.items);\n                break;\n            case 'remove':\n                this.removeRange(collectionChange.index, collectionChange.index + collectionChange.count);\n                break;\n            case 'removeLeft':\n                this.removeLeft(collectionChange.count);\n                break;\n            case 'removeRight':\n                this.removeRight(collectionChange.count);\n                break;\n            case 'replace':\n                this.set(collectionChange.index, collectionChange.items[0]);\n                break;\n            case 'swap':\n                this.swap(collectionChange.index, collectionChange.index2);\n                break;\n        }\n    }\n\n    /**\n     * Returns a promise that resolves when the next update occurs\n     * @param cancellationToken\n     */\n    public awaitNextUpdate(cancellationToken?: CancellationToken): Promise<CollectionChange<T>> {\n        return new Promise((resolve) => {\n            this.listenOnce((value) => resolve(value), cancellationToken);\n        });\n    }\n\n    public get length(): DataSource<number> {\n        return this.lengthSource;\n    }\n\n    public getData(): ReadonlyArray<T> {\n        return this.data;\n    }\n\n    public get(index: number): T {\n        return this.data[index];\n    }\n\n    public set(index: number, item: T): void {\n        const old = this.data[index];\n        if (old === item) {\n            return;\n        }\n        this.data[index] = item;\n        this.update({ operation: 'replace', operationDetailed: 'replace', target: old, count: 1, index, items: [item], newState: this.data });\n        this.onItemsRemoved.fire([old]);\n        this.onItemsAdded.fire([item]);\n\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n    }\n\n    public indexOf(item: T): number {\n        return this.data.indexOf(item);\n    }\n\n    public find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T {\n        return this.data.find(predicate, thisArg);\n    }\n\n    public findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number {\n        return this.data.findIndex(predicate, thisArg);\n    }\n\n    public lastIndexOf(item: T): number {\n        return this.data.lastIndexOf(item);\n    }\n\n    public includes(item: T): boolean {\n        return this.data.includes(item);\n    }\n\n    public replace(item: T, newItem: T): void {\n        const index = this.indexOf(item);\n        if (index !== -1) {\n            this.set(index, newItem);\n        }\n    }\n\n    public swap(indexA: number, indexB: number): void {\n        if (indexA === indexB) {\n            return;\n        }\n\n        const itemA = this.data[indexA];\n        const itemB = this.data[indexB];\n        this.data[indexB] = itemA;\n        this.data[indexA] = itemB;\n\n        this.update({ operation: 'swap', operationDetailed: 'swap', index: indexA, index2: indexB, items: [itemA, itemB], newState: this.data });\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n    }\n\n    public swapItems(itemA: T, itemB: T): void {\n        if (itemA === itemB) {\n            return;\n        }\n\n        const indexA = this.data.indexOf(itemA);\n        const indexB = this.data.indexOf(itemB);\n        if (indexA !== -1 && indexB !== -1) {\n            this.data[indexB] = itemA;\n            this.data[indexA] = itemB;\n        }\n\n        this.update({ operation: 'swap', operationDetailed: 'swap', index: indexA, index2: indexB, items: [itemA, itemB], newState: this.data });\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n    }\n\n    public appendArray(items: T[]) {\n        if (!items || items.length === 0) {\n            return;\n        }\n\n        if (items.length <= 65000) {\n            //Push is significantly faster than concat but it is limited to 65535 items in one push\n            this.data.push.apply(this.data, items);\n        } else {\n            console.warn('Appending over 65000 items in one go can lead to performance issues. Consider streaming your changes progressively');\n            this.data = this.data.concat(items);\n        }\n\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n\n        this.update({\n            operation: 'add',\n            operationDetailed: 'append',\n            count: items.length,\n            index: this.data.length - items.length,\n            items,\n            newState: this.data\n        });\n        this.onItemsAdded.fire(items);\n    }\n\n    public splice(index: number, deleteCount: number, ...insertion: T[]): T[] {\n        let removed = [];\n        if (deleteCount > 0) {\n            removed = this.removeAt(index, deleteCount);\n        }\n\n        if (insertion && insertion.length > 0) {\n            this.insertAt(index, ...insertion);\n        }\n\n        return removed;\n    }\n\n    public insertAt(index: number, ...items: T[]): void {\n        if (items.length === 0) {\n            return;\n        }\n\n        this.data.splice(index, 0, ...items);\n\n        this.update({\n            operation: 'add',\n            operationDetailed: 'insert',\n            count: items.length,\n            index,\n            items,\n            newState: this.data\n        });\n        this.onItemsAdded.fire(items);\n        this.lengthSource.update(this.data.length);\n    }\n\n    public push(...items: T[]) {\n        this.appendArray(items);\n    }\n\n    public unshift(...items: T[]) {\n        this.data.unshift(...items);\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n        this.update({ operation: 'add', operationDetailed: 'prepend', count: items.length, items, index: 0, newState: this.data });\n        this.onItemsAdded.fire(items);\n    }\n\n    public pop(): T {\n        //This could technically just call removeRight(1) but removeRight is based on splicing which creates a new array so this can be significantly faster\n        const item = this.data.pop();\n\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n        this.update({\n            operation: 'remove',\n            operationDetailed: 'removeRight',\n            count: 1,\n            index: this.data.length,\n            items: [item],\n            newState: this.data\n        });\n        this.onItemsRemoved.fire([item]);\n\n        return item;\n    }\n\n    public merge(newData: T[]): void {\n        if (newData.length === 0) {\n            return this.clear();\n        }\n        if (newData === this.data) {\n            return;\n        }\n\n        if (newData.every((v, i) => v === this.data[i])) {\n            if (this.data.length > newData.length) {\n                this.removeRight(this.data.length - newData.length);\n                return;\n            } else {\n                return;\n            }\n        }\n\n        const old = this.data;\n        this.data = newData.slice();\n\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n        this.update({\n            operation: 'merge',\n            operationDetailed: 'merge',\n            previousState: old,\n            index: 0,\n            items: this.data,\n            newState: this.data\n        });\n        this.onItemsRemoved.fire(old);\n        this.onItemsAdded.fire(this.data);\n    }\n\n    public removeRight(count: number): T[] {\n        const length = this.data.length;\n        const result = this.data.splice(length - count, count);\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n        this.update({ operation: 'remove', operationDetailed: 'removeRight', count, index: length - count, items: result, newState: this.data });\n        this.onItemsRemoved.fire(result);\n\n        return result;\n    }\n\n    public removeLeft(count: number): void {\n        const removed = this.data.splice(0, count);\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n        this.update({ operation: 'remove', operationDetailed: 'removeLeft', count, index: 0, items: removed, newState: this.data });\n        this.onItemsRemoved.fire(removed);\n    }\n\n    public removeWhere(reject: (v: T) => boolean): void {\n        const removed = this.data.filter(reject);\n        for (const item of removed) {\n            this.remove(item);\n        }\n    }\n\n    public removeAt(index: number, count: number = 1): T[] {\n        const removed = this.data.splice(index, count);\n        this.update({ operation: 'remove', operationDetailed: 'remove', count: removed.length, index, items: removed, newState: this.data });\n        this.onItemsRemoved.fire(removed);\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n\n        return removed;\n    }\n\n    public removeRange(start: number, end: number): T[] {\n        const removed = this.data.splice(start, end - start);\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n        this.update({ operation: 'remove', operationDetailed: 'remove', count: removed.length, index: start, items: removed, newState: this.data });\n        this.onItemsRemoved.fire(removed);\n\n        return removed;\n    }\n\n    public remove(item: T): T {\n        const index = this.data.indexOf(item);\n        if (index !== -1) {\n            return this.removeAt(index)[0];\n        } else {\n            return undefined;\n        }\n    }\n\n    public clear(): void {\n        if (this.data.length === 0) {\n            return;\n        }\n\n        const items = this.data;\n        this.data = [];\n\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n\n        this.update({\n            operation: 'remove',\n            operationDetailed: 'clear',\n            count: items.length,\n            index: 0,\n            items,\n            previousState: items,\n            newState: this.data\n        });\n        this.onItemsRemoved.fire(items);\n    }\n\n    public some(cb: (item: T, index: number, array: T[]) => boolean): boolean {\n        return this.data.some(cb);\n    }\n\n    public every(cb: (item: T, index: number, array: T[]) => boolean): boolean {\n        return this.data.every(cb);\n    }\n\n    public shift(): T {\n        const item = this.data.shift();\n\n        if (this.lengthSource.value !== this.data.length) {\n            this.lengthSource.update(this.data.length);\n        }\n\n        this.update({ operation: 'remove', operationDetailed: 'removeLeft', items: [item], count: 1, index: 0, newState: this.data });\n        this.onItemsRemoved.fire([item]);\n\n        return item;\n    }\n\n    public toArray(): T[] {\n        return this.data.slice();\n    }\n\n    public flat(\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): T extends ReadOnlyArrayDataSource<infer U> ? ReadOnlyArrayDataSource<U> : ReadOnlyArrayDataSource<FlatArray<T, 1>> {\n        const view = new FlattenedArrayView<any>(this as any, 1, cancellationToken, this.name + '.flat()', config);\n\n        return view as any;\n    }\n\n    public reduce<R>(reducer: (acc: R, value: T) => R, initial?: R, cancellationToken?: CancellationToken): DataSource<R> {\n        const result = new DataSource<R>(initial);\n\n        this.listenAndRepeat((change: CollectionChange<T>) => {\n            switch (change.operationDetailed) {\n                case 'append':\n                    let newVal = result.value;\n                    for (const item of change.items) {\n                        newVal = reducer(newVal, item);\n                    }\n                    result.update(newVal);\n                    break;\n                case 'clear':\n                    result.update(initial);\n                    break;\n                case 'removeRight':\n                case 'removeLeft':\n                case 'prepend':\n                case 'insert':\n                case 'merge':\n                case 'replace':\n                case 'swap':\n                case 'remove':\n                    let newVal2 = initial;\n                    for (const item of change.newState) {\n                        newVal2 = reducer(newVal2, item);\n                    }\n                    result.update(newVal2);\n                    break;\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public reverse(cancellationToken?: CancellationToken, config?: ViewConfig): ReversedArrayView<T> {\n        const view = new ReversedArrayView<T>(this, cancellationToken, this.name + '.reverse()', config);\n\n        return view;\n    }\n\n    public sort(\n        comparator: (a: T, b: T) => number = (a, b) => {\n            if (a == undefined) {\n                return 1;\n            }\n\n            if (b == undefined) {\n                return -1;\n            }\n\n            if (typeof a === 'number' && typeof b === 'number') {\n                return a - b;\n            } else {\n                return a.toString().localeCompare(b.toString());\n            }\n        },\n        dependencies: ReadOnlyDataSource<any>[] = [],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<T> {\n        const view = new SortedArrayView(this, comparator, cancellationToken, this.name + '.sort()', config);\n\n        dependencies.forEach((dep) => {\n            dep.listen(() => view.refresh());\n        }, cancellationToken);\n\n        return view;\n    }\n\n    public slice(\n        start: number | DataSource<number>,\n        end?: number | DataSource<number>,\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<T> {\n        if (typeof start === 'number') {\n            start = new DataSource(start);\n        }\n\n        if (typeof end === 'number') {\n            end = new DataSource(end);\n        }\n\n        if (end === undefined) {\n            end = this.length;\n        }\n\n        return new SlicedArrayView(this, start, end, cancellationToken, this.name + '.slice()', config);\n    }\n\n    public map<D>(\n        mapper: (data: T) => D,\n        dependencies: ReadOnlyDataSource<any>[] = [],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<D> {\n        const view = new MappedArrayView<T, D>(this, mapper, cancellationToken, this.name + '.map()', config);\n\n        dependencies.forEach((dep) => {\n            dep.listen(() => view.refresh());\n        }, cancellationToken);\n\n        return view;\n    }\n\n    public unique(cancellationToken?: CancellationToken, config?: ViewConfig): UniqueArrayView<T> {\n        return new UniqueArrayView(this, cancellationToken, this.name + '.unique()', config);\n    }\n\n    public indexBy<K extends keyof T>(key: K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<T[K], T> {\n        const view = new MapDataSource<T[K], T>();\n\n        this.listenAndRepeat((change) => {\n            if (!config?.ignoredOperations?.includes(change.operationDetailed)) {\n                switch (change.operation) {\n                    case 'add':\n                        for (const item of change.items) {\n                            view.set(item[key], item);\n                        }\n                        break;\n                    case 'remove':\n                        for (const item of change.items) {\n                            view.delete(item[key]);\n                        }\n                        break;\n                    case 'replace':\n                        view.delete(change.target[key]);\n                        view.set(change.items[0][key], change.items[0]);\n                        break;\n                    case 'merge':\n                        const oldKeys = new Set(view.keys());\n                        const newKeys = new Set(change.items.map((item) => item[key]));\n                        for (const oldKey of oldKeys) {\n                            if (!newKeys.has(oldKey)) {\n                                view.delete(oldKey);\n                            }\n                        }\n                        for (const newKey of newKeys) {\n                            if (!oldKeys.has(newKey)) {\n                                view.set(\n                                    newKey,\n                                    change.items.find((item) => item[key] === newKey)\n                                );\n                            }\n                        }\n                        break;\n                }\n            }\n        }, cancellationToken);\n        return view;\n    }\n\n    public indexByProvider<K>(provider: (item: T) => K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<K, T> {\n        const view = new MapDataSource<K, T>();\n\n        this.listenAndRepeat((change) => {\n            if (!config?.ignoredOperations?.includes(change.operationDetailed)) {\n                switch (change.operation) {\n                    case 'add':\n                        for (const item of change.items) {\n                            view.set(provider(item), item);\n                        }\n                        break;\n                    case 'remove':\n                        for (const item of change.items) {\n                            view.delete(provider(item));\n                        }\n                        break;\n                    case 'replace':\n                        view.delete(provider(change.target));\n                        view.set(provider(change.items[0]), change.items[0]);\n                        break;\n                    case 'merge':\n                        const oldKeys = new Set(view.keys());\n                        const newKeys = new Set(change.items.map((item) => provider(item)));\n                        for (const oldKey of oldKeys) {\n                            if (!newKeys.has(oldKey)) {\n                                view.delete(oldKey);\n                            }\n                        }\n                        for (const newKey of newKeys) {\n                            if (!oldKeys.has(newKey)) {\n                                view.set(\n                                    newKey,\n                                    change.items.find((item) => provider(item) === newKey)\n                                );\n                            }\n                        }\n                        break;\n                }\n            }\n        }, cancellationToken);\n        return view;\n    }\n\n    public groupBy<K extends keyof T>(key: K, cancellationToken?: CancellationToken, config?: ViewConfig): MapDataSource<T[K], ReadOnlyArrayDataSource<T>> {\n        const view = new MapDataSource<T[K], ArrayDataSource<T>>();\n\n        function handleRemove(item: T) {\n            const list = view.get(item[key]);\n            list.splice(list.indexOf(item), 1);\n            if (list.length.value === 0) {\n                view.delete(item[key]);\n            }\n        }\n\n        function handleAdd(item: T) {\n            if (!view.has(item[key])) {\n                view.set(item[key], new ArrayDataSource());\n            }\n            view.get(item[key]).push(item);\n        }\n\n        this.listenAndRepeat((change) => {\n            if (!config?.ignoredOperations?.includes(change.operationDetailed)) {\n                switch (change.operation) {\n                    case 'add':\n                        for (const item of change.items) {\n                            handleAdd(item);\n                        }\n                        break;\n                    case 'remove':\n                        for (const item of change.items) {\n                            handleRemove(item);\n                        }\n                        break;\n                    case 'replace':\n                        handleRemove(change.target);\n                        handleAdd(change.items[0]);\n                        break;\n                    case 'merge':\n                        const diff = change.previousState.filter((item) => !change.newState.includes(item));\n                        for (const item of diff) {\n                            if (view.has(item[key]) && view.get(item[key]).includes(item)) {\n                                handleRemove(item);\n                            }\n                        }\n                        for (const item of change.items) {\n                            if (!view.has(item[key])) {\n                                handleAdd(item);\n                            } else {\n                                if (!view.get(item[key]).includes(item)) {\n                                    handleAdd(item);\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n        }, cancellationToken);\n        return view as any as MapDataSource<T[K], ReadOnlyArrayDataSource<T>>;\n    }\n\n    public groupByProvider<K>(\n        provider: (item: T) => K,\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): MapDataSource<K, ReadOnlyArrayDataSource<T>> {\n        const view = new MapDataSource<K, ArrayDataSource<T>>();\n\n        function handleRemove(item: T) {\n            const list = view.get(provider(item));\n            list.splice(list.indexOf(item), 1);\n            if (list.length.value === 0) {\n                view.delete(provider(item));\n            }\n        }\n\n        function handleAdd(item: T) {\n            if (!view.has(provider(item))) {\n                view.set(provider(item), new ArrayDataSource());\n            }\n            view.get(provider(item)).push(item);\n        }\n\n        this.listenAndRepeat((change) => {\n            if (!config?.ignoredOperations?.includes(change.operationDetailed)) {\n                switch (change.operation) {\n                    case 'add':\n                        for (const item of change.items) {\n                            handleAdd(item);\n                        }\n                        break;\n                    case 'remove':\n                        for (const item of change.items) {\n                            handleRemove(item);\n                        }\n                        break;\n                    case 'replace':\n                        handleRemove(change.target);\n                        handleAdd(change.items[0]);\n                        break;\n                    case 'merge':\n                        const diff = change.previousState.filter((item) => !change.newState.includes(item));\n                        for (const item of diff) {\n                            if (view.has(provider(item)) && view.get(provider(item)).includes(item)) {\n                                handleRemove(item);\n                            }\n                        }\n                        for (const item of change.items) {\n                            if (!view.has(provider(item))) {\n                                handleAdd(item);\n                            } else {\n                                if (!view.get(provider(item)).includes(item)) {\n                                    handleAdd(item);\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n        }, cancellationToken);\n        return view as any as MapDataSource<K, ReadOnlyArrayDataSource<T>>;\n    }\n\n    public groupByMultiProvider<K>(\n        provider: (item: T) => K[],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): MapDataSource<K, ReadOnlyArrayDataSource<T>> {\n        const view = new MapDataSource<K, ArrayDataSource<T>>();\n\n        function handleRemove(item: T) {\n            for (const i of provider(item)) {\n                const list = view.get(i);\n                list.splice(list.indexOf(item), 1);\n                if (list.length.value === 0) {\n                    view.delete(i);\n                }\n            }\n        }\n\n        function handleAdd(item: T) {\n            for (const i of provider(item)) {\n                if (!view.has(i)) {\n                    view.set(i, new ArrayDataSource());\n                }\n                view.get(i).push(item);\n            }\n        }\n\n        this.listenAndRepeat((change) => {\n            if (!config?.ignoredOperations?.includes(change.operationDetailed)) {\n                switch (change.operation) {\n                    case 'add':\n                        for (const item of change.items) {\n                            handleAdd(item);\n                        }\n                        break;\n                    case 'remove':\n                        for (const item of change.items) {\n                            handleRemove(item);\n                        }\n                        break;\n                    case 'replace':\n                        handleRemove(change.target);\n                        handleAdd(change.items[0]);\n                        break;\n                    case 'merge':\n                        const diff = change.previousState.filter((item) => !change.newState.includes(item));\n                        for (const item of diff) {\n                            for (const i of provider(item)) {\n                                if (view.has(i) && view.get(i).includes(item)) {\n                                    handleRemove(item);\n                                }\n                            }\n                        }\n                        for (const item of change.items) {\n                            for (const i of provider(item)) {\n                                if (!view.has(i)) {\n                                    handleAdd(item);\n                                } else {\n                                    if (!view.get(i).includes(item)) {\n                                        handleAdd(item);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n        }, cancellationToken);\n        return view as any as MapDataSource<K, ReadOnlyArrayDataSource<T>>;\n    }\n\n    public filter(\n        callback: Predicate<T>,\n        dependencies: ReadOnlyDataSource<any>[] = [],\n        cancellationToken?: CancellationToken,\n        config?: ViewConfig\n    ): ReadOnlyArrayDataSource<T> {\n        const view = new FilteredArrayView(this, callback, cancellationToken, this.name + '.filter()', config);\n\n        dependencies.forEach((dep) => {\n            dep.listen(() => view.refresh(), cancellationToken);\n        });\n\n        return view;\n    }\n\n    public limit(count: number, cancellationToken?: CancellationToken): ReadOnlyArrayDataSource<T> {\n        const view = new LimitedArrayView(this, count, cancellationToken, this.name + '.limit()');\n\n        return view;\n    }\n\n    public forEach(callbackfn: (value: T, index: number, array: T[]) => void): void {\n        return this.data.forEach(callbackfn);\n    }\n\n    protected update(change: CollectionChange<T>) {\n        this.updateEvent.fire(change);\n    }\n}\n\nexport interface ViewConfig {\n    ignoredOperations?: DetailedOperations[];\n}\n\nexport class FlattenedArrayView<T> extends ArrayDataSource<T> {\n    private parent: ArrayDataSource<T[]>;\n    private depth: number;\n    private sessionToken: CancellationToken;\n\n    constructor(\n        parent: ArrayDataSource<T[]>,\n        depth: number,\n        cancellationToken: CancellationToken = new CancellationToken(),\n        name?: string,\n        config?: ViewConfig\n    ) {\n        super([], name);\n        this.depth = depth;\n        this.parent = parent;\n        this.refresh();\n\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            switch (change.operationDetailed) {\n                case 'removeLeft':\n                case 'removeRight':\n                case 'remove':\n                case 'swap':\n                case 'replace':\n                case 'insert':\n                case 'merge':\n                case 'prepend':\n                case 'append':\n                    this.refresh();\n                    break;\n                case 'clear':\n                    this.clear();\n                    break;\n            }\n        }, cancellationToken);\n    }\n\n    public refresh() {\n        if (this.sessionToken) {\n            this.sessionToken.cancel();\n            this.sessionToken = undefined;\n        }\n\n        const data = this.parent.getData();\n        if (data.length > 0) {\n            if (data[0] instanceof ArrayDataSource) {\n                this.sessionToken = new CancellationToken();\n                const combination = ArrayDataSource.fromMultipleSources(data as any as ArrayDataSource<T>[]);\n                combination.listen((change) => {\n                    this.applyCollectionChange(change);\n                }, this.sessionToken);\n                this.merge(combination.getData() as any);\n            } else {\n                this.merge(data.flat(this.depth) as T[]);\n            }\n        }\n    }\n}\n\nexport class MappedArrayView<D, T> extends ArrayDataSource<T> {\n    private parent: ArrayDataSource<D>;\n    private mapper: (a: D) => T;\n\n    constructor(\n        parent: ArrayDataSource<D>,\n        mapper: (a: D) => T,\n        cancellationToken: CancellationToken = new CancellationToken(),\n        name?: string,\n        config?: ViewConfig\n    ) {\n        const initial = parent.getData().map(mapper);\n        super(initial, name);\n        this.parent = parent;\n        this.mapper = mapper;\n\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            switch (change.operationDetailed) {\n                case 'removeLeft':\n                    this.removeLeft(change.count);\n                    break;\n                case 'removeRight':\n                    this.removeRight(change.count);\n                    break;\n                case 'remove':\n                    for (let i = 0; i < change.items.length; i++) {\n                        this.remove(this.data[change.index + i]);\n                    }\n                    break;\n                case 'clear':\n                    this.clear();\n                    break;\n                case 'prepend':\n                    this.unshift(...change.items.map(this.mapper));\n                    break;\n                case 'append':\n                    this.appendArray(change.items.map(this.mapper));\n                    break;\n                case 'insert':\n                    this.insertAt(change.index, ...change.items.map(this.mapper));\n                    break;\n                case 'swap':\n                    this.swap(change.index, change.index2);\n                    break;\n                case 'replace':\n                    this.set(change.index, this.mapper(change.items[0]));\n                    break;\n                case 'merge':\n                    const old = this.data.slice();\n                    const source = change.previousState.slice();\n                    for (let i = 0; i < change.newState.length; i++) {\n                        if (this.data.length <= i) {\n                            this.data.push(this.mapper(change.newState[i]));\n                            source.push(change.newState[i]);\n                        } else if (source[i] !== change.newState[i]) {\n                            const index = source.indexOf(change.newState[i], i);\n                            if (index !== -1) {\n                                const a = this.data[i];\n                                const b = this.data[index];\n                                this.data[i] = b;\n                                this.data[index] = a;\n                                const c = source[i];\n                                const d = source[index];\n                                source[i] = d;\n                                source[index] = c;\n                            } else {\n                                this.data.splice(i, 0, this.mapper(change.newState[i]));\n                                source.splice(i, 0, change.newState[i]);\n                            }\n                        }\n                    }\n                    if (this.data.length > change.newState.length) {\n                        this.data.length = change.newState.length;\n                    }\n                    this.length.update(this.data.length);\n                    this.update({\n                        operation: 'merge',\n                        operationDetailed: 'merge',\n                        previousState: old,\n                        index: 0,\n                        items: this.data,\n                        newState: this.data\n                    });\n                    this.onItemsRemoved.fire(old);\n                    this.onItemsAdded.fire(this.data);\n                    break;\n            }\n        }, cancellationToken);\n    }\n\n    public refresh() {\n        this.merge(this.parent.getData().map(this.mapper));\n    }\n}\n\nexport class ReversedArrayView<T> extends ArrayDataSource<T> {\n    private parent: ArrayDataSource<T>;\n\n    constructor(parent: ArrayDataSource<T>, cancellationToken: CancellationToken = new CancellationToken(), name?: string, config?: ViewConfig) {\n        const initial = parent.getData().slice().reverse();\n        super(initial, name);\n        this.parent = parent;\n\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            switch (change.operationDetailed) {\n                case 'removeLeft':\n                    this.removeRight(change.count);\n                    break;\n                case 'removeRight':\n                    this.removeLeft(change.count);\n                    break;\n                case 'remove':\n                    for (const item of change.items) {\n                        this.remove(item);\n                    }\n                    break;\n                case 'clear':\n                    this.clear();\n                    break;\n                case 'prepend':\n                    this.appendArray(change.items.reverse());\n                    break;\n                case 'append':\n                    this.unshift(...change.items.reverse());\n                    break;\n                case 'insert':\n                    this.merge(change.newState.slice().reverse());\n                    break;\n                case 'merge':\n                    this.merge(change.items.slice().reverse());\n                    break;\n                case 'swap':\n                    this.merge(change.newState.slice().reverse());\n                    break;\n                case 'replace':\n                    this.merge(change.newState.slice().reverse());\n                    break;\n            }\n        }, cancellationToken);\n    }\n\n    public refresh() {\n        this.merge(this.parent.getData().slice().reverse());\n    }\n}\n\nexport class SlicedArrayView<T> extends ArrayDataSource<T> {\n    constructor(\n        parent: ArrayDataSource<T>,\n        start: DataSource<number>,\n        end: DataSource<number>,\n        cancellationToken: CancellationToken = new CancellationToken(),\n        name?: string,\n        config?: ViewConfig\n    ) {\n        const initial = parent.getData().slice(start.value, end.value);\n        super(initial, name);\n\n        start.listen(() => this.merge(parent.getData().slice(start.value, end.value)), cancellationToken);\n        end.listen(() => this.merge(parent.getData().slice(start.value, end.value)), cancellationToken);\n\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            switch (change.operationDetailed) {\n                case 'removeLeft':\n                case 'removeRight':\n                case 'remove':\n                case 'append':\n                case 'prepend':\n                case 'insert':\n                case 'swap':\n                case 'replace':\n                case 'merge':\n                    this.merge(parent.getData().slice(start.value, end.value));\n                    break;\n                case 'clear':\n                    this.clear();\n                    break;\n            }\n        }, cancellationToken);\n    }\n}\n\nexport class UniqueArrayView<T> extends ArrayDataSource<T> {\n    constructor(parent: ArrayDataSource<T>, cancellationToken: CancellationToken = new CancellationToken(), name?: string, config?: ViewConfig) {\n        const initial = Array.from(new Set(parent.getData()));\n        super(initial, name);\n        let filteredItems;\n\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            switch (change.operationDetailed) {\n                case 'removeLeft':\n                case 'removeRight':\n                case 'remove':\n                    for (const item of change.items) {\n                        if (!change.newState.includes(item)) {\n                            this.remove(item);\n                        }\n                    }\n                    break;\n                case 'clear':\n                    this.clear();\n                    break;\n                case 'prepend':\n                    filteredItems = change.items.filter((e) => !this.data.includes(e));\n                    this.unshift(...filteredItems);\n                    break;\n                case 'append':\n                    filteredItems = change.items.filter((e) => !this.data.includes(e));\n                    this.appendArray(filteredItems);\n                    break;\n                case 'insert':\n                    filteredItems = change.items.filter((e) => !this.data.includes(e));\n                    this.insertAt(change.index, ...filteredItems);\n                    break;\n                case 'merge':\n                    this.merge(Array.from(new Set(parent.getData())));\n                    break;\n                case 'swap':\n                    this.swap(change.index, change.index2);\n                    break;\n                case 'replace':\n                    if (this.data.includes(change.items[0])) {\n                        this.remove(change.target);\n                    } else {\n                        this.set(change.index, change.items[0]);\n                    }\n                    break;\n            }\n        }, cancellationToken);\n    }\n}\n\nexport class SortedArrayView<T> extends ArrayDataSource<T> {\n    private comparator: (a: T, b: T) => number;\n    private parent: ArrayDataSource<T>;\n\n    constructor(\n        parent: ArrayDataSource<T>,\n        comparator: (a: T, b: T) => number,\n        cancellationToken: CancellationToken = new CancellationToken(),\n        name?: string,\n        config?: ViewConfig\n    ) {\n        const initial = parent.getData().slice().sort(comparator);\n        super(initial, name);\n        this.parent = parent;\n        this.comparator = comparator;\n\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            switch (change.operationDetailed) {\n                case 'removeLeft':\n                case 'removeRight':\n                case 'remove':\n                    for (const item of change.items) {\n                        this.remove(item);\n                    }\n                    break;\n                case 'clear':\n                    this.clear();\n                    break;\n                case 'prepend':\n                    this.unshift(...change.items);\n                    this.data.sort(this.comparator);\n                    break;\n                case 'append':\n                    this.appendSorted(change.items);\n                    break;\n                case 'insert':\n                    this.appendSorted(change.items);\n                    break;\n                case 'merge':\n                    this.merge(change.items.slice().sort(this.comparator));\n                    break;\n                case 'swap':\n                    break;\n                case 'replace':\n                    this.remove(change.target);\n                    this.appendSorted(change.items);\n                    break;\n            }\n        }, cancellationToken);\n    }\n\n    private appendSorted(items: T[]) {\n        if (items.length === 1 && this.data.length === 0) {\n            this.push(items[0]);\n        } else {\n            this.merge(this.data.concat(items).sort(this.comparator));\n        }\n    }\n\n    public refresh() {\n        this.merge(this.parent.getData().slice().sort(this.comparator));\n    }\n}\n\nexport class FilteredArrayView<T> extends ArrayDataSource<T> {\n    private viewFilter: Predicate<T>;\n    private parent: ArrayDataSource<T>;\n    constructor(\n        parent: ArrayDataSource<T> | T[],\n        filter?: Predicate<T>,\n        cancellationToken: CancellationToken = new CancellationToken(),\n        name?: string,\n        config?: ViewConfig\n    ) {\n        if (Array.isArray(parent)) {\n            parent = new ArrayDataSource(parent);\n        }\n        filter = filter ?? (() => true);\n        const initial = (parent as FilteredArrayView<T>).data.filter(filter);\n        super(initial, name);\n\n        this.parent = parent;\n        this.viewFilter = filter;\n        parent.listen((change) => {\n            if (config?.ignoredOperations?.includes(change.operationDetailed)) {\n                return;\n            }\n\n            let filteredItems;\n            switch (change.operationDetailed) {\n                case 'clear':\n                    this.clear();\n                    break;\n                case 'removeLeft':\n                case 'removeRight':\n                case 'remove':\n                    for (const item of change.items) {\n                        this.remove(item);\n                    }\n                    break;\n                case 'prepend':\n                    filteredItems = change.items.filter(this.viewFilter);\n                    this.unshift(...filteredItems);\n                    break;\n                case 'append':\n                    filteredItems = change.items.filter(this.viewFilter);\n                    this.appendArray(filteredItems);\n                    break;\n                case 'insert':\n                    filteredItems = change.items.filter(this.viewFilter);\n                    this.insertAt(change.index, ...filteredItems);\n                    break;\n                case 'merge':\n                    this.merge(change.items.filter(this.viewFilter));\n                    break;\n                case 'swap':\n                    const indexA = this.data.indexOf(change.items[0]);\n                    const indexB = this.data.indexOf(change.items[1]);\n                    if (indexA !== -1 && indexB !== -1) {\n                        this.swap(indexA, indexB);\n                    }\n                    break;\n                case 'replace':\n                    const index = this.data.indexOf(change.target);\n                    if (index !== -1) {\n                        const acceptNew = this.viewFilter(change.items[0]);\n                        if (acceptNew) {\n                            this.set(index, change.items[0]);\n                        } else {\n                            this.remove(change.target);\n                        }\n                    }\n                    break;\n            }\n        }, cancellationToken);\n    }\n\n    /**\n     * Replaces the filter function\n     * @param filter\n     * @returns returns new size of array view after applying filter\n     */\n    public updateFilter(filter: Predicate<T>): number {\n        if (this.viewFilter === filter) {\n            return this.data.length;\n        }\n        this.viewFilter = filter;\n        this.refresh();\n        return this.data.length;\n    }\n\n    /**\n     * Recalculates the filter. Only needed if your filter function isn't pure and you know the result would be different if run again compared to before\n     */\n    public refresh() {\n        this.merge((this.parent as FilteredArrayView<T>).data.filter(this.viewFilter));\n    }\n}\n\nexport class LimitedArrayView<T> extends ArrayDataSource<T> {\n    constructor(parent: ArrayDataSource<T> | T[], sizeLimit: number, cancellationToken: CancellationToken = new CancellationToken(), name?: string) {\n        if (Array.isArray(parent)) {\n            parent = new ArrayDataSource(parent);\n        }\n        const initial = (parent as LimitedArrayView<T>).data.slice(0, sizeLimit);\n        super(initial, name);\n\n        parent.listen((change) => {\n            switch (change.operationDetailed) {\n                case 'clear':\n                    this.clear();\n                    break;\n                case 'removeLeft':\n                case 'removeRight':\n                case 'remove':\n                    if (change.index < sizeLimit) {\n                        this.removeRange(change.index, change.index + Math.min(sizeLimit, change.count));\n\n                        if (this.data.length < sizeLimit) {\n                            this.appendArray(change.newState.slice(this.data.length, sizeLimit));\n                        }\n                    }\n                    break;\n                case 'prepend':\n                    this.removeRight(Math.min(change.count, sizeLimit));\n                    this.unshift(...change.items.slice(0, sizeLimit));\n                    break;\n\n                case 'append':\n                    if (this.data.length < sizeLimit) {\n                        this.appendArray(change.items.slice(0, sizeLimit - this.data.length));\n                    }\n                    break;\n\n                case 'insert':\n                    if (change.index < sizeLimit) {\n                        this.removeRight(Math.min(change.count, sizeLimit - change.index));\n                        this.insertAt(change.index, ...change.items.slice(0, sizeLimit - change.index));\n                    }\n                    break;\n                case 'merge':\n                case 'swap':\n                    this.merge(change.newState.slice(0, sizeLimit));\n                    break;\n                case 'replace':\n                    if (change.index < sizeLimit) {\n                        this.set(change.index, change.items[0]);\n                    }\n                    break;\n            }\n        }, cancellationToken);\n    }\n}\n\nexport function processTransform<I, O>(operations: DataSourceOperator<any, any>[], result: DataSource<O>): (input: I) => Promise<void> {\n    return async (v: any) => {\n        try {\n            for (const operation of operations) {\n                switch (operation.operationType) {\n                    case OperationType.NOOP:\n                    case OperationType.MAP:\n                        v = (operation as DataSourceMapOperator<any, any>).operation(v);\n                        break;\n                    case OperationType.MAP_DELAY_FILTER:\n                        const tmp = await (operation as DataSourceMapDelayFilterOperator<any, any>).operation(v);\n                        if (tmp.cancelled) {\n                            return;\n                        } else {\n                            v = await tmp.item;\n                        }\n                        break;\n                    case OperationType.DELAY:\n                    case OperationType.MAP_DELAY:\n                        v = await (operation as DataSourceMapOperator<any, any>).operation(v);\n                        break;\n                    case OperationType.DELAY_FILTER:\n                        if (!(await (operation as DataSourceDelayFilterOperator<any>).operation(v))) {\n                            return;\n                        }\n                        break;\n                    case OperationType.FILTER:\n                        if (!(operation as DataSourceFilterOperator<any>).operation(v)) {\n                            return;\n                        }\n                        break;\n                }\n            }\n            result.update(v);\n        } catch (e) {\n            result.emitError(e);\n        }\n    };\n}\n\nexport interface MapChange<K, V> {\n    key: K;\n    oldValue: V;\n    newValue: V;\n    deleted?: boolean;\n}\n\nexport class MapDataSource<K, V> {\n    protected data: Map<K, V>;\n    private updateEvent: EventEmitter<MapChange<K, V>>;\n    private updateEventOnKey: Map<K, EventEmitter<MapChange<K, V>>>;\n\n    constructor(initialData?: Map<K, V>) {\n        this.data = initialData ?? new Map();\n\n        this.updateEvent = new EventEmitter();\n        this.updateEventOnKey = new Map();\n    }\n\n    public cancelAll(): void {\n        this.updateEvent.cancelAll();\n        this.updateEventOnKey.forEach((v, k) => v.cancelAll());\n        this.updateEventOnKey.clear();\n    }\n\n    /**\n     * Connects to an aurum-server exposed map datasource. View https://github.com/CyberPhoenix90/aurum-server for more information\n     * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server\n     * @param  {AurumServerInfo} aurumServerInfo\n     * @returns DataSource\n     */\n    public static fromRemoteSource<K, V>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): MapDataSource<K, V> {\n        const result = new MapDataSource<K, V>();\n\n        syncMapDataSource(result, aurumServerInfo, cancellation);\n\n        return result;\n    }\n\n    public static fromMultipleMaps<K, V>(maps: MapDataSource<K, V>[], cancellationToken?: CancellationToken): MapDataSource<K, V> {\n        const result = new MapDataSource<K, V>();\n        let i = 0;\n        for (const map of maps) {\n            let index = i;\n            result.assign(map);\n            map.listen((change) => {\n                let isOverwritten = false;\n                for (let j = index + 1; j < maps.length; j++) {\n                    if (maps[j].has(change.key)) {\n                        isOverwritten = true;\n                        break;\n                    }\n                }\n                if (!isOverwritten) {\n                    if (change.deleted) {\n                        result.delete(change.key);\n                    } else {\n                        result.set(change.key, change.newValue);\n                    }\n                }\n            }, cancellationToken);\n        }\n\n        return result;\n    }\n\n    public toAsyncIterator(cancellation?: CancellationToken): AsyncIterableIterator<MapChange<K, V>> {\n        return this.updateEvent.toAsyncIterator(cancellation);\n    }\n\n    public pipe(target: MapDataSource<K, V>, cancellation?: CancellationToken): void {\n        this.listenAndRepeat((c) => target.applyMapChange(c), cancellation);\n    }\n\n    public forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n        this.data.forEach(callbackfn, thisArg);\n    }\n\n    public toString(): string {\n        return this.data.toString();\n    }\n\n    public static toMapDataSource<K, V>(value: Map<K, V> | MapDataSource<K, V>): MapDataSource<K, V> {\n        if (value instanceof MapDataSource) {\n            return value;\n        } else {\n            return new MapDataSource(value);\n        }\n    }\n\n    public applyMapChange(change: MapChange<K, V>) {\n        if (change.deleted && this.data.has(change.key)) {\n            this.delete(change.key);\n        } else if (!change.deleted && !this.data.has(change.key)) {\n            this.set(change.key, change.newValue);\n        }\n    }\n\n    /**\n     * Creates a datasource for a single key of the object\n     * @param key\n     * @param cancellationToken\n     */\n    public pick(key: K, cancellationToken?: CancellationToken): DataSource<V> {\n        const subDataSource: DataSource<V> = new DataSource(this.data.get(key));\n\n        this.listenOnKey(\n            key,\n            (v) => {\n                subDataSource.update(v.newValue);\n            },\n            cancellationToken\n        );\n\n        return subDataSource;\n    }\n\n    /**\n     * Listen to changes of the object\n     */\n    public listen(callback: Callback<MapChange<K, V>>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Same as listen but will immediately call the callback with the current value of each key\n     */\n    public listenAndRepeat(callback: Callback<MapChange<K, V>>, cancellationToken?: CancellationToken): Callback<void> {\n        const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;\n        for (const key of this.data.keys()) {\n            callback({\n                key,\n                newValue: this.data.get(key),\n                oldValue: undefined,\n                deleted: false\n            });\n        }\n        return c;\n    }\n\n    public map<D>(mapper: (key: K, value: V, valueLifetimeToken: CancellationToken) => D, cancellation: CancellationToken): MapDataSource<K, D> {\n        const result = new MapDataSource<K, D>();\n        const lifeTimeMap = new Map<K, CancellationToken>();\n        this.listenAndRepeat((change) => {\n            if (change.deleted) {\n                lifeTimeMap.get(change.key).cancel();\n                lifeTimeMap.delete(change.key);\n                result.delete(change.key);\n            } else {\n                const lifeTimeToken = new CancellationToken();\n                if (lifeTimeMap.has(change.key)) {\n                    lifeTimeMap.get(change.key).cancel();\n                }\n                lifeTimeMap.set(change.key, lifeTimeToken);\n                const newItem = mapper(change.key, change.newValue, lifeTimeToken);\n                result.set(change.key, newItem);\n            }\n        }, cancellation);\n        return result;\n    }\n\n    public toKeysArrayDataSource(cancellation: CancellationToken): ArrayDataSource<K> {\n        const result = new ArrayDataSource<K>();\n        this.listenAndRepeat((change) => {\n            if (change.deleted) {\n                result.remove(change.key);\n            } else if (!change.deleted) {\n                if (!result.includes(change.key)) {\n                    result.push(change.key);\n                }\n            }\n        }, cancellation);\n\n        return result;\n    }\n\n    public toArrayDataSource(cancellation: CancellationToken): ArrayDataSource<V> {\n        const stateMap: Map<K, V> = new Map<K, V>();\n        const result = new ArrayDataSource<V>();\n        this.listenAndRepeat((change) => {\n            if (change.deleted && stateMap.has(change.key)) {\n                const item = stateMap.get(change.key);\n                result.remove(item);\n                stateMap.delete(change.key);\n            } else if (stateMap.has(change.key)) {\n                const newItem = change.newValue;\n                result.replace(stateMap.get(change.key), newItem);\n                stateMap.set(change.key, newItem);\n            } else if (!stateMap.has(change.key) && !change.deleted) {\n                const newItem = change.newValue;\n                result.push(newItem);\n                stateMap.set(change.key, newItem);\n            }\n        }, cancellation);\n\n        return result;\n    }\n\n    public toEntriesArrayDataSource(cancellation: CancellationToken): ArrayDataSource<[K, V]> {\n        const stateMap: Map<K, V> = new Map<K, V>();\n        const result = new ArrayDataSource<[K, V]>();\n        this.listenAndRepeat((change) => {\n            if (change.deleted && stateMap.has(change.key)) {\n                const index = result.findIndex((v) => v[0] === change.key);\n                result.removeAt(index);\n                stateMap.delete(change.key);\n            } else if (stateMap.has(change.key)) {\n                const newItem = change.newValue;\n                const index = result.findIndex((v) => v[0] === change.key);\n                result.set(index, [change.key, newItem]);\n                stateMap.set(change.key, newItem);\n            } else if (!stateMap.has(change.key) && !change.deleted) {\n                const newItem = change.newValue;\n                result.push([change.key, newItem]);\n                stateMap.set(change.key, newItem);\n            }\n        }, cancellation);\n\n        return result;\n    }\n\n    public clear() {\n        for (const key of this.data.keys()) {\n            this.delete(key);\n        }\n    }\n\n    /**\n     * Same as listenOnKey but will immediately call the callback with the current value first\n     */\n    public listenOnKeyAndRepeat(key: K, callback: Callback<MapChange<K, V>>, cancellationToken?: CancellationToken): Callback<void> {\n        callback({\n            key,\n            newValue: this.data.get(key),\n            oldValue: undefined\n        });\n\n        return this.listenOnKey(key, callback, cancellationToken);\n    }\n\n    /**\n     * Listen to changes of a single key of the object\n     */\n    public listenOnKey(key: K, callback: Callback<MapChange<K, V>>, cancellationToken?: CancellationToken): Callback<void> {\n        if (!this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.set(key, new EventEmitter());\n        }\n        const event = this.updateEventOnKey.get(key);\n        return event.subscribe(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Returns all the keys of the object in the source\n     */\n    public keys(): IterableIterator<K> {\n        return this.data.keys();\n    }\n\n    /**\n     * Returns all the values of the object in the source\n     */\n    public values(): IterableIterator<V> {\n        return this.data.values();\n    }\n\n    /**\n     * get the current value of a key of the object\n     * @param key\n     */\n    public get(key: K): V {\n        return this.data.get(key);\n    }\n\n    /**\n     * check if map has a key\n     * @param key\n     */\n    public has(key: K): boolean {\n        return this.data.has(key);\n    }\n\n    /**\n     * delete a key from the object\n     * @param key\n     * @param value\n     */\n    public delete(key: K): void {\n        if (!this.has(key)) {\n            return;\n        }\n\n        const old = this.data.get(key);\n        this.data.delete(key);\n        this.updateEvent.fire({ oldValue: old, key, newValue: undefined, deleted: true });\n        if (this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: undefined });\n        }\n    }\n\n    /**\n     * set the value for a key of the object\n     * @param key\n     * @param value\n     */\n    public set(key: K, value: V): void {\n        if (this.data.get(key) === value) {\n            return;\n        }\n\n        const old = this.data.get(key);\n        this.data.set(key, value);\n        this.updateEvent.fire({ oldValue: old, key, newValue: this.data.get(key) });\n        if (this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.get(key).fire({ oldValue: old, key, newValue: this.data.get(key) });\n        }\n    }\n\n    public merge(newData: Map<K, V> | MapDataSource<K, V>): void {\n        for (const key of newData.keys()) {\n            this.set(key, newData.get(key));\n        }\n\n        for (const key of this.keys()) {\n            if (!newData.has(key)) {\n                this.delete(key);\n            }\n        }\n    }\n\n    public entries(): IterableIterator<[K, V]> {\n        return this.data.entries();\n    }\n\n    /**\n     * Merge the key value pairs of an object into this object non recursively\n     * @param newData\n     */\n    public assign(newData: Map<K, V> | MapDataSource<K, V>): void {\n        for (const key of newData.keys()) {\n            this.set(key, newData.get(key));\n        }\n    }\n\n    /**\n     * Returns a shallow copy of the map\n     */\n    public toMap(): Map<K, V> {\n        return new Map(this.data.entries());\n    }\n}\n\nexport interface SetChange<K> {\n    key: K;\n    exists: boolean;\n}\n\nexport interface ReadOnlySetDataSource<K> {\n    difference(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K>;\n    union(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K>;\n    intersection(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K>;\n    symmetricDifference(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K>;\n\n    isSubsetOf(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean;\n    isSupersetOf(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean;\n    isDisjointWith(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean;\n    isIdenticalTo(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean;\n\n    pick(key: K, cancellationToken?: CancellationToken): DataSource<boolean>;\n    listen(callback: Callback<SetChange<K>>, cancellationToken?: CancellationToken): Callback<void>;\n    listenAndRepeat(callback: Callback<SetChange<K>>, cancellationToken?: CancellationToken): Callback<void>;\n    listenOnKeyAndRepeat(key: K, callback: Callback<boolean>, cancellationToken?: CancellationToken): Callback<void>;\n    listenOnKey(key: K, callback: Callback<boolean>, cancellationToken?: CancellationToken): Callback<void>;\n    map<D>(mapper: (key: K) => D): ReadOnlyArrayDataSource<D>;\n    keys(): IterableIterator<K>;\n    has(key: K): boolean;\n    pickKey(key: K, cancellationToken?: CancellationToken): DataSource<boolean>;\n    toArray(): K[];\n    toArrayDataSource(cancellationToken?: CancellationToken): ReadOnlyArrayDataSource<K>;\n    toSet(): Set<K>;\n    clear(): void;\n    [Symbol.iterator](): IterableIterator<K>;\n    entries(): IterableIterator<[K, K]>;\n    values(): IterableIterator<K>;\n    readonly size: number;\n}\nexport class SetDataSource<K> implements ReadOnlySetDataSource<K> {\n    protected data: Set<K>;\n    private updateEvent: EventEmitter<SetChange<K>>;\n    private updateEventOnKey: Map<K, EventEmitter<boolean>>;\n\n    constructor(initialData?: Set<K> | K[]) {\n        if (Array.isArray(initialData)) {\n            this.data = new Set(initialData);\n        } else {\n            this.data = initialData ?? new Set();\n        }\n\n        this.updateEvent = new EventEmitter();\n        this.updateEventOnKey = new Map();\n    }\n\n    /**\n     * Connects to an aurum-server exposed set datasource. View https://github.com/CyberPhoenix90/aurum-server for more information\n     * Note that type safety is not guaranteed. Whatever the server sends as an update will be propagated. Make sure you trust the server\n     * @param  {AurumServerInfo} aurumServerInfo\n     * @returns DataSource\n     */\n    public static fromRemoteSource<T>(aurumServerInfo: AurumServerInfo, cancellation: CancellationToken): SetDataSource<T> {\n        const result = new SetDataSource<T>(undefined);\n\n        syncSetDataSource(result, aurumServerInfo, cancellation);\n\n        return result;\n    }\n\n    public static fromAsyncIterator<T>(iterator: AsyncIterableIterator<T>, cancellation?: CancellationToken): SetDataSource<T> {\n        const result = new SetDataSource<T>();\n\n        (async () => {\n            for await (const item of iterator) {\n                if (cancellation?.isCancelled) {\n                    return;\n                }\n                result.add(item);\n            }\n        })();\n\n        return result;\n    }\n\n    public toAsyncIterator(cancellation?: CancellationToken): AsyncIterableIterator<SetChange<K>> {\n        return this.updateEvent.toAsyncIterator(cancellation);\n    }\n\n    /**\n     * Remove all listeners\n     */\n    public cancelAll(): void {\n        this.updateEvent.cancelAll();\n    }\n\n    public applySetChange(change: SetChange<K>): void {\n        if (change.exists && !this.has(change.key)) {\n            this.data.add(change.key);\n        } else if (!change.exists && this.has(change.key)) {\n            this.data.delete(change.key);\n        }\n    }\n\n    public clear(): void {\n        for (const key of this.data.keys()) {\n            this.delete(key);\n        }\n    }\n\n    public isSubsetOf(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean {\n        for (const key of this) {\n            if (!otherSet.has(key)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public isSupersetOf(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean {\n        for (const key of otherSet) {\n            if (!this.has(key)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public isDisjointWith(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean {\n        for (const key of otherSet) {\n            if (this.has(key)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public get size(): number {\n        return this.data.size;\n    }\n\n    public isIdenticalTo(otherSet: ReadOnlySetDataSource<K> | Set<K>): boolean {\n        if (this.size !== otherSet.size) {\n            return false;\n        }\n\n        for (const key of otherSet) {\n            if (!this.has(key)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static toSetDataSource<K>(value: Set<K> | SetDataSource<K>): SetDataSource<K> {\n        if (value instanceof SetDataSource) {\n            return value;\n        } else {\n            return new SetDataSource(value);\n        }\n    }\n\n    public [Symbol.iterator](): IterableIterator<K> {\n        return this.data.keys();\n    }\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    public entries(): IterableIterator<[K, K]> {\n        return this.data.entries();\n    }\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    public values(): IterableIterator<K> {\n        return this.data.values();\n    }\n\n    public difference(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K> {\n        const result = new SetDataSource<K>();\n        const otherSetKeys = new Set<K>(otherSet.keys());\n        this.listenAndRepeat((change) => {\n            if (change.exists && !otherSetKeys.has(change.key)) {\n                result.add(change.key);\n            }\n\n            if (!change.exists) {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        otherSet.listenAndRepeat((change) => {\n            if (change.exists) {\n                result.delete(change.key);\n            }\n\n            if (!change.exists && this.has(change.key)) {\n                result.add(change.key);\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public union(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K> {\n        const result = new SetDataSource<K>();\n\n        this.listenAndRepeat((change) => {\n            if (change.exists) {\n                result.add(change.key);\n            } else if (!otherSet.has(change.key)) {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        otherSet.listenAndRepeat((change) => {\n            if (change.exists) {\n                result.add(change.key);\n            } else if (!this.has(change.key)) {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public intersection(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K> {\n        const result = new SetDataSource<K>();\n\n        this.listenAndRepeat((change) => {\n            if (change.exists && otherSet.has(change.key)) {\n                result.add(change.key);\n            } else {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        otherSet.listenAndRepeat((change) => {\n            if (change.exists && this.has(change.key)) {\n                result.add(change.key);\n            } else {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public symmetricDifference(otherSet: ReadOnlySetDataSource<K>, cancellationToken: CancellationToken): ReadOnlySetDataSource<K> {\n        const result = new SetDataSource<K>();\n\n        this.listenAndRepeat((change) => {\n            if (change.exists && !otherSet.has(change.key)) {\n                result.add(change.key);\n            } else if (!change.exists && otherSet.has(change.key)) {\n                result.add(change.key);\n            } else if (change.exists && otherSet.has(change.key)) {\n                result.delete(change.key);\n            } else if (!change.exists && !otherSet.has(change.key)) {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        otherSet.listenAndRepeat((change) => {\n            if (change.exists && !this.has(change.key)) {\n                result.add(change.key);\n            } else if (!change.exists && this.has(change.key)) {\n                result.add(change.key);\n            } else if (change.exists && this.has(change.key)) {\n                result.delete(change.key);\n            } else if (!change.exists && !this.has(change.key)) {\n                result.delete(change.key);\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    public toString(): string {\n        return this.data.toString();\n    }\n\n    /**\n     * Creates a datasource for a single key of the object\n     * @param key\n     * @param cancellationToken\n     */\n    public pick(key: K, cancellationToken?: CancellationToken): DataSource<boolean> {\n        const subDataSource: DataSource<boolean> = new DataSource(this.data.has(key));\n\n        this.listenOnKey(\n            key,\n            (v) => {\n                subDataSource.update(v);\n            },\n            cancellationToken\n        );\n\n        return subDataSource;\n    }\n\n    /**\n     * Listen to changes of the object\n     */\n    public listen(callback: Callback<SetChange<K>>, cancellationToken?: CancellationToken): Callback<void> {\n        return this.updateEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    /**\n     * Same as listen but will immediately call the callback with the current value of each key\n     */\n    public listenAndRepeat(callback: Callback<SetChange<K>>, cancellationToken?: CancellationToken): Callback<void> {\n        const c = this.updateEvent.subscribe(callback, cancellationToken).cancel;\n        for (const key of this.data.keys()) {\n            callback({\n                key,\n                exists: true\n            });\n        }\n        return c;\n    }\n\n    /**\n     * Same as listenOnKey but will immediately call the callback with the current value first\n     */\n    public listenOnKeyAndRepeat(key: K, callback: Callback<boolean>, cancellationToken?: CancellationToken): Callback<void> {\n        callback(this.has(key));\n\n        return this.listenOnKey(key, callback, cancellationToken);\n    }\n\n    /**\n     * Listen to changes of a single key of the object\n     */\n    public listenOnKey(key: K, callback: Callback<boolean>, cancellationToken?: CancellationToken): Callback<void> {\n        if (!this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.set(key, new EventEmitter());\n        }\n        const event = this.updateEventOnKey.get(key);\n        return event.subscribe(callback, cancellationToken).cancel;\n    }\n\n    public toArrayDataSource(cancellationToken?: CancellationToken): ReadOnlyArrayDataSource<K> {\n        return this.map((key) => key, cancellationToken);\n    }\n\n    public map<D>(mapper: (key: K) => D, cancellationToken?: CancellationToken): ReadOnlyArrayDataSource<D> {\n        const stateMap: Map<K, D> = new Map<K, D>();\n        const result = new ArrayDataSource<D>();\n        this.listenAndRepeat((change) => {\n            if (!change.exists && stateMap.has(change.key)) {\n                const item = stateMap.get(change.key);\n                result.remove(item);\n                stateMap.delete(change.key);\n            } else if (!stateMap.has(change.key) && change.exists) {\n                const newItem = mapper(change.key);\n                result.push(newItem);\n                stateMap.set(change.key, newItem);\n            }\n        }, cancellationToken);\n\n        return result;\n    }\n\n    /**\n     * Returns all the keys of the object in the source\n     */\n    public keys(): IterableIterator<K> {\n        return this.data.keys();\n    }\n\n    /**\n     * check if map has a key\n     * @param key\n     */\n    public has(key: K): boolean {\n        return this.data.has(key);\n    }\n\n    /**\n     * Returns a datasource that reflects if the key exists in the set\n     * @param key\n     * @param cancellationToken\n     * @returns\n     */\n    public pickKey(key: K, cancellationToken?: CancellationToken): DataSource<boolean> {\n        const result = new DataSource(this.has(key));\n        this.listenOnKey(key, (v) => result.update(v), cancellationToken);\n        return result;\n    }\n\n    /**\n     * delete a key from the object\n     * @param key\n     * @param value\n     */\n    public delete(key: K): void {\n        if (this.has(key)) {\n            this.data.delete(key);\n            this.updateEvent.fire({ key, exists: false });\n            if (this.updateEventOnKey.has(key)) {\n                this.updateEventOnKey.get(key).fire(false);\n            }\n        }\n    }\n\n    /**\n     * set the value for a key of the object\n     * @param key\n     * @param value\n     */\n    public add(key: K): void {\n        if (this.data.has(key)) {\n            return;\n        }\n        this.data.add(key);\n        this.updateEvent.fire({ key, exists: true });\n        if (this.updateEventOnKey.has(key)) {\n            this.updateEventOnKey.get(key).fire(true);\n        }\n    }\n\n    public merge(newData: Set<K> | SetDataSource<K> | K[] | ArrayDataSource<K>): void {\n        let newItems: Set<K>;\n        if (newData instanceof SetDataSource) {\n            newItems = newData.data;\n        } else if (newData instanceof Set) {\n            newItems = newData;\n        } else if (newData instanceof ArrayDataSource) {\n            newItems = new Set(newData.getData());\n        } else {\n            newItems = new Set(newData);\n        }\n        for (const item of this.data) {\n            if (!newItems.has(item)) {\n                this.delete(item);\n            }\n        }\n\n        for (const item of newItems) {\n            this.add(item);\n        }\n    }\n\n    /**\n     * Merge the key value pairs of an object into this object non recursively\n     * @param newData\n     */\n    public assign(newData: Set<K> | SetDataSource<K>): void {\n        for (const key of newData.keys()) {\n            this.add(key);\n        }\n    }\n\n    /**\n     * Returns a shallow copy of the set\n     */\n    public toSet(): Set<K> {\n        return new Set(this.data.keys());\n    }\n\n    public toArray(): K[] {\n        return Array.from(this.data.keys());\n    }\n}\n\n/**\n * Only allows one update to propagate through the operations at a time. If a new update comes in while the previous one is still being processed it will be buffered and processed after the previous one is done\n */\nexport function dsCriticalSection<T, A, B = A, C = B, D = C, E = D, F = E, G = F, H = G, I = H, J = I, K = J>(\n    operationA: DataSourceOperator<T, A>,\n    operationB?: DataSourceOperator<A, B>,\n    operationC?: DataSourceOperator<B, C>,\n    operationD?: DataSourceOperator<C, D>,\n    operationE?: DataSourceOperator<D, E>,\n    operationF?: DataSourceOperator<E, F>,\n    operationG?: DataSourceOperator<F, G>,\n    operationH?: DataSourceOperator<G, H>,\n    operationI?: DataSourceOperator<H, I>,\n    operationJ?: DataSourceOperator<I, J>,\n    operationK?: DataSourceOperator<J, K>\n): DataSourceMapDelayFilterOperator<T, K> {\n    const lockState = new DataSource<boolean>(false);\n    const operations = [\n        operationA,\n        operationB,\n        operationC,\n        operationD,\n        operationE,\n        operationF,\n        operationG,\n        operationH,\n        operationI,\n        operationJ,\n        operationK\n    ].filter((v) => v !== undefined);\n    const buffer = [];\n\n    lockState.listen((v) => {\n        if (!v) {\n            if (buffer.length > 0) {\n                queueMicrotask(async () => {\n                    if (!lockState.value) {\n                        lockState.update(true);\n                        const item = buffer.shift();\n                        try {\n                            const value = await processInlineTransform(operations, item.value);\n                            item.resolve(value);\n                        } catch (e) {\n                            item.reject(e);\n                        } finally {\n                            lockState.update(false);\n                        }\n                    }\n                });\n            }\n        }\n    });\n\n    return {\n        name: `CriticalSection<${operations.map((v) => v.name).join(', ')}>`,\n        operationType: OperationType.MAP_DELAY_FILTER,\n        operation: async (v) => {\n            if (!lockState.value) {\n                lockState.update(true);\n                try {\n                    const result = await processInlineTransform(operations, v);\n                    return result;\n                } finally {\n                    lockState.update(false);\n                }\n            }\n            return new Promise((resolve, reject) => {\n                buffer.push({\n                    resolve,\n                    reject,\n                    value: v\n                });\n            });\n        }\n    };\n}\n\nexport function dsForkInline<T, A1, B1 = A1, C1 = B1, D1 = C1, E1 = D1, F1 = E1, G1 = F1, H1 = G1, I1 = H1>(\n    condition: (value: T) => boolean,\n    operationA: DataSourceOperator<T, A1>,\n    operationB?: DataSourceOperator<A1, B1>,\n    operationC?: DataSourceOperator<B1, C1>,\n    operationD?: DataSourceOperator<C1, D1>,\n    operationE?: DataSourceOperator<D1, E1>,\n    operationF?: DataSourceOperator<E1, F1>,\n    operationG?: DataSourceOperator<F1, G1>,\n    operationH?: DataSourceOperator<G1, H1>,\n    operationI?: DataSourceOperator<H1, I1>\n): DataSourceMapDelayFilterOperator<T, T | I1> {\n    const ops = [operationA, operationB, operationC, operationD, operationE, operationF, operationG, operationH, operationI].filter((v) => v !== undefined);\n\n    return {\n        name: 'fork-inline',\n        operationType: OperationType.MAP_DELAY_FILTER,\n        operation: async (v) => {\n            if (condition(v)) {\n                return processInlineTransform(ops, v);\n            } else {\n                return { item: v, cancelled: false };\n            }\n        }\n    };\n}\n\nasync function processInlineTransform(operations: DataSourceOperator<any, any>[], value: any): Promise<{ item: any; cancelled: boolean }> {\n    let out;\n    let error;\n    let hasValue = false;\n\n    const sink = new DataSource();\n    sink.listen((result) => {\n        out = result;\n        hasValue = true;\n    });\n    sink.handleErrors((e) => {\n        error = e;\n    });\n\n    await processTransform(operations, sink)(value);\n\n    if (error) {\n        throw error;\n    }\n\n    return { item: out, cancelled: !hasValue };\n}\n", "import { ReadOnlyDataSource, DataSource, MapDataSource, ArrayDataSource } from '../stream/data_source.js';\nimport { dsMap } from '../stream/data_source_operators.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { CancellationToken } from './cancellation_token.js';\nimport { AttributeValue, ClassType, StyleType } from './common.js';\n\nexport function aurumClassName(\n    data: { [key: string]: boolean | ReadOnlyDataSource<boolean> } | MapDataSource<string, boolean>,\n    cancellationToken?: CancellationToken\n): Array<string | ReadOnlyDataSource<string>> | ArrayDataSource<string> {\n    if (data instanceof MapDataSource) {\n        return handleClassMapDataSource(data, cancellationToken);\n    } else {\n        return handleClassMapLike(data, cancellationToken);\n    }\n}\n\nfunction handleClassMapLike(\n    data: { [key: string]: boolean | ReadOnlyDataSource<boolean> } | MapDataSource<string, boolean>,\n    cancellationToken: CancellationToken\n) {\n    const result = [];\n    for (const key in data) {\n        if (data[key]) {\n            if (data[key] instanceof DataSource || data[key] instanceof DuplexDataSource) {\n                const source = data[key] as ReadOnlyDataSource<boolean>;\n                const mappedSource = new DataSource<string>(source.value ? key : '');\n                source.listen((value) => {\n                    mappedSource.update(value ? key : '');\n                }, cancellationToken);\n\n                result.push(mappedSource);\n            } else {\n                result.push(key);\n            }\n        }\n    }\n    return result;\n}\n\nfunction handleClassMapDataSource(data: MapDataSource<string, boolean>, cancellationToken: CancellationToken): ArrayDataSource<string> {\n    const stateMap: Map<string, boolean> = new Map<string, boolean>();\n    const result = new ArrayDataSource<string>();\n    data.listenAndRepeat((change) => {\n        if (change.deleted && stateMap.has(change.key)) {\n            result.remove(change.key);\n            stateMap.delete(change.key);\n        } else if (stateMap.has(change.key)) {\n            const newState = change.newValue;\n            if (newState && !stateMap.get(change.key)) {\n                result.push(change.key);\n            }\n            if (!newState && stateMap.get(change.key)) {\n                result.remove(change.key);\n            }\n            stateMap.set(change.key, newState);\n        } else if (!stateMap.has(change.key) && !change.deleted) {\n            const newState = change.newValue;\n            if (newState) {\n                result.push(change.key);\n            }\n            stateMap.set(change.key, newState);\n        }\n    }, cancellationToken);\n\n    return result;\n}\n\nexport function combineClass(cancellationToken: CancellationToken, ...args: ClassType[]): ClassType {\n    args = args.filter((e) => !!e);\n\n    if (args.length < 2) {\n        return args[0];\n    }\n\n    let fixed: string = '';\n    const sources: ReadOnlyDataSource<string | string[]>[] = [];\n    const maps: MapDataSource<string, boolean>[] = [];\n\n    resolveConstants(args);\n\n    function resolveConstants(args: ClassType[]) {\n        for (const arg of args) {\n            if (typeof arg === 'string') {\n                fixed += arg + ' ';\n            } else if (Array.isArray(arg)) {\n                resolveConstants(arg);\n            } else if (arg instanceof DataSource || arg instanceof DuplexDataSource) {\n                sources.push(arg);\n            } else if (arg instanceof MapDataSource) {\n                maps.push(arg);\n            } else if (typeof arg === 'object') {\n                for (const key in arg) {\n                    if (arg[key] instanceof DataSource || arg[key] instanceof DuplexDataSource) {\n                        sources.push(\n                            arg[key].transform(\n                                dsMap((v) => (v ? key : '')),\n                                cancellationToken\n                            )\n                        );\n                    } else {\n                        fixed += arg[key] ? key + ' ' : '';\n                    }\n                }\n            }\n        }\n    }\n\n    fixed = fixed.trim();\n\n    if (sources.length || maps.length) {\n        const result = new DataSource<string>();\n\n        function update() {\n            const classes: string[] = [fixed];\n            for (const source of sources) {\n                if (Array.isArray(source.value)) {\n                    classes.push(...source.value);\n                } else {\n                    classes.push(source.value);\n                }\n            }\n            for (const map of maps) {\n                for (const key of map.keys()) {\n                    if (map.get(key)) {\n                        classes.push(key);\n                    }\n                }\n            }\n            result.update(classes.join(' '));\n        }\n\n        update();\n\n        for (const source of sources) {\n            source.listen(update, cancellationToken);\n        }\n\n        for (const map of maps) {\n            map.listen(update, cancellationToken);\n        }\n\n        return result;\n    } else {\n        return fixed;\n    }\n}\n\nexport function combineAttribute(cancellationToken: CancellationToken, ...args: AttributeValue[]): AttributeValue {\n    const constants: Array<string | boolean> = [];\n    const sources: ReadOnlyDataSource<string>[] = [];\n\n    for (const attr of args) {\n        if (typeof attr === 'string' || typeof attr === 'boolean') {\n            constants.push(attr);\n        }\n        if (attr instanceof DataSource || attr instanceof DuplexDataSource) {\n            sources.push(attr);\n        }\n    }\n\n    if (sources.length) {\n        return sources[0].aggregate(\n            sources.slice(1),\n            (...data) => {\n                if (constants.length) {\n                    return data.concat(constants).join(' ');\n                } else {\n                    return data.join(' ');\n                }\n            },\n            cancellationToken\n        );\n    } else {\n        return constants.join(' ');\n    }\n}\n\nexport function combineStyle(cancellationToken: CancellationToken, ...args: StyleType[]): StyleType {\n    let fixed: string = '';\n    const sources: ReadOnlyDataSource<string>[] = [];\n    const maps: MapDataSource<string, string>[] = [];\n\n    for (const attr of args) {\n        if (typeof attr === 'string') {\n            fixed += attr + ';';\n        } else if (attr instanceof DataSource || attr instanceof DuplexDataSource) {\n            sources.push(attr);\n        } else if (attr instanceof MapDataSource) {\n            maps.push(attr);\n        } else if (typeof attr === 'object' && !(attr instanceof DataSource || attr instanceof DuplexDataSource)) {\n            //@ts-ignore\n            for (const key in attr) {\n                if (attr[key] instanceof DataSource) {\n                    sources.push(attr[key].transform((v) => `${camelCaseToKebabCase(key)}:${v};`, cancellationToken));\n                } else {\n                    fixed += `${camelCaseToKebabCase(key)}:${attr[key]};`;\n                }\n            }\n        }\n    }\n\n    if (sources.length || maps.length) {\n        let result = new DataSource(computeResult(fixed, sources, maps));\n\n        for (const source of sources) {\n            source.listenAndRepeat((change) => {\n                result.update(computeResult(fixed, sources, maps));\n            }, cancellationToken);\n        }\n\n        for (const map of maps) {\n            map.listenAndRepeat((change) => {\n                result.update(computeResult(fixed, sources, maps));\n            }, cancellationToken);\n        }\n\n        return result;\n    } else {\n        return fixed;\n    }\n}\n\nfunction computeResult(fixed: string, sources: ReadOnlyDataSource<string>[], maps: MapDataSource<string, string>[]) {\n    let result = fixed;\n    for (const source of sources) {\n        result += source.value;\n    }\n\n    for (const map of maps) {\n        for (const key of map.keys()) {\n            if (map.get(key)) {\n                result += `${camelCaseToKebabCase(key)}:${map.get(key)};`;\n            }\n        }\n    }\n    return result;\n}\n\nexport function camelCaseToKebabCase(key: string): string {\n    return key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();\n}\n", "import { ArrayDataSource, DataSource, MapDataSource, ReadOnlyDataSource } from '../stream/data_source.js';\nimport { dsMap, dsUnique } from '../stream/data_source_operators.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { aurumClassName, camelCaseToKebabCase } from '../utilities/classname.js';\nimport { ClassType, StyleType } from '../utilities/common.js';\nimport { Data } from '../utilities/sources.js';\n\nexport function handleClass(data: ClassType, cleanUp: CancellationToken): Data<string> {\n    if (typeof data === 'string') {\n        return data;\n    } else if (data instanceof DataSource || data instanceof DuplexDataSource) {\n        return data\n            .transform(\n                dsUnique(),\n                dsMap((v) => {\n                    if (Array.isArray(v)) {\n                        return v.join(' ');\n                    } else {\n                        return v;\n                    }\n                }),\n                cleanUp\n            )\n            .withInitial(data.value);\n    } else if (data instanceof ArrayDataSource) {\n        return data.reduce<string>((p, c) => `${p} ${c}`, '', cleanUp);\n    } else if (data instanceof MapDataSource || (typeof data === 'object' && !Array.isArray(data))) {\n        const result = aurumClassName(data as any, cleanUp);\n        return handleClass(result, cleanUp);\n    } else {\n        const result = new DataSource<string>(buildClass(data));\n\n        for (const i of data as Array<string | ReadOnlyDataSource<string>>) {\n            if (i instanceof DataSource) {\n                i.transform(dsUnique(), cleanUp).listen((v) => {\n                    result.update(buildClass(data));\n                }, cleanUp);\n            }\n        }\n\n        return result;\n    }\n}\n\nfunction buildClass(data: (string | ReadOnlyDataSource<string>)[]): string {\n    return (data as Array<string | ReadOnlyDataSource<string>>).reduce<string>((p, c) => {\n        if (c == null) {\n            return p;\n        }\n\n        if (typeof c === 'string') {\n            return `${p} ${c}`;\n        } else {\n            if (c.value) {\n                return `${p} ${c.value}`;\n            } else {\n                return p;\n            }\n        }\n    }, '');\n}\n\nexport function handleStyle(data: StyleType, cleanUp: CancellationToken): Data<string> {\n    if (typeof data === 'string') {\n        return data;\n    } else if (data instanceof DataSource || data instanceof DuplexDataSource) {\n        return data.transform(\n            dsUnique(),\n            dsMap((v) => {\n                return v.toString();\n            }),\n            cleanUp\n        );\n    } else if (data instanceof MapDataSource) {\n        return data.toEntriesArrayDataSource(cleanUp).reduce<string>(\n            (p, c) => {\n                return `${p}${camelCaseToKebabCase(c[0])}:${c[1]};`;\n            },\n            '',\n            cleanUp\n        );\n    } else if (typeof data === 'object' && !Array.isArray(data)) {\n        const result = new ArrayDataSource<[string, string]>();\n        let index = 0;\n        for (const i in data) {\n            if (data[i] instanceof DataSource) {\n                const myIndex = index;\n                result.push([i, data[i].value]);\n                (data[i] as ReadOnlyDataSource<string>).listen((v) => {\n                    result.set(myIndex, [i, v]);\n                }, cleanUp);\n            } else {\n                result.push([i, data[i]]);\n            }\n            index++;\n        }\n\n        return result.reduce<string>((p, c) => `${p}${camelCaseToKebabCase(c[0])}:${c[1]};`, '', cleanUp);\n    } else {\n        return '';\n    }\n}\n", "import { ArrayDataSource, CollectionChange, DataSource, ReadOnlyArrayDataSource, ReadOnlyDataSource } from '../stream/data_source.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { EventEmitter } from '../utilities/event_emitter.js';\n\nexport type AurumComponent<T> = (props: T, children: Renderable[], api: AurumComponentAPI) => Renderable;\n\nexport function createRenderSession(): RenderSession {\n    const session = {\n        attachCalls: [],\n        sessionToken: new CancellationToken(() => {\n            for (const token of session.tokens) {\n                token.cancel();\n            }\n        }),\n        tokens: []\n    };\n\n    return session;\n}\n\nexport const aurumElementModelIdentitiy = Symbol('AurumElementModel');\n\nexport const nodeData = new WeakMap<any, AurumNodeData>();\n\nexport interface AurumNodeData {}\n\ntype ResolvedRenderable =\n    | AurumElement\n    | HTMLElement\n    | Text\n    | string\n    | number\n    | AurumElementModel<any>\n    | ReadOnlyDataSource<Renderable>\n    | ReadOnlyArrayDataSource<Renderable>\n    | DuplexDataSource<Renderable>;\n\nexport type Renderable = ResolvedRenderable | Promise<ResolvedRenderable>;\n\nexport type Rendered = AurumElement | HTMLElement | Text | SVGElement;\n\nexport interface ComponentLifeCycle {\n    onAttach(): void;\n    onDetach(): void;\n}\n\nexport interface ComponentLifeCycleInternal extends ComponentLifeCycle {\n    attach: EventEmitter<void>;\n    detach: EventEmitter<void>;\n}\n\nexport interface AurumComponentAPI {\n    synchronizeLifeCycle(lifeCycle: ComponentLifeCycle): void;\n    onAttach(cb: () => void): void;\n    onDetach(cb: () => void): void;\n    cancellationToken: CancellationToken;\n    prerender(children: Renderable[], lifeCycle: ComponentLifeCycle): any[];\n    prerender(child: Renderable, lifeCycle: ComponentLifeCycle): any;\n}\n\nexport interface AurumElementModel<T> {\n    [aurumElementModelIdentitiy]: boolean;\n    props: T;\n    name: string;\n    isIntrinsic: boolean;\n    children: Renderable[];\n    factory(props: T, children: Renderable[], api: AurumComponentAPI): Renderable;\n}\n\nexport function createLifeCycle(): ComponentLifeCycle {\n    const lc = {\n        attach: new EventEmitter<void>(),\n        detach: new EventEmitter<void>(),\n        onAttach() {\n            lc.attach.fire();\n        },\n        onDetach() {\n            lc.detach.fire();\n        }\n    } as ComponentLifeCycleInternal;\n\n    return lc;\n}\n\nexport abstract class AurumElement {\n    public children: Rendered[];\n    protected api: AurumComponentAPI;\n    private static id: number = 1;\n\n    protected contentStartMarker: Comment;\n    protected contentEndMarker: Comment;\n    protected hostNode: HTMLElement;\n    protected lastStartIndex: number;\n    protected lastEndIndex: number;\n    protected disposed: boolean = false;\n\n    constructor(dataSource: ArrayDataSource<any> | DataSource<any> | DuplexDataSource<any>, api: AurumComponentAPI) {\n        this.children = [];\n        this.api = api;\n        this.api.onAttach(() => {\n            if (!this.api.cancellationToken.isCancelled) {\n                if (this.hostNode === undefined) {\n                    throw new Error('illegal state: Attach fired but not actually attached');\n                }\n                this.render(dataSource);\n            }\n        });\n    }\n\n    public dispose(): void {\n        if (this.disposed) {\n            return;\n        }\n\n        if (this.hostNode.isConnected) {\n            this.clearContent();\n            this.contentStartMarker.remove();\n            this.contentEndMarker.remove();\n        }\n        this.disposed = true;\n    }\n\n    public attachToDom(node: HTMLElement, index: number): void {\n        if (this.hostNode) {\n            throw new Error('Aurum Element is already attached');\n        }\n        const id = AurumElement.id++;\n\n        this.hostNode = node;\n        this.contentStartMarker = document.createComment('START Aurum Node ' + id);\n        //@ts-ignore\n        this.contentStartMarker.owner = this;\n        this.contentEndMarker = document.createComment('END Aurum Node ' + id);\n        if (index >= node.childNodes.length) {\n            node.appendChild(this.contentStartMarker);\n            node.appendChild(this.contentEndMarker);\n        } else {\n            node.insertBefore(this.contentStartMarker, node.childNodes[index]);\n            node.insertBefore(this.contentEndMarker, node.childNodes[index + 1]);\n        }\n    }\n\n    protected getStartIndex(): number {\n        return this.getWorkIndex() - 1;\n    }\n\n    protected getWorkIndex(): number {\n        if (this.lastStartIndex !== undefined && this.hostNode.childNodes[this.lastStartIndex] === this.contentStartMarker) {\n            return this.lastStartIndex + 1;\n        }\n\n        for (let i = 0; i < this.hostNode.childNodes.length; i++) {\n            if (this.hostNode.childNodes[i] === this.contentStartMarker) {\n                this.lastStartIndex = i;\n                return i + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    protected getLastIndex(): number {\n        if (this.lastEndIndex !== undefined && this.hostNode.childNodes[this.lastEndIndex] === this.contentEndMarker) {\n            return this.lastEndIndex;\n        }\n\n        for (let i = 0; i < this.hostNode.childNodes.length; i++) {\n            if (this.hostNode.childNodes[i] === this.contentEndMarker) {\n                this.lastEndIndex = i;\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    protected abstract render(dataSource: DataSource<any> | ArrayDataSource<any> | DuplexDataSource<any>): void;\n\n    protected clearContent(): void {\n        if (this.hostNode === undefined) {\n            throw new Error('illegal state: Aurum element was not attched to anything');\n        }\n\n        let workIndex = this.getWorkIndex();\n        while (this.hostNode.childNodes[workIndex] !== this.contentEndMarker) {\n            if (!(this.hostNode.childNodes[workIndex] instanceof Comment)) {\n                this.hostNode.removeChild(this.hostNode.childNodes[workIndex]);\n            } else {\n                //@ts-ignore\n                if (this.hostNode.childNodes[workIndex].owner.disposed) {\n                    break;\n                }\n                //@ts-ignore\n                this.hostNode.childNodes[workIndex].owner.dispose();\n            }\n        }\n    }\n\n    protected updateDom(): void {\n        const workIndex = this.getWorkIndex();\n        let i: number;\n        let offset: number = 0;\n        for (i = 0; i < this.children.length; i++) {\n            const child = this.children[i];\n            if (child === undefined || child === null) {\n                offset--;\n                continue;\n            }\n\n            if (child === this.hostNode.childNodes[i + workIndex + offset]) {\n                continue;\n            }\n\n            if (child instanceof AurumElement) {\n                if (!child.hostNode) {\n                    child.attachToDom(this.hostNode, i + workIndex + offset);\n                }\n                if (child.getStartIndex() === i + workIndex + offset) {\n                    offset += child.getLastIndex() - i - offset - workIndex;\n                } else {\n                    let start = child.getStartIndex();\n                    let end = child.getLastIndex();\n\n                    for (let ptr = start, swapIteration = 0; ptr <= end; ptr++, swapIteration++) {\n                        const itemA = this.hostNode.childNodes[i + workIndex + offset + swapIteration];\n                        const itemB = this.hostNode.childNodes[ptr];\n                        const parentA = itemA.parentNode;\n                        const siblingA = itemA.nextSibling === itemB ? itemB : itemA.nextSibling;\n\n                        itemB.parentNode.insertBefore(itemA, itemB);\n                        parentA.insertBefore(itemB, siblingA);\n                    }\n                    offset += child.getLastIndex() - i - offset - workIndex;\n                }\n                continue;\n            }\n\n            if (\n                this.hostNode.childNodes[i + workIndex + offset] !== this.contentEndMarker &&\n                this.hostNode.childNodes[i + workIndex + offset] !== this.children[i] &&\n                this.hostNode.childNodes[i + workIndex + offset] !== (this.children[i + 1] as SingularAurumElement)?.contentStartMarker\n            ) {\n                if (child instanceof HTMLElement || child instanceof Text || child instanceof SVGElement) {\n                    this.hostNode.removeChild(this.hostNode.childNodes[i + workIndex + offset]);\n                    if (this.hostNode.childNodes[i + workIndex + offset]) {\n                        this.lastEndIndex++;\n                        this.hostNode.insertBefore(child, this.hostNode.childNodes[i + workIndex + offset]);\n                    } else {\n                        this.lastEndIndex++;\n                        this.hostNode.appendChild(child);\n                    }\n                } else {\n                    throw new Error('not implemented');\n                }\n            } else {\n                if (child instanceof HTMLElement || child instanceof Text || child instanceof SVGElement) {\n                    if (this.hostNode.childNodes[i + workIndex + offset]) {\n                        this.lastEndIndex++;\n                        this.hostNode.insertBefore(child, this.hostNode.childNodes[i + workIndex + offset]);\n                    } else {\n                        this.lastEndIndex++;\n                        this.hostNode.appendChild(child);\n                    }\n                } else {\n                    throw new Error('not implemented');\n                }\n            }\n        }\n        while (this.hostNode.childNodes[i + workIndex + offset] !== this.contentEndMarker) {\n            this.lastEndIndex--;\n            this.hostNode.removeChild(this.hostNode.childNodes[i + workIndex + offset]);\n        }\n    }\n}\n\n/**\n * @internal\n */\nexport interface RenderSession {\n    attachCalls: Array<() => void>;\n    tokens: CancellationToken[];\n    sessionToken: CancellationToken;\n}\n\n/**\n * @internal\n */\nexport function renderInternal<T extends Renderable | Renderable[]>(element: T, session: RenderSession, prerendering: boolean = false): any {\n    if (element == undefined) {\n        return undefined;\n    }\n\n    if (Array.isArray(element)) {\n        const result = [];\n        for (const item of element) {\n            const rendered = renderInternal(item, session, prerendering);\n            // Flatten the rendered content into a single array to avoid having to iterate over nested arrays later\n            if (rendered !== undefined && rendered !== null) {\n                if (Array.isArray(rendered)) {\n                    result.push(...rendered);\n                } else {\n                    result.push(rendered);\n                }\n            }\n        }\n        return result;\n    }\n\n    if (!prerendering) {\n        const type = typeof element;\n        if (type === 'string') {\n            return document.createTextNode(element as string) as any;\n        } else if (type === 'number' || type === 'bigint' || type === 'boolean') {\n            return document.createTextNode(element.toString()) as any;\n        }\n\n        if (element instanceof Promise) {\n            const ds = new DataSource();\n            element.then((val) => {\n                ds.update(val);\n            });\n            const result = new SingularAurumElement(ds, createAPI(session));\n            return result as any;\n        } else if (element instanceof DataSource || element instanceof DuplexDataSource) {\n            const result = new SingularAurumElement(element as any, createAPI(session));\n            return result as any;\n        } else if (element instanceof ArrayDataSource) {\n            const result = new ArrayAurumElement(element as any, createAPI(session));\n            return result as any;\n        }\n    }\n\n    if (element[aurumElementModelIdentitiy]) {\n        const model: AurumElementModel<any> = element as any as AurumElementModel<any>;\n        let api: AurumComponentAPI;\n        //Optimization: skip creating API for no props basic html nodes because they are by far the most frequent and this can yield a noticable performance increase\n        if (!model.isIntrinsic || model.props) {\n            api = createAPI(session);\n        } else {\n            api = {\n                renderSession: session\n            } as any;\n        }\n        let componentResult;\n        if (model.isIntrinsic) {\n            componentResult = model.factory(model.props, model.children, api);\n        } else {\n            componentResult = model.factory(model.props ?? {}, model.children, api);\n        }\n        return renderInternal(componentResult, session, prerendering);\n    }\n    // Unsupported types are returned as is in hope that a transclusion component will transform it into something compatible\n    return element as any;\n}\n\n/**\n * @internal\n */\nexport function createAPI(session: RenderSession): AurumComponentAPI {\n    let token: CancellationToken = undefined;\n    const api = {\n        renderSession: session,\n        synchronizeLifeCycle(lifeCycle: ComponentLifeCycle): void {\n            api.onAttach(() => lifeCycle.onAttach());\n            api.onDetach(() => lifeCycle.onDetach());\n        },\n        onAttach: (cb) => {\n            session.attachCalls.push(cb);\n        },\n        onDetach: (cb) => {\n            if (!token) {\n                token = new CancellationToken();\n                session.tokens.push(token);\n            }\n            token.addCancellable(cb);\n        },\n        get cancellationToken() {\n            if (!token) {\n                token = new CancellationToken();\n                session.tokens.push(token);\n            }\n            return token;\n        },\n        prerender(target: Renderable | Renderable[], lifeCycle: ComponentLifeCycle) {\n            const lc = lifeCycle as ComponentLifeCycleInternal;\n            const subSession = createRenderSession();\n            const result = renderInternal(target, subSession, true);\n\n            lc.attach.subscribeOnce(() => {\n                subSession.attachCalls.forEach((cb) => cb());\n            });\n\n            lc.detach.subscribeOnce(() => {\n                lc.attach.cancelAll();\n                subSession.sessionToken.cancel();\n            });\n            return result;\n        }\n    };\n\n    return api;\n}\n\nexport class ArrayAurumElement extends AurumElement {\n    private renderSessions: WeakMap<any, RenderSession>;\n    private dataSource: ArrayDataSource<any>;\n\n    constructor(dataSource: ArrayDataSource<any>, api: AurumComponentAPI) {\n        super(dataSource, api);\n        this.renderSessions = new WeakMap();\n        this.dataSource = dataSource;\n    }\n\n    public dispose(): void {\n        if (this.disposed) {\n            return;\n        }\n        this.api.cancellationToken.cancel();\n        super.dispose();\n    }\n\n    public attachToDom(node: HTMLElement, index: number): void {\n        super.attachToDom(node, index);\n        //@ts-ignore\n        this.contentStartMarker.dataSource = this.dataSource;\n        //@ts-ignore\n        this.contentEndMarker.dataSource = this.dataSource;\n    }\n\n    protected render(dataSource: ArrayDataSource<any>): void {\n        dataSource.listenAndRepeat((n) => {\n            if (!this.disposed) {\n                this.handleNewContent(n);\n            }\n        }, this.api.cancellationToken);\n    }\n\n    private spliceChildren(index: number, amount: number, ...newItems: Rendered[]): void {\n        let removed;\n        if (newItems) {\n            removed = this.children.splice(index, amount, ...newItems);\n        } else {\n            removed = this.children.splice(index, amount);\n        }\n        for (const item of removed) {\n            this.renderSessions.get(item)?.sessionToken.cancel();\n        }\n    }\n\n    private handleNewContent(change: CollectionChange<any>): void {\n        if (this.hostNode === undefined) {\n            throw new Error('illegal state: Aurum element was not attched to anything');\n        }\n\n        let optimized = false;\n        const ac = [];\n        switch (change.operationDetailed) {\n            case 'merge':\n                const source = change.previousState.slice();\n                for (let i = 0; i < change.newState.length; i++) {\n                    if (this.children.length <= i) {\n                        const rendered = this.renderItem(change.newState[i], ac);\n                        if (Array.isArray(rendered)) {\n                            this.children.push(...rendered);\n                        } else {\n                            this.children.push(rendered);\n                        }\n                        source.push(change.newState[i]);\n                    } else if (source[i] !== change.newState[i]) {\n                        const index = source.indexOf(change.newState[i], i);\n                        if (index !== -1) {\n                            const a = this.children[i];\n                            const b = this.children[index];\n                            this.children[i] = b;\n                            this.children[index] = a;\n                            const c = source[i];\n                            const d = source[index];\n                            source[i] = d;\n                            source[index] = c;\n                        } else {\n                            const rendered = this.renderItem(change.newState[i], ac);\n                            if (Array.isArray(rendered)) {\n                                this.spliceChildren(i, 0, ...rendered);\n                            } else {\n                                this.spliceChildren(i, 0, rendered);\n                            }\n                            source.splice(i, 0, change.newState[i]);\n                        }\n                    }\n                }\n                if (this.children.length > change.newState.length) {\n                    this.spliceChildren(change.newState.length, this.children.length - change.newState.length);\n                }\n                break;\n            case 'remove':\n            case 'removeLeft':\n            case 'removeRight':\n                this.spliceChildren(flattenIndex(change.newState, change.index), flattenIndex(change.items, change.items.length));\n                break;\n            case 'append':\n                let targetIndex = this.getLastIndex();\n                optimized = true;\n                for (const item of change.items) {\n                    const rendered = this.renderItem(item, ac);\n                    if (Array.isArray(rendered)) {\n                        this.children = this.children.concat(rendered);\n\n                        for (let i = 0; i <= rendered.length; i++) {\n                            if (rendered[i]) {\n                                if (rendered[i] instanceof AurumElement) {\n                                    rendered[i].attachToDom(this.hostNode, targetIndex);\n                                    this.lastEndIndex = this.getLastIndex();\n                                    targetIndex = this.lastEndIndex;\n                                } else {\n                                    this.hostNode.insertBefore(rendered[i], this.hostNode.childNodes[targetIndex]);\n                                    this.lastEndIndex++;\n                                    targetIndex++;\n                                }\n                            }\n                        }\n                    } else {\n                        this.children.push(rendered);\n                        if (rendered) {\n                            if (rendered instanceof AurumElement) {\n                                rendered.attachToDom(this.hostNode, targetIndex);\n                                this.lastEndIndex = this.getLastIndex();\n                                targetIndex = this.lastEndIndex;\n                            } else {\n                                this.hostNode.insertBefore(rendered, this.hostNode.childNodes[targetIndex]);\n                                this.lastEndIndex++;\n                                targetIndex++;\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'replace':\n                const rendered = this.renderItem(change.items[0], ac);\n                if (Array.isArray(rendered)) {\n                    throw new Error('illegal state');\n                } else {\n                    this.children[change.index] = rendered;\n                }\n                break;\n            case 'swap':\n                const itemA = this.children[change.index];\n                const itemB = this.children[change.index2];\n\n                if ((itemA instanceof HTMLElement && itemB instanceof HTMLElement) || (itemA instanceof SVGElement && itemB instanceof SVGElement)) {\n                    optimized = true;\n                    if (itemA.parentElement === itemB.parentElement) {\n                        if (itemA.nextSibling === itemB) {\n                            itemB.parentNode.insertBefore(itemB, itemA);\n                            this.children[change.index2] = itemA;\n                            this.children[change.index] = itemB;\n                            break;\n                        }\n                        if (itemB.nextSibling === itemA) {\n                            itemB.parentNode.insertBefore(itemA, itemB);\n                            this.children[change.index2] = itemA;\n                            this.children[change.index] = itemB;\n                            break;\n                        }\n                    }\n\n                    const parentA = itemA.parentNode;\n                    const siblingA = itemA.nextSibling === itemB ? itemB : itemA.nextSibling;\n\n                    itemB.parentNode.insertBefore(itemA, itemB);\n                    parentA.insertBefore(itemB, siblingA);\n                }\n                this.children[change.index2] = itemA;\n                this.children[change.index] = itemB;\n                break;\n            case 'prepend':\n                for (let i = change.items.length - 1; i >= 0; i--) {\n                    const item = change.items[i];\n                    const rendered = this.renderItem(item, ac);\n                    if (Array.isArray(rendered)) {\n                        throw new Error('illegal state');\n                    } else {\n                        this.children.unshift(rendered);\n                    }\n                }\n                break;\n            case 'insert':\n                let index = change.index;\n                for (const item of change.items) {\n                    const rendered = this.renderItem(item, ac);\n                    if (Array.isArray(rendered)) {\n                        throw new Error('illegal state');\n                    } else {\n                        this.children.splice(index, 0, rendered);\n                        index += 1;\n                    }\n                }\n                break;\n            case 'clear':\n                this.spliceChildren(0, this.children.length);\n                this.renderSessions = new WeakMap();\n                break;\n            default:\n                throw new Error(`DOM updates from ${change.operationDetailed} are not supported`);\n        }\n        if (!optimized) {\n            this.updateDom();\n        }\n        for (const c of ac) {\n            c();\n        }\n    }\n\n    private renderItem(item: any, attachCalls: any[]) {\n        if (item === null || item === undefined) {\n            return;\n        }\n\n        const s = createRenderSession();\n        const rendered = renderInternal(item, s);\n        if (rendered === undefined || rendered === null) {\n            return;\n        }\n        if (rendered instanceof AurumElement) {\n            s.sessionToken.addCancellable(() => rendered.dispose());\n        }\n        this.renderSessions.set(rendered, s);\n        attachCalls.push(...s.attachCalls);\n        return rendered;\n    }\n}\n\nfunction flattenIndex(source: any[], index: number) {\n    let flatIndex = 0;\n    for (let i = 0; i < index; i++) {\n        if (Array.isArray(source[i])) {\n            flatIndex += flattenIndex(source[i], source[i].length);\n        } else {\n            flatIndex++;\n        }\n    }\n\n    return flatIndex;\n}\n\nexport class SingularAurumElement extends AurumElement {\n    private renderSession: RenderSession;\n    private lastValue: any;\n    private dataSource: DataSource<any> | DuplexDataSource<any>;\n\n    constructor(dataSource: DataSource<any> | DuplexDataSource<any>, api: AurumComponentAPI) {\n        super(dataSource, api);\n        this.api.cancellationToken.addCancellable(() => this.renderSession?.sessionToken.cancel());\n        this.dataSource = dataSource;\n    }\n\n    public dispose(): void {\n        if (this.disposed) {\n            return;\n        }\n        this.api.cancellationToken.cancel();\n        super.dispose();\n    }\n\n    public attachToDom(node: HTMLElement, index: number): void {\n        super.attachToDom(node, index);\n        //@ts-ignore\n        this.contentStartMarker.dataSource = this.dataSource;\n        //@ts-ignore\n        this.contentEndMarker.dataSource = this.dataSource;\n    }\n\n    protected render(dataSource: DataSource<any> | DuplexDataSource<any>): void {\n        dataSource.listenAndRepeat((n) => {\n            if (!this.disposed) {\n                this.handleNewContent(n);\n            }\n        }, this.api.cancellationToken);\n    }\n\n    private handleNewContent(newValue: any): void {\n        if (this.lastValue === newValue) {\n            return;\n        }\n        let optimized = false;\n        if (this.children.length === 1 && this.children[0] instanceof Text) {\n            const type = typeof newValue;\n            if (type === 'string' || type === 'bigint' || type === 'number' || type === 'boolean') {\n                this.children[0].nodeValue = newValue;\n                optimized = true;\n            }\n        }\n        if (!optimized) {\n            this.fullRebuild(newValue);\n            this.updateDom();\n            for (const cb of this.renderSession.attachCalls) {\n                cb();\n            }\n        }\n\n        this.lastValue = newValue;\n    }\n\n    private fullRebuild(newValue: any): void {\n        this.clearContent();\n        this.endSession();\n        this.renderSession = createRenderSession();\n        let rendered = renderInternal(newValue, this.renderSession);\n        if (rendered === undefined) {\n            this.children = [];\n            return;\n        }\n\n        if (!Array.isArray(rendered)) {\n            rendered = [rendered];\n        }\n        for (const item of rendered) {\n            if (item instanceof AurumElement) {\n                this.renderSession.sessionToken.addCancellable(() => {\n                    item.dispose();\n                });\n            }\n        }\n\n        if (Array.isArray(rendered)) {\n            this.children = rendered;\n        }\n    }\n\n    private endSession(): void {\n        if (this.renderSession) {\n            this.renderSession.sessionToken.cancel();\n            this.renderSession = undefined;\n        }\n    }\n}\n", "import { handleClass, handleStyle } from '../../nodes/rendering_helpers.js';\nimport { AurumComponentAPI, AurumElement, createRenderSession, Renderable, Rendered, renderInternal } from '../aurum_element.js';\nimport { DataSource } from '../../stream/data_source.js';\nimport { dsUnique } from '../../stream/data_source_operators.js';\nimport { DuplexDataSource } from '../../stream/duplex_data_source.js';\nimport { CancellationToken } from '../../utilities/cancellation_token.js';\nimport { AttributeValue, Callback, ClassType, DataDrain, MapLike, StringSource, StyleType } from '../../utilities/common.js';\nimport { AurumDecorator } from '../../utilities/aurum.js';\n\nexport interface HTMLNodeProps<T> {\n    decorate?: AurumDecorator | AurumDecorator[];\n    id?: AttributeValue;\n    name?: AttributeValue;\n    draggable?: AttributeValue;\n    class?: ClassType;\n    tabindex?: AttributeValue;\n    style?: StyleType;\n    title?: AttributeValue;\n    role?: AttributeValue;\n    slot?: AttributeValue;\n    contenteditable?: AttributeValue;\n    onContextMenu?: DataDrain<MouseEvent>;\n    onDblClick?: DataDrain<MouseEvent>;\n    onClick?: DataDrain<MouseEvent>;\n    onKeyDown?: DataDrain<KeyboardEvent>;\n    onKeyUp?: DataDrain<KeyboardEvent>;\n    onMouseDown?: DataDrain<MouseEvent>;\n    onMouseUp?: DataDrain<MouseEvent>;\n    onMouseEnter?: DataDrain<MouseEvent>;\n    onMouseLeave?: DataDrain<MouseEvent>;\n    onMouseMove?: DataDrain<MouseEvent>;\n    onMouseWheel?: DataDrain<WheelEvent>;\n    onBlur?: DataDrain<FocusEvent>;\n    onFocus?: DataDrain<FocusEvent>;\n    onDrag?: DataDrain<DragEvent>;\n    onDragEnd?: DataDrain<DragEvent>;\n    onDragEnter?: DataDrain<DragEvent>;\n    onDragExit?: DataDrain<DragEvent>;\n    onDragLeave?: DataDrain<DragEvent>;\n    onDragOver?: DataDrain<DragEvent>;\n    onDragStart?: DataDrain<DragEvent>;\n    onDrop?: DataDrain<DragEvent>;\n    onLoad?: DataDrain<Event>;\n    onError?: DataDrain<ErrorEvent>;\n\n    onAttach?: Callback<T>;\n    onDetach?: Callback<T>;\n}\n\n/**\n * @internal\n */\nexport const defaultEvents: MapLike<string> = {\n    drag: 'onDrag',\n    dragstart: 'onDragStart',\n    dragend: 'onDragEnd',\n    dragexit: 'onDragExit',\n    dragover: 'onDragOver',\n    dragenter: 'onDragEnter',\n    dragleave: 'onDragLeave',\n    drop: 'onDrop',\n    blur: 'onBlur',\n    focus: 'onFocus',\n    click: 'onClick',\n    dblclick: 'onDblClick',\n    keydown: 'onKeyDown',\n    keyhit: 'onKeyHit',\n    keyup: 'onKeyUp',\n    contextmenu: 'onContextMenu',\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mousemove: 'onMouseMove',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mousewheel: 'onMouseWheel',\n    load: 'onLoad',\n    error: 'onError'\n};\n\n/**\n * @internal\n */\nexport const defaultAttributes: string[] = ['id', 'name', 'draggable', 'tabindex', 'role', 'contenteditable', 'slot', 'title'];\n\nexport function DomNodeCreator<T extends HTMLNodeProps<any>>(\n    nodeName: string,\n    extraAttributes?: string[],\n    extraEvents?: MapLike<string>,\n    extraLogic?: (node: HTMLElement, props: T, cleanUp: CancellationToken) => void,\n    svg: boolean = false\n) {\n    return function (props: T, children: Renderable[], api: AurumComponentAPI): HTMLElement {\n        let node;\n        if (svg) {\n            node = document.createElementNS('http://www.w3.org/2000/svg', nodeName);\n        } else {\n            node = document.createElement(nodeName);\n        }\n        if (props) {\n            processHTMLNode(node, props, api.cancellationToken, extraAttributes, extraEvents);\n        }\n        //@ts-ignore\n        const renderedChildren = renderInternal(children, api.renderSession);\n        connectChildren(node, renderedChildren);\n        if (props) {\n            if (props.onAttach) {\n                api.onAttach(() => props.onAttach(node));\n            }\n            if (props.onDetach) {\n                api.onDetach(() => {\n                    if (node.isConnected) {\n                        node.parentElement.removeChild(node);\n                    }\n                    props.onDetach(node);\n                });\n            }\n        }\n\n        extraLogic?.(node, props, api.cancellationToken);\n\n        return node;\n    };\n}\n\nfunction connectChildren(target: HTMLElement, children: Rendered[]): void {\n    if (children === undefined || children === null || children.length === 0) {\n        return;\n    }\n\n    for (const child of children) {\n        if (!child) {\n            continue;\n        }\n        if (child instanceof Text || child instanceof HTMLElement || child instanceof SVGElement) {\n            target.appendChild(child);\n        } else if (child instanceof AurumElement) {\n            child.attachToDom(target, target.childNodes.length);\n        } else {\n            if (typeof child === 'function') {\n                throw new Error(\n                    'Unexpected child type passed to DOM Node: function. Did you mean to use a component? To use a component use JSX syntax such as <MyComponent/> it works even with function references. <props.myReference/>'\n                );\n            }\n\n            throw new Error(`Unexpected child type passed to DOM Node: ${children}`);\n        }\n    }\n}\n\nexport function processHTMLNode(\n    node: HTMLElement,\n    props: HTMLNodeProps<any>,\n    cleanUp: CancellationToken,\n    extraAttributes?: string[],\n    extraEvents?: MapLike<string>\n) {\n    createEventHandlers(node, defaultEvents, props);\n    if (extraEvents) {\n        createEventHandlers(node, extraEvents, props);\n    }\n\n    const dataProps = Object.keys(props).filter((e) => e.includes('-'));\n    bindProps(node, defaultAttributes, props, cleanUp, dataProps);\n    if (extraAttributes) {\n        bindProps(node, extraAttributes, props, cleanUp);\n    }\n\n    if (props.style) {\n        const result = handleStyle(props.style, cleanUp);\n        if (result instanceof DataSource) {\n            result.listenAndRepeat((v) => {\n                node.setAttribute('style', v);\n            }, cleanUp);\n        } else {\n            node.setAttribute('style', result);\n        }\n    }\n\n    if (props.class) {\n        const result = handleClass(props.class, cleanUp);\n        if (result instanceof DataSource) {\n            result.listenAndRepeat((v) => {\n                node.className = v;\n            }, cleanUp);\n        } else {\n            node.className = result;\n        }\n    }\n}\n\nexport function createEventHandlers(node: HTMLElement, events: MapLike<string>, props: any) {\n    for (const key in events) {\n        if (props[events[key]]) {\n            if (props[events[key]] instanceof DataSource) {\n                //@ts-ignore\n                node.addEventListener(key, (e: MouseEvent) => props[events[key]].update(e));\n            } else if (props[events[key]] instanceof DuplexDataSource) {\n                //@ts-ignore\n                node.addEventListener(key, (e: MouseEvent) => props[events[key]].updateDownstream(e));\n            } else if (typeof props[events[key]] === 'function') {\n                //@ts-ignore\n                node.addEventListener(key, (e: MouseEvent) => props[events[key]](e));\n            }\n        }\n    }\n}\n\nfunction bindProps(node: HTMLElement, keys: string[], props: any, cleanUp: CancellationToken, dynamicProps?: string[]) {\n    for (const key of keys) {\n        if (props[key]) {\n            assignStringSourceToAttribute(node, props[key], key, cleanUp);\n        }\n    }\n    if (dynamicProps) {\n        for (const key of dynamicProps) {\n            if (props[key]) {\n                assignStringSourceToAttribute(node, props[key], key, cleanUp);\n            }\n        }\n    }\n}\n\n/**\n * Renders Aurum content synchronously in line. In case no lifecycle sync object is provided you have to manually call fireOnAttach and dispose at the appropriate times to ensure proper lifecycle handling such as attach and detach events\n * @param content Content to render\n * @param syncLifecycle Optional lifecycle sync object. If provided the lifecycle of the rendered content will be synchronized with the provided lifecycle (meaning attach and detach events will be fired when the lifecycle fires them)\n */\nexport function aurumToHTML(content: Renderable, syncLifecycle?: AurumComponentAPI): { content: HTMLElement; fireOnAttach(): void; dispose(): void } {\n    const rs = createRenderSession();\n    const renderedContent = renderInternal(content, rs);\n\n    if (syncLifecycle) {\n        syncLifecycle.onAttach(() => rs.attachCalls.forEach((c) => c()));\n        syncLifecycle.onDetach(() => rs.sessionToken.cancel());\n    }\n\n    return {\n        content: renderedContent,\n        fireOnAttach: () => rs.attachCalls.forEach((c) => c()),\n        dispose: () => rs.sessionToken.cancel()\n    };\n}\n\nfunction assignStringSourceToAttribute(node: HTMLElement, data: StringSource, key: string, cleanUp: CancellationToken) {\n    if (typeof data === 'string') {\n        node.setAttribute(key, data);\n    } else if (typeof data === 'boolean') {\n        if (data) {\n            node.setAttribute(key, '');\n        }\n    } else if (data instanceof DataSource || data instanceof DuplexDataSource) {\n        if (typeof data.value === 'string') {\n            node.setAttribute(key, data.value);\n        } else if (typeof data.value === 'boolean') {\n            if (data.value) {\n                node.setAttribute(key, '');\n            }\n        }\n        data.transform(dsUnique(), cleanUp).listen((v) => {\n            if (typeof v === 'string') {\n                node.setAttribute(key, v);\n            } else if (typeof v === 'boolean') {\n                if (v) {\n                    node.setAttribute(key, '');\n                } else {\n                    node.removeAttribute(key);\n                }\n            }\n        });\n    } else {\n        throw new Error('Attributes only support types boolean, string, number and data sources');\n    }\n}\n", "import { HTMLNodeProps, DomNodeCreator } from '../rendering/renderers/dom_adapter.js';\nimport { AttributeValue, DataDrain } from '../utilities/common.js';\nimport { GenericDataSource, DataSource } from '../stream/data_source.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\n\nexport interface InputProps extends HTMLNodeProps<HTMLInputElement> {\n    placeholder?: AttributeValue;\n    readonly?: AttributeValue;\n    disabled?: AttributeValue;\n    onChange?: DataDrain<InputEvent>;\n    onInput?: DataDrain<InputEvent>;\n    value?: GenericDataSource<string> | string;\n    accept?: AttributeValue;\n    alt?: AttributeValue;\n    autocomplete?: AttributeValue;\n    autofocus?: AttributeValue;\n    checked?: GenericDataSource<boolean> | boolean;\n    formAction?: AttributeValue;\n    formEnctype?: AttributeValue;\n    formMethod?: AttributeValue;\n    formNoValidate?: AttributeValue;\n    formTarget?: AttributeValue;\n    step?: AttributeValue;\n    list?: AttributeValue;\n    max?: AttributeValue;\n    maxLength?: AttributeValue;\n    min?: AttributeValue;\n    minLength?: AttributeValue;\n    pattern?: AttributeValue;\n    multiple?: AttributeValue;\n    required?: AttributeValue;\n    type?: AttributeValue;\n}\n\n/**\n * @internal\n */\nconst inputEvents = { input: 'onInput', change: 'onChange' };\n\n/**\n * @internal\n */\nconst inputProps = [\n    'placeholder',\n    'readonly',\n    'disabled',\n    'accept',\n    'alt',\n    'autocomplete',\n    'autofocus',\n    'checked',\n    'defaultChecked',\n    'formAction',\n    'formEnctype',\n    'formMethod',\n    'formNoValidate',\n    'formTarget',\n    'max',\n    'maxLength',\n    'min',\n    'minLength',\n    'pattern',\n    'multiple',\n    'required',\n    'type',\n    'step',\n    'list'\n];\n\n/**\n * @internal\n */\nexport const Input = DomNodeCreator<InputProps>('input', inputProps, inputEvents, (node: HTMLElement, props: InputProps, cleanUp: CancellationToken) => {\n    const input = node as HTMLInputElement;\n    if (props.value) {\n        if (props.value instanceof DataSource) {\n            props.value.listenAndRepeat((v) => {\n                input.value = v ?? '';\n            }, cleanUp);\n            input.addEventListener('input', () => {\n                (props.value as DataSource<string>).update(input.value);\n            });\n        } else if (props.value instanceof DuplexDataSource) {\n            props.value.listenAndRepeat((v) => {\n                input.value = v ?? '';\n            }, cleanUp);\n            input.addEventListener('input', () => {\n                (props.value as DuplexDataSource<string>).updateUpstream(input.value);\n            });\n        } else {\n            input.value = props.value as string;\n        }\n    }\n\n    if (props.checked) {\n        if (props.checked instanceof DataSource) {\n            props.checked.listenAndRepeat((v) => {\n                input.checked = v ?? false;\n            }, cleanUp);\n            input.addEventListener('change', () => {\n                (props.checked as DataSource<boolean>).update(input.checked);\n            });\n        } else if (props.checked instanceof DuplexDataSource) {\n            props.checked.listenAndRepeat((v) => {\n                input.checked = v ?? false;\n            }, cleanUp);\n            input.addEventListener('change', () => {\n                (props.checked as DuplexDataSource<boolean>).updateUpstream(input.checked);\n            });\n        } else {\n            input.checked = props.checked as boolean;\n        }\n    }\n});\n", "import { DataSource, GenericDataSource } from '../stream/data_source.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { DomNodeCreator, HTMLNodeProps } from '../rendering/renderers/dom_adapter.js';\n\nexport interface SelectProps extends HTMLNodeProps<HTMLSelectElement> {\n    value?: GenericDataSource<string> | string;\n    selectedIndex?: GenericDataSource<number> | number;\n}\n\n/**\n * @internal\n */\nconst selectEvents = { change: 'onChange' };\n\n/**\n * @internal\n */\nexport const Select = DomNodeCreator<SelectProps>('select', undefined, selectEvents, (node: HTMLElement, props: SelectProps, cleanUp: CancellationToken) => {\n    const select = node as HTMLSelectElement;\n\n    if (props?.value || props?.selectedIndex) {\n        // In case props.value is a data source we need to reapply the value when the children change because the children may be unstable/be removed and re-added which would falsify the state.\n        if (props.value instanceof DataSource || props.value instanceof DuplexDataSource) {\n            const mo = new MutationObserver(() => {\n                select.value = (props.value as GenericDataSource<string>).value;\n            });\n            mo.observe(select, {\n                childList: true\n            });\n\n            cleanUp.addCancellable(() => {\n                mo.disconnect();\n            });\n        }\n\n        if (props.selectedIndex instanceof DataSource || props.selectedIndex instanceof DuplexDataSource) {\n            const mo = new MutationObserver(() => {\n                select.selectedIndex = (props.selectedIndex as GenericDataSource<number>).value;\n            });\n            mo.observe(select, {\n                childList: true\n            });\n\n            cleanUp.addCancellable(() => {\n                mo.disconnect();\n            });\n        }\n\n        if (props.value instanceof DataSource) {\n            props.value.listenAndRepeat((v) => {\n                select.value = v;\n            }, cleanUp);\n            select.addEventListener('change', () => {\n                (props.value as DataSource<string>).update(select.value);\n            });\n        } else if (props.value instanceof DuplexDataSource) {\n            props.value.listenAndRepeat((v) => {\n                select.value = v;\n            }, cleanUp);\n            select.addEventListener('change', () => {\n                (props.value as DuplexDataSource<string>).updateUpstream(select.value);\n            });\n        } else {\n            select.value = props.value as string;\n        }\n\n        if (props?.selectedIndex) {\n            if (props.selectedIndex instanceof DataSource) {\n                props.selectedIndex.listenAndRepeat((v) => {\n                    select.selectedIndex = v;\n                }, cleanUp);\n                select.addEventListener('change', () => {\n                    (props.selectedIndex as DataSource<number>).update(select.selectedIndex);\n                });\n            } else if (props.selectedIndex instanceof DuplexDataSource) {\n                props.selectedIndex.listenAndRepeat((v) => {\n                    select.selectedIndex = v;\n                }, cleanUp);\n                select.addEventListener('change', () => {\n                    (props.selectedIndex as DuplexDataSource<number>).updateUpstream(select.selectedIndex);\n                });\n            } else {\n                select.selectedIndex = props.selectedIndex as number;\n            }\n        }\n    }\n});\n", "import { DomNodeCreator, HTMLNodeProps } from '../rendering/renderers/dom_adapter.js';\nimport { AttributeValue, DataDrain } from '../utilities/common.js';\n\nexport const Code = DomNodeCreator<HTMLNodeProps<HTMLElement>>('code');\nexport const Div = DomNodeCreator<HTMLNodeProps<HTMLDivElement>>('div');\n\n/**\n * @internal\n */\nexport interface AProps extends HTMLNodeProps<HTMLAnchorElement> {\n    href?: AttributeValue;\n    hreflang?: AttributeValue;\n    media?: AttributeValue;\n    download?: AttributeValue;\n    target?: AttributeValue;\n    ping?: AttributeValue;\n    referrerpolicy?: AttributeValue;\n    rel?: AttributeValue;\n    type?: AttributeValue;\n}\n/**\n * @internal\n */\nexport const A = DomNodeCreator<AProps>('a', ['href', 'target', 'hreflang', 'media', 'download', 'ping', 'referrerpolicy', 'rel', 'type']);\n/**\n * @internal\n */\nexport const Abbr = DomNodeCreator<HTMLNodeProps<HTMLElement>>('abbr');\n/**\n * @internal\n */\nexport const Address = DomNodeCreator<HTMLNodeProps<HTMLElement>>('address');\n/**\n * @internal\n */\nexport const H1 = DomNodeCreator<HTMLNodeProps<HTMLElement>>('h1');\n/**\n * @internal\n */\nexport const H2 = DomNodeCreator<HTMLNodeProps<HTMLElement>>('h2');\n/**\n * @internal\n */\nexport const H3 = DomNodeCreator<HTMLNodeProps<HTMLElement>>('h3');\n/**\n * @internal\n */\nexport const H4 = DomNodeCreator<HTMLNodeProps<HTMLElement>>('h4');\n/**\n * @internal\n */\nexport const H5 = DomNodeCreator<HTMLNodeProps<HTMLElement>>('h5');\n/**\n * @internal\n */\nexport const H6 = DomNodeCreator<HTMLNodeProps<HTMLElement>>('h6');\n\n/**\n * @internal\n */\nexport interface AreaProps extends HTMLNodeProps<HTMLAreaElement> {\n    alt?: AttributeValue;\n    coords?: AttributeValue;\n    download?: AttributeValue;\n    href?: AttributeValue;\n    hreflang?: AttributeValue;\n    media?: AttributeValue;\n    rel?: AttributeValue;\n    shape?: AttributeValue;\n    target?: AttributeValue;\n    type?: AttributeValue;\n    ping?: AttributeValue;\n    referrerpolicy?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Area = DomNodeCreator<AreaProps>('area', [\n    'alt',\n    'coors',\n    'download',\n    'href',\n    'hreflang',\n    'media',\n    'rel',\n    'shape',\n    'target',\n    'type',\n    'ping',\n    'referrerpolicy'\n]);\n/**\n * @internal\n */\nexport const Article = DomNodeCreator<HTMLNodeProps<HTMLElement>>('article');\n/**\n * @internal\n */\nexport const Aside = DomNodeCreator<HTMLNodeProps<HTMLElement>>('aside');\n/**\n * @internal\n */\nexport const Span = DomNodeCreator<HTMLNodeProps<HTMLSpanElement>>('span');\n/**\n * @internal\n */\nexport const NoScript = DomNodeCreator<HTMLNodeProps<HTMLElement>>('noscript');\n\n/**\n * @internal\n */\nexport interface VideoProps extends HTMLNodeProps<HTMLVideoElement> {\n    controls?: AttributeValue;\n    autoplay?: AttributeValue;\n    loop?: AttributeValue;\n    muted?: AttributeValue;\n    preload?: AttributeValue;\n    src?: AttributeValue;\n    poster?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n    autopictureinpicture?: AttributeValue;\n    controlslist?: AttributeValue;\n    crossorigin?: AttributeValue;\n    disablepictureinpicture?: AttributeValue;\n    disableremoteplayback?: AttributeValue;\n    playsinline?: AttributeValue;\n\n    onCanPlay?: DataDrain<Event>;\n    onCanPlayThrough?: DataDrain<Event>;\n    onComplete?: DataDrain<Event>;\n    onDurationChange?: DataDrain<Event>;\n    onEmptied?: DataDrain<Event>;\n    onEnded?: DataDrain<Event>;\n    onLoadedData?: DataDrain<Event>;\n    onLoadedMetadata?: DataDrain<Event>;\n    onPause?: DataDrain<Event>;\n    onPlay?: DataDrain<Event>;\n    onPlaying?: DataDrain<Event>;\n    onProgress?: DataDrain<Event>;\n    onRateChange?: DataDrain<Event>;\n    onSeeked?: DataDrain<Event>;\n    onSeeking?: DataDrain<Event>;\n    onStalled?: DataDrain<Event>;\n    onSuspend?: DataDrain<Event>;\n    onTimeUpdate?: DataDrain<Event>;\n    onVolumeChange?: DataDrain<Event>;\n    onWaiting?: DataDrain<Event>;\n}\n/**\n * @internal\n */\nexport const Video = DomNodeCreator<VideoProps>(\n    'video',\n    [\n        'controls',\n        'autoplay',\n        'loop',\n        'muted',\n        'preload',\n        'src',\n        'poster',\n        'width',\n        'height',\n        'autopictureinpicture',\n        'controlslist',\n        'crossorigin',\n        'disablepictureinpicture',\n        'disableremoteplayback',\n        'playsinline'\n    ],\n    {\n        canPlay: 'onCanPlay',\n        canplaythrough: 'onCanPlayThrough',\n        complete: 'onComplete',\n        durationchange: 'onDurationChange',\n        emptied: 'onEmptied',\n        ended: 'onEnded',\n        loadeddata: 'onLoadedData',\n        loadedmetadata: 'onLoadedMetadata',\n        pause: 'onPause',\n        play: 'onPlay',\n        playing: 'onPlaying',\n        progress: 'onProgress',\n        ratechange: 'onRateChange',\n        seeked: 'onSeeked',\n        seeking: 'onSeeking',\n        stalled: 'onStalled',\n        suspend: 'onSuspend',\n        timeupdate: 'onTimeUpdate',\n        volumechange: 'onVolumeChange',\n        waiting: 'onWaiting'\n    }\n);\n/**\n * @internal\n */\nexport const Ul = DomNodeCreator<HTMLNodeProps<HTMLUListElement>>('ul');\n/**\n * @internal\n */\nexport const Ol = DomNodeCreator<HTMLNodeProps<HTMLOListElement>>('ol');\n/**\n * @internal\n */\nexport const Li = DomNodeCreator<HTMLNodeProps<HTMLLIElement>>('li');\n/**\n * @internal\n */\nexport const B = DomNodeCreator<HTMLNodeProps<HTMLElement>>('b');\n/**\n * @internal\n */\nexport const Body = DomNodeCreator<HTMLNodeProps<HTMLBodyElement>>('body');\n/**\n * @internal\n */\nexport const Title = DomNodeCreator<HTMLNodeProps<HTMLTitleElement>>('title');\n/**\n * @internal\n */\nexport const Summary = DomNodeCreator<HTMLNodeProps<HTMLElement>>('summary');\n/**\n * @internal\n */\nexport const THead = DomNodeCreator<HTMLNodeProps<HTMLElement>>('thead');\n/**\n * @internal\n */\nexport const Template = DomNodeCreator<HTMLNodeProps<HTMLTemplateElement>>('template');\n/**\n * @internal\n */\nexport const Q = DomNodeCreator<HTMLNodeProps<HTMLQuoteElement>>('q');\n/**\n * @internal\n */\nexport const Pre = DomNodeCreator<HTMLNodeProps<HTMLPreElement>>('pre');\n/**\n * @internal\n */\nexport const P = DomNodeCreator<HTMLNodeProps<HTMLParagraphElement>>('p');\n/**\n * @internal\n */\nexport const Hr = DomNodeCreator<HTMLNodeProps<HTMLHRElement>>('hr');\n\n/**\n * @internal\n */\nexport interface AudioProps extends HTMLNodeProps<HTMLAudioElement> {\n    controls?: AttributeValue;\n    autoplay?: AttributeValue;\n    loop?: AttributeValue;\n    muted?: AttributeValue;\n    preload?: AttributeValue;\n    src?: AttributeValue;\n    crossorigin?: AttributeValue;\n\n    onAudioProcess?: DataDrain<Event>;\n    onCanPlay?: DataDrain<Event>;\n    onCanPlayThrough?: DataDrain<Event>;\n    onComplete?: DataDrain<Event>;\n    onDurationChange?: DataDrain<Event>;\n    onEmptied?: DataDrain<Event>;\n    onEnded?: DataDrain<Event>;\n    onLoadedData?: DataDrain<Event>;\n    onLoadedMetadata?: DataDrain<Event>;\n    onPause?: DataDrain<Event>;\n    onPlay?: DataDrain<Event>;\n    onPlaying?: DataDrain<Event>;\n    onRateChange?: DataDrain<Event>;\n    onSeeked?: DataDrain<Event>;\n    onSeeking?: DataDrain<Event>;\n    onStalled?: DataDrain<Event>;\n    onSuspend?: DataDrain<Event>;\n    onTimeUpdate?: DataDrain<Event>;\n    onVolumeChange?: DataDrain<Event>;\n    onWaiting?: DataDrain<Event>;\n}\n\n/**\n * @internal\n */\nexport const Audio = DomNodeCreator<AudioProps>('audio', ['controls', 'autoplay', 'loop', 'muted', 'preload', 'src', 'crossorigin'], {\n    audioprocess: 'onAudioProcess',\n    canplay: 'onCanPlay',\n    canplaythrough: 'onCanPlayThrough',\n    complete: 'onComplete',\n    durationchange: 'onDurationChange',\n    emptied: 'onEmptied',\n    ended: 'onEnded',\n    loadeddata: 'onLoadedData',\n    loadedmetadata: 'onLoadedMetadata',\n    pause: 'onPause',\n    play: 'onPlay',\n    playing: 'onPlaying',\n    ratechange: 'onRateChange',\n    seeked: 'onSeeked',\n    seeking: 'onSeeking',\n    stalled: 'onStalled',\n    suspend: 'onSuspend',\n    timeupdate: 'onTimeUpdate',\n    volumechange: 'onVolumeChange',\n    waiting: 'onWaiting'\n});\n/**\n * @internal\n */\nexport const Br = DomNodeCreator<HTMLNodeProps<HTMLBRElement>>('br');\n\n/**\n * @internal\n */\nexport interface ButtonProps extends HTMLNodeProps<HTMLButtonElement> {\n    type?: AttributeValue;\n    disabled?: AttributeValue;\n    autofocus?: AttributeValue;\n    form?: AttributeValue;\n    formaction?: AttributeValue;\n    formenctype?: AttributeValue;\n    formmethod?: AttributeValue;\n    formnovalidate?: AttributeValue;\n    formtarget?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Button = DomNodeCreator<ButtonProps>('button', [\n    'disabled',\n    'autofocus',\n    'form',\n    'formaction',\n    'formenctype',\n    'formmethod',\n    'formnovalidate',\n    'formtarget',\n    'type'\n]);\n\n/**\n * @internal\n */\nexport interface CanvasProps extends HTMLNodeProps<HTMLCanvasElement> {\n    width?: AttributeValue;\n    height?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Canvas = DomNodeCreator<CanvasProps>('canvas', ['width', 'height']);\n\n/**\n * @internal\n */\nexport interface DataProps extends HTMLNodeProps<HTMLDataElement> {\n    value?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Data = DomNodeCreator<DataProps>('data', ['value']);\n/**\n * @internal\n */\nexport const Details = DomNodeCreator<HTMLNodeProps<HTMLDetailsElement>>('details');\n/**\n * @internal\n */\nexport const Em = DomNodeCreator<HTMLNodeProps<HTMLElement>>('em');\n/**\n * @internal\n */\nexport const Footer = DomNodeCreator<HTMLNodeProps<HTMLElement>>('footer');\n\n/**\n * @internal\n */\nexport interface FormProps extends HTMLNodeProps<HTMLFormElement> {\n    action?: AttributeValue;\n    method?: AttributeValue;\n    rel?: AttributeValue;\n    enctype?: AttributeValue;\n    novalidate?: AttributeValue;\n    target?: AttributeValue;\n    'accept-charset'?: AttributeValue;\n    autocomplete?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Form = DomNodeCreator<FormProps>('form', ['action', 'method', 'rel', 'enctype', 'novalidate', 'target', 'accept-charset', 'autocomplete']);\n\n/**\n * @internal\n */\nexport interface MetaProps extends HTMLNodeProps<HTMLMetaElement> {\n    ['http-equiv']?: AttributeValue;\n    ['charset']?: AttributeValue;\n    content?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Meta = DomNodeCreator<MetaProps>('meta', ['http-equiv', 'charset', 'content']);\n\n/**\n * @internal\n */\nexport interface HtmlProps extends HTMLNodeProps<HTMLHtmlElement> {\n    lang?: string;\n    xmlns?: string;\n}\n\n/**\n * @internal\n */\nexport const Html = DomNodeCreator<HtmlProps>('html', ['lang', 'xmlns']);\n/**\n * @internal\n */\nexport const Head = DomNodeCreator<HTMLNodeProps<HTMLHeadElement>>('head');\n/**\n * @internal\n */\nexport const Header = DomNodeCreator<HTMLNodeProps<HTMLElement>>('header');\n/**\n * @internal\n */\nexport const Heading = DomNodeCreator<HTMLNodeProps<HTMLHeadingElement>>('heading');\n/**\n * @internal\n */\nexport const I = DomNodeCreator<HTMLNodeProps<HTMLElement>>('i');\n\n/**\n * @internal\n */\nexport interface IFrameProps extends HTMLNodeProps<HTMLIFrameElement> {\n    src?: AttributeValue;\n    allow?: AttributeValue;\n    allowfullscreen?: AttributeValue;\n    allowpaymentrequest?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n    srcdoc?: AttributeValue;\n    loading?: AttributeValue;\n    sandbox?: AttributeValue;\n    frameborder?: AttributeValue;\n    csp?: AttributeValue;\n    referrerpolicy?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const IFrame = DomNodeCreator<IFrameProps>('iframe', [\n    'src',\n    'srcdoc',\n    'width',\n    'height',\n    'allow',\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'loading',\n    'sandbox',\n    'frameborder',\n    'csp',\n    'referrerpolicy'\n]);\n\n/**\n * @internal\n */\nexport interface ImgProps extends HTMLNodeProps<HTMLImageElement> {\n    src?: AttributeValue;\n    alt?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n    referrerpolicy?: AttributeValue;\n    sizes?: AttributeValue;\n    srcset?: AttributeValue;\n    usemap?: AttributeValue;\n    crossorigin?: AttributeValue;\n    decoding?: AttributeValue;\n    ismap?: AttributeValue;\n    loading?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Img = DomNodeCreator<ImgProps>('img', [\n    'src',\n    'alt',\n    'width',\n    'height',\n    'referrerpolicy',\n    'sizes',\n    'srcset',\n    'usemap',\n    'crossorigin',\n    'decoding',\n    'ismap',\n    'loading'\n]);\n\n/**\n * @internal\n */\nexport interface LabelProps extends HTMLNodeProps<HTMLLabelElement> {\n    for?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Label = DomNodeCreator<LabelProps>('label', ['for']);\n\n/**\n * @internal\n */\nexport interface LinkProps extends HTMLNodeProps<HTMLLinkElement> {\n    href?: AttributeValue;\n    rel?: AttributeValue;\n    media?: AttributeValue;\n    as?: AttributeValue;\n    disabled?: AttributeValue;\n    type?: AttributeValue;\n    crossorigin?: AttributeValue;\n    hreflang?: AttributeValue;\n    referrerpolicy?: AttributeValue;\n    sizes?: AttributeValue;\n    integrity?: AttributeValue;\n    imagesizes?: AttributeValue;\n    prefetch?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Link = DomNodeCreator<LinkProps>('link', [\n    'href',\n    'rel',\n    'media',\n    'as',\n    'disabled',\n    'type',\n    'crossorigin',\n    'hreflang',\n    'referrerpolicy',\n    'sizes',\n    'integrity',\n    'imagesizes',\n    'prefetch'\n]);\n/**\n * @internal\n */\nexport const Nav = DomNodeCreator<HTMLNodeProps<HTMLElement>>('nav');\n/**\n * @internal\n */\nexport const Sub = DomNodeCreator<HTMLNodeProps<HTMLElement>>('sub');\n/**\n * @internal\n */\nexport const Sup = DomNodeCreator<HTMLNodeProps<HTMLElement>>('sup');\n/**\n * @internal\n */\nexport const Table = DomNodeCreator<HTMLNodeProps<HTMLTableElement>>('table');\n/**\n * @internal\n */\nexport const TBody = DomNodeCreator<HTMLNodeProps<HTMLElement>>('tbody');\n/**\n * @internal\n */\nexport const TFoot = DomNodeCreator<HTMLNodeProps<HTMLElement>>('tfoot');\n\n/**\n * @internal\n */\nexport interface ColProps extends HTMLNodeProps<HTMLTableColElement> {\n    span?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Col = DomNodeCreator<ColProps>('col', ['span']);\n/**\n * @internal\n */\nexport const Colgroup = DomNodeCreator<HTMLNodeProps<HTMLTableColElement>>('colgroup', ['span']);\n/**\n * @internal\n */\nexport const Caption = DomNodeCreator<HTMLNodeProps<HTMLTableCaptionElement>>('caption');\n/**\n * @internal\n */\nexport const Tr = DomNodeCreator<HTMLNodeProps<HTMLTableRowElement>>('tr');\n\n/**\n * @internal\n */\nexport interface TableCellProps extends HTMLNodeProps<HTMLTableCellElement> {\n    colspan?: AttributeValue;\n    headers?: AttributeValue;\n    rowspan?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Td = DomNodeCreator<TableCellProps>('td', ['colspan', 'headers', 'rowspan']);\n/**\n * @internal\n */\nexport const Th = DomNodeCreator<HTMLNodeProps<HTMLTableHeaderCellElement>>('th', ['scope', 'abbr', 'colspan', 'headers', 'rowspan']);\n\n/**\n * @internal\n */\nexport interface TimeProps extends HTMLNodeProps<HTMLTimeElement> {\n    datetime?: AttributeValue;\n}\n/**\n * @internal\n */\nexport const Time = DomNodeCreator<TimeProps>('time', ['datetime']);\n\n/**\n * @internal\n */\nexport interface StyleProps extends HTMLNodeProps<HTMLStyleElement> {\n    media?: AttributeValue;\n    type?: AttributeValue;\n    nonce?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Style = DomNodeCreator<StyleProps>('style', ['media', 'type', 'nonce']);\n\n/**\n * @internal\n */\nexport interface SourceProps extends HTMLNodeProps<HTMLSourceElement> {\n    src?: AttributeValue;\n    srcset?: AttributeValue;\n    media?: AttributeValue;\n    sizes?: AttributeValue;\n    type?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Source = DomNodeCreator<SourceProps>('source', ['src', 'srcset', 'media', 'sizes', 'type']);\n\n/**\n * @internal\n */\nexport interface TrackProps extends HTMLNodeProps<HTMLTrackElement> {\n    src?: AttributeValue;\n    srclang?: AttributeValue;\n    label?: AttributeValue;\n    kind?: AttributeValue;\n    default?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Track = DomNodeCreator<TrackProps>('track', ['src', 'srclang', 'label', 'kind', 'default']);\n\n/**\n * @internal\n */\nexport interface ParamProps extends HTMLNodeProps<HTMLParamElement> {\n    value?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Param = DomNodeCreator<ParamProps>('param', ['value']);\n\n/**\n * @internal\n */\nexport interface ScriptProps extends HTMLNodeProps<HTMLScriptElement> {\n    src?: AttributeValue;\n    async?: AttributeValue;\n    defer?: AttributeValue;\n    integrity?: AttributeValue;\n    nomodule?: AttributeValue;\n    crossorigin?: AttributeValue;\n    type?: AttributeValue;\n    referrerpolicy?: AttributeValue;\n    text?: AttributeValue;\n    nonce?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Script = DomNodeCreator<ScriptProps>('script', [\n    'src',\n    'async',\n    'defer',\n    'integrity',\n    'nomodule',\n    'type',\n    'crossorigin',\n    'referrerpolicy',\n    'text',\n    'nonce'\n]);\n\nconst commonSvgProps = [\n    'clip-path',\n    'clip-rule',\n    'color',\n    'color-interpolation',\n    'color-rendering',\n    'cursor',\n    'display',\n    'fill',\n    'fill-opacity',\n    'fill-rule',\n    'filter',\n    'mask',\n    'opacity',\n    'pointer-events',\n    'shape-rendering',\n    'stroke',\n    'stroke-dasharray',\n    'stroke-dashoffset',\n    'stroke-linecap',\n    'stroke-linejoin',\n    'stroke-miterlimit',\n    'stroke-opacity',\n    'stroke-width',\n    'transform',\n    'vector-effect',\n    'visibility'\n];\n\nexport interface SVGNodeProps extends HTMLNodeProps<SVGSVGElement> {\n    'clip-path'?: AttributeValue;\n    'clip-rule'?: AttributeValue;\n    color?: AttributeValue;\n    'color-interpolation'?: AttributeValue;\n    'color-rendering'?: AttributeValue;\n    cursor?: AttributeValue;\n    display?: AttributeValue;\n    fill?: AttributeValue;\n    'fill-opacity'?: AttributeValue;\n    'fill-rule'?: AttributeValue;\n    filter?: AttributeValue;\n    mask?: AttributeValue;\n    opacity?: AttributeValue;\n    'pointer-events'?: AttributeValue;\n    'shape-rendering'?: AttributeValue;\n    stroke?: AttributeValue;\n    'stroke-dasharray'?: AttributeValue;\n    'stroke-dashoffset'?: AttributeValue;\n    'stroke-linecap'?: AttributeValue;\n    'stroke-linejoin'?: AttributeValue;\n    'stroke-miterlimit'?: AttributeValue;\n    'stroke-opacity'?: AttributeValue;\n    'stroke-width'?: AttributeValue;\n    transform?: AttributeValue;\n    'vector-effect'?: AttributeValue;\n    visibility?: AttributeValue;\n}\n/**\n * @internal\n */\nexport interface SvgProps extends SVGNodeProps {\n    width?: AttributeValue;\n    height?: AttributeValue;\n    xmlns?: AttributeValue;\n    version?: AttributeValue;\n    x?: AttributeValue;\n    y?: AttributeValue;\n    x1?: AttributeValue;\n    y1?: AttributeValue;\n    x2?: AttributeValue;\n    y2?: AttributeValue;\n    cx?: AttributeValue;\n    cy?: AttributeValue;\n    r?: AttributeValue;\n    rx?: AttributeValue;\n    ry?: AttributeValue;\n    d?: AttributeValue;\n    path?: AttributeValue;\n    points?: AttributeValue;\n    viewBox?: AttributeValue;\n    preserveAspectRatio?: AttributeValue;\n    'xmlns:xlink'?: AttributeValue;\n    'xml:space'?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Svg = DomNodeCreator<SvgProps>(\n    'svg',\n    [\n        'width',\n        'height',\n        'xmlns',\n        'version',\n        'x',\n        'y',\n        'x1',\n        'y1',\n        'x2',\n        'y2',\n        'cx',\n        'cy',\n        'r',\n        'rx',\n        'ry',\n        'd',\n        'path',\n        'points',\n        'viewBox',\n        'preserveAspectRatio',\n        'xmlns:xlink',\n        'xml:space',\n        ...commonSvgProps\n    ],\n    undefined,\n    undefined,\n    true\n);\n\nexport interface CircleProps extends SVGNodeProps {\n    cx?: AttributeValue;\n    cy?: AttributeValue;\n    r?: AttributeValue;\n}\n\nexport const Circle = DomNodeCreator<CircleProps>('circle', ['cx', 'cy', 'r', ...commonSvgProps], undefined, undefined, true);\n\nexport interface EllipseProps extends SVGNodeProps {\n    cx?: AttributeValue;\n    cy?: AttributeValue;\n    rx?: AttributeValue;\n    ry?: AttributeValue;\n}\n\nexport const Ellipse = DomNodeCreator<EllipseProps>('ellipse', ['cx', 'cy', 'rx', 'ry', ...commonSvgProps], undefined, undefined, true);\n\nexport interface LineProps extends SVGNodeProps {\n    x1?: AttributeValue;\n    y1?: AttributeValue;\n    x2?: AttributeValue;\n    y2?: AttributeValue;\n}\n\nexport const Line = DomNodeCreator<LineProps>('line', ['x1', 'y1', 'x2', 'y2', ...commonSvgProps], undefined, undefined, true);\n\nexport interface PolygonProps extends SVGNodeProps {\n    points?: AttributeValue;\n}\n\nexport const Polygon = DomNodeCreator<PolygonProps>('polygon', ['points', ...commonSvgProps], undefined, undefined, true);\n\nexport interface PolylineProps extends SVGNodeProps {\n    points?: AttributeValue;\n}\n\nexport const Polyline = DomNodeCreator<PolylineProps>('polyline', ['points', ...commonSvgProps], undefined, undefined, true);\n\nexport interface PathProps extends SVGNodeProps {\n    d?: AttributeValue;\n}\n\nexport const Path = DomNodeCreator<PathProps>('path', ['d', ...commonSvgProps], undefined, undefined, true);\n\nexport interface RectProps extends SVGNodeProps {\n    x?: AttributeValue;\n    y?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n}\n\nexport const Rect = DomNodeCreator<RectProps>('rect', ['x', 'y', 'width', 'height', ...commonSvgProps], undefined, undefined, true);\n\nexport interface TextProps extends SVGNodeProps {\n    dx?: AttributeValue;\n    dy?: AttributeValue;\n    rotate?: AttributeValue;\n    textLength?: AttributeValue;\n    x?: AttributeValue;\n    y?: AttributeValue;\n}\n\nexport const Text = DomNodeCreator<TextProps>('text', ['dx', 'dy', 'rotate', 'textLength', 'x', 'y', ...commonSvgProps], undefined, undefined, true);\n\nexport const Tspan = DomNodeCreator<TextProps>('tspan', ['dx', 'dy', 'rotate', 'textLength', 'x', 'y', ...commonSvgProps], undefined, undefined, true);\n\nexport interface ImageProps extends SVGNodeProps {\n    x?: AttributeValue;\n    y?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n    href?: AttributeValue;\n}\n\nexport const Image = DomNodeCreator<ImageProps>('image', ['x', 'y', 'width', 'height', 'href', ...commonSvgProps], undefined, undefined, true);\n\nexport interface GProps extends SVGNodeProps {}\n\nexport const G = DomNodeCreator<GProps>('g', [...commonSvgProps], undefined, undefined, true);\n\nexport interface DefsProps extends SVGNodeProps {}\n\nexport const Defs = DomNodeCreator<DefsProps>('defs', [...commonSvgProps], undefined, undefined, true);\n\nexport interface SymbolProps extends SVGNodeProps {\n    viewBox?: AttributeValue;\n    preserveAspectRatio?: AttributeValue;\n}\n\nexport const Symbol = DomNodeCreator<SymbolProps>('symbol', ['viewBox', 'preserveAspectRatio', ...commonSvgProps], undefined, undefined, true);\n\nexport interface UseProps extends SVGNodeProps {\n    href?: AttributeValue;\n    x?: AttributeValue;\n    y?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n}\n\nexport const Use = DomNodeCreator<UseProps>('use', ['href', 'x', 'y', 'width', 'height', ...commonSvgProps], undefined, undefined, true);\n\nexport interface MarkerProps extends SVGNodeProps {\n    viewBox?: AttributeValue;\n    preserveAspectRatio?: AttributeValue;\n    refX?: AttributeValue;\n    refY?: AttributeValue;\n    markerWidth?: AttributeValue;\n    markerHeight?: AttributeValue;\n    orient?: AttributeValue;\n}\n\nexport const Marker = DomNodeCreator<MarkerProps>(\n    'marker',\n    ['viewBox', 'preserveAspectRatio', 'refX', 'refY', 'markerWidth', 'markerHeight', 'orient', ...commonSvgProps],\n    undefined,\n    undefined,\n    true\n);\n\nexport interface MaskProps extends SVGNodeProps {\n    x?: AttributeValue;\n    y?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n}\n\nexport const Mask = DomNodeCreator<MaskProps>('mask', ['x', 'y', 'width', 'height', ...commonSvgProps], undefined, undefined, true);\n\nexport interface LinearGradientProps extends SVGNodeProps {\n    x1?: AttributeValue;\n    y1?: AttributeValue;\n    x2?: AttributeValue;\n    y2?: AttributeValue;\n}\n\nexport const LinearGradient = DomNodeCreator<LinearGradientProps>('linearGradient', ['x1', 'y1', 'x2', 'y2', ...commonSvgProps], undefined, undefined, true);\n\nexport interface RadialGradientProps extends SVGNodeProps {\n    cx?: AttributeValue;\n    cy?: AttributeValue;\n    r?: AttributeValue;\n    fx?: AttributeValue;\n    fy?: AttributeValue;\n    fr?: AttributeValue;\n}\n\nexport const RadialGradient = DomNodeCreator<RadialGradientProps>(\n    'radialGradient',\n    ['cx', 'cy', 'r', 'fx', 'fy', 'fr', ...commonSvgProps],\n    undefined,\n    undefined,\n    true\n);\n\nexport interface StopProps extends SVGNodeProps {\n    offset?: AttributeValue;\n    'stop-color'?: AttributeValue;\n    'stop-opacity'?: AttributeValue;\n}\n\nexport const Stop = DomNodeCreator<StopProps>('stop', ['offset', 'stop-color', 'stop-opacity', ...commonSvgProps], undefined, undefined, true);\n\nexport interface ClipPathProps extends SVGNodeProps {\n    clipPathUnits?: AttributeValue;\n}\n\nexport const ClipPath = DomNodeCreator<ClipPathProps>('clipPath', ['clipPathUnits', ...commonSvgProps], undefined, undefined, true);\n\nexport interface ForeignObjectProps extends SVGNodeProps {\n    x?: AttributeValue;\n    y?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n}\n\nexport const ForeignObject = DomNodeCreator<ForeignObjectProps>('foreignObject', ['x', 'y', 'width', 'height', ...commonSvgProps], undefined, undefined, true);\n\nexport interface PatternProps extends SVGNodeProps {\n    x?: AttributeValue;\n    y?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n    patternUnits?: AttributeValue;\n    patternContentUnits?: AttributeValue;\n    patternTransform?: AttributeValue;\n    viewBox?: AttributeValue;\n    preserveAspectRatio?: AttributeValue;\n}\n\nexport const Pattern = DomNodeCreator<PatternProps>(\n    'pattern',\n    ['x', 'y', 'width', 'height', 'patternUnits', 'patternContentUnits', 'patternTransform', 'viewBox', 'preserveAspectRatio', ...commonSvgProps],\n    undefined,\n    undefined,\n    true\n);\n\n/**\n * @internal\n */\nexport interface ProgressProps extends HTMLNodeProps<HTMLProgressElement> {\n    max?: AttributeValue;\n    value?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Progress = DomNodeCreator<ProgressProps>('progress', ['max', 'value']);\n\n/**\n * @internal\n */\nexport interface OptionProps extends HTMLNodeProps<HTMLElement> {\n    value?: AttributeValue;\n    disabled?: AttributeValue;\n    label?: AttributeValue;\n    selected?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Option = DomNodeCreator<OptionProps>('option', ['value', 'label', 'disabled', 'selected']);\n\n/**\n * @internal\n */\nexport interface OptGroupProps extends HTMLNodeProps<HTMLOptGroupElement> {\n    disabled?: AttributeValue;\n    label?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const OptGroup = DomNodeCreator<OptGroupProps>('optgroup', ['label', 'disabled']);\n\n/**\n * @internal\n */\nexport interface SlotProps extends HTMLNodeProps<HTMLSlotElement> {}\n\n/**\n * @internal\n */\nexport const Slot = DomNodeCreator<SlotProps>('slot');\n\n/**\n * @internal\n */\nexport const Strong = DomNodeCreator<HTMLNodeProps<HTMLElement>>('strong');\n/**\n * @internal\n */\nexport const Samp = DomNodeCreator<HTMLNodeProps<HTMLElement>>('samp');\n/**\n * @internal\n */\nexport const Kbd = DomNodeCreator<HTMLNodeProps<HTMLElement>>('kbd');\n/**\n * @internal\n */\nexport const Var = DomNodeCreator<HTMLNodeProps<HTMLElement>>('var');\n/**\n * @internal\n */\nexport const Wbr = DomNodeCreator<HTMLNodeProps<HTMLElement>>('wbr');\n/**\n * @internal\n */\nexport const Picture = DomNodeCreator<HTMLNodeProps<HTMLElement>>('picture');\n\n/**\n * @internal\n */\nexport interface OutputProps extends HTMLNodeProps<HTMLOutputElement> {\n    form?: AttributeValue;\n    for?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Output = DomNodeCreator<OutputProps>('output', ['for', 'form']);\n\n/**\n * @internal\n */\nexport interface ObjectProps extends HTMLNodeProps<HTMLObjectElement> {\n    data?: AttributeValue;\n    width?: AttributeValue;\n    height?: AttributeValue;\n    form?: AttributeValue;\n    type?: AttributeValue;\n    usemap?: AttributeValue;\n}\n\n/**\n * @internal\n */\nexport const Object = DomNodeCreator<ObjectProps>('object', ['data', 'width', 'height', 'form', 'type', 'usemap']);\n", "import { GenericDataSource, DataSource } from '../stream/data_source.js';\nimport { AttributeValue, DataDrain } from '../utilities/common.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { HTMLNodeProps, DomNodeCreator } from '../rendering/renderers/dom_adapter.js';\n\nexport interface TextAreaProps extends HTMLNodeProps<HTMLTextAreaElement> {\n    placeholder?: AttributeValue;\n    readonly?: AttributeValue;\n    disabled?: AttributeValue;\n    onChange?: DataDrain<InputEvent>;\n    onInput?: DataDrain<InputEvent>;\n    value?: GenericDataSource<string> | string;\n    cols?: AttributeValue;\n    rows?: AttributeValue;\n    wrap?: AttributeValue;\n    form?: AttributeValue;\n    autocomplete?: AttributeValue;\n    autofocus?: AttributeValue;\n    max?: AttributeValue;\n    maxLength?: AttributeValue;\n    min?: AttributeValue;\n    minLength?: AttributeValue;\n    spellcheck?: AttributeValue;\n    required?: AttributeValue;\n    type?: AttributeValue;\n}\n\n/**\n * @internal\n */\nconst textAreaEvents = { input: 'onInput', change: 'onChange' };\n\n/**\n * @internal\n */\nconst textAreaProps = [\n    'placeholder',\n    'readonly',\n    'disabled',\n    'form',\n    'cols',\n    'rows',\n    'wrap',\n    'autocomplete',\n    'autofocus',\n    'max',\n    'maxLength',\n    'min',\n    'spellcheck',\n    'minLength',\n    'required',\n    'type'\n];\n\n/**\n * @internal\n */\nexport const TextArea = DomNodeCreator<TextAreaProps>(\n    'textArea',\n    textAreaProps,\n    textAreaEvents,\n    (node: HTMLElement, props: TextAreaProps, cleanUp: CancellationToken) => {\n        const textArea = node as HTMLTextAreaElement;\n        if (props.value) {\n            if (props.value instanceof DataSource) {\n                props.value.listenAndRepeat((v) => {\n                    textArea.value = v;\n                }, cleanUp);\n                textArea.addEventListener('input', () => {\n                    (props.value as DataSource<string>).update(textArea.value);\n                });\n            } else if (props.value instanceof DuplexDataSource) {\n                props.value.listenAndRepeat((v) => {\n                    textArea.value = v;\n                }, cleanUp);\n                textArea.addEventListener('input', () => {\n                    (props.value as DuplexDataSource<string>).updateUpstream(textArea.value);\n                });\n            } else {\n                textArea.value = props.value as string;\n            }\n        }\n    }\n);\n", "import { HTMLNodeProps } from '../rendering/renderers/dom_adapter.js';\nimport { Input, InputProps } from '../nodes/input.js';\nimport { Select, SelectProps } from '../nodes/select.js';\nimport {\n    A,\n    Abbr,\n    Address,\n    AProps,\n    Area,\n    AreaProps,\n    Article,\n    Aside,\n    Audio,\n    AudioProps,\n    B,\n    Body,\n    Br,\n    Button,\n    ButtonProps,\n    Canvas,\n    CanvasProps,\n    Caption,\n    Code,\n    Col,\n    Colgroup,\n    ColProps,\n    Data,\n    DataProps,\n    Defs,\n    Details,\n    Div,\n    Em,\n    Footer,\n    Form,\n    FormProps,\n    G,\n    H1,\n    H2,\n    H3,\n    H4,\n    H5,\n    H6,\n    Head,\n    Header,\n    Heading,\n    Hr,\n    Html,\n    HtmlProps,\n    I,\n    IFrame,\n    IFrameProps,\n    Img,\n    ImgProps,\n    Kbd,\n    Label,\n    LabelProps,\n    Li,\n    Line,\n    Link,\n    LinkProps,\n    Meta,\n    MetaProps,\n    Nav,\n    NoScript,\n    Object,\n    ObjectProps,\n    Ol,\n    OptGroup,\n    OptGroupProps,\n    Option,\n    OptionProps,\n    Output,\n    OutputProps,\n    P,\n    Param,\n    ParamProps,\n    Picture,\n    Pre,\n    Progress,\n    ProgressProps,\n    Q,\n    Rect,\n    Samp,\n    Script,\n    ScriptProps,\n    Slot,\n    SlotProps,\n    Source,\n    SourceProps,\n    Span,\n    Strong,\n    Style,\n    StyleProps,\n    Sub,\n    Summary,\n    Sup,\n    Svg,\n    SvgProps,\n    Table,\n    TableCellProps,\n    TBody,\n    Td,\n    Template,\n    TFoot,\n    Th,\n    THead,\n    Time,\n    TimeProps,\n    Title,\n    Tr,\n    Track,\n    TrackProps,\n    Ul,\n    Var,\n    Video,\n    VideoProps,\n    Wbr,\n    Text,\n    Tspan,\n    Circle,\n    Ellipse,\n    Polygon,\n    Polyline,\n    Path,\n    Image,\n    Symbol,\n    CircleProps,\n    EllipseProps,\n    ImageProps,\n    LineProps,\n    PathProps,\n    PolygonProps,\n    PolylineProps,\n    RectProps,\n    SymbolProps,\n    UseProps,\n    LinearGradientProps,\n    RadialGradientProps,\n    StopProps,\n    MaskProps,\n    Mask,\n    Use,\n    Stop,\n    LinearGradient,\n    RadialGradient,\n    Marker,\n    ClipPath,\n    ForeignObject,\n    Pattern,\n    ClipPathProps,\n    PatternProps,\n    ForeignObjectProps,\n    MarkerProps\n} from '../nodes/simple_dom_nodes.js';\nimport { TextArea, TextAreaProps } from '../nodes/textarea.js';\nimport {\n    ArrayAurumElement,\n    AurumComponentAPI,\n    AurumElement,\n    AurumElementModel,\n    aurumElementModelIdentitiy,\n    createAPI,\n    createRenderSession,\n    renderInternal,\n    Renderable\n} from '../rendering/aurum_element.js';\nimport { ArrayDataSource, ReadOnlyArrayDataSource, ReadOnlyDataSource } from '../stream/data_source.js';\nimport { CancellationToken } from './cancellation_token.js';\nimport { MapLike } from './common.js';\n\nexport type AurumDecorator = (model: AurumElementModel<any>) => Renderable;\n\nconst nodeMap = {\n    address: Address,\n    kbd: Kbd,\n    samp: Samp,\n    object: Object,\n    optgroup: OptGroup,\n    picture: Picture,\n    output: Output,\n    param: Param,\n    strong: Strong,\n    track: Track,\n    var: Var,\n    wbr: Wbr,\n    button: Button,\n    code: Code,\n    hr: Hr,\n    div: Div,\n    input: Input,\n    li: Li,\n    span: Span,\n    style: Style,\n    ul: Ul,\n    p: P,\n    img: Img,\n    link: Link,\n    canvas: Canvas,\n    a: A,\n    article: Article,\n    br: Br,\n    form: Form,\n    label: Label,\n    ol: Ol,\n    pre: Pre,\n    progress: Progress,\n    table: Table,\n    td: Td,\n    tr: Tr,\n    th: Th,\n    textarea: TextArea,\n    h1: H1,\n    h2: H2,\n    h3: H3,\n    h4: H4,\n    h5: H5,\n    h6: H6,\n    html: Html,\n    head: Head,\n    header: Header,\n    footer: Footer,\n    nav: Nav,\n    b: B,\n    i: I,\n    script: Script,\n    abbr: Abbr,\n    area: Area,\n    aside: Aside,\n    audio: Audio,\n    em: Em,\n    heading: Heading,\n    iframe: IFrame,\n    noscript: NoScript,\n    option: Option,\n    q: Q,\n    select: Select,\n    source: Source,\n    title: Title,\n    video: Video,\n    tbody: TBody,\n    tfoot: TFoot,\n    meta: Meta,\n    body: Body,\n    thead: THead,\n    summary: Summary,\n    details: Details,\n    sub: Sub,\n    sup: Sup,\n    svg: Svg,\n    data: Data,\n    time: Time,\n    template: Template,\n    slot: Slot,\n    col: Col,\n    colgroup: Colgroup,\n    caption: Caption,\n    line: Line,\n    rect: Rect,\n    defs: Defs,\n    g: G,\n    text: Text,\n    tspan: Tspan,\n    circle: Circle,\n    ellipse: Ellipse,\n    polygon: Polygon,\n    polyline: Polyline,\n    path: Path,\n    image: Image,\n    symbol: Symbol,\n    use: Use,\n    stop: Stop,\n    lineargradient: LinearGradient,\n    radialgradient: RadialGradient,\n    clippath: ClipPath,\n    pattern: Pattern,\n    mask: Mask,\n    foreignobject: ForeignObject,\n    marker: Marker\n};\n\nexport class Aurum {\n    public static rehydrate(aurumRenderable: Renderable, dom: HTMLElement): CancellationToken {\n        const target = dom.parentElement;\n        dom.remove();\n        return Aurum.attach(aurumRenderable, target);\n    }\n\n    public static attach(aurumRenderable: Renderable, dom: HTMLElement): CancellationToken {\n        const session = createRenderSession();\n        const content = renderInternal(aurumRenderable, session);\n        if (content instanceof AurumElement) {\n            content.attachToDom(dom, dom.childNodes.length);\n            session.sessionToken.addCancellable(() => content.dispose());\n        } else if (Array.isArray(content)) {\n            const root = new ArrayAurumElement(new ArrayDataSource(content), createAPI(session));\n            session.sessionToken.addCancellable(() => root.dispose());\n            root.attachToDom(dom, dom.childNodes.length);\n        } else {\n            dom.appendChild(content);\n            session.sessionToken.addCancellable(() => {\n                if (content.isConnected) {\n                    dom.removeChild(content);\n                }\n            });\n        }\n        for (let i = session.attachCalls.length - 1; i >= 0; i--) {\n            session.attachCalls[i]();\n        }\n\n        return session.sessionToken;\n    }\n\n    /**\n     * Fragment works through factory by checking if the node is equal to this function\n     */\n    public static fragment() {}\n\n    public static factory(\n        node: string | ((props: any, children: Renderable[], api: AurumComponentAPI) => Renderable),\n        args: MapLike<any>,\n        ...innerNodes: Array<AurumElementModel<any> | ReadOnlyDataSource<any> | ReadOnlyArrayDataSource<any>>\n    ): AurumElementModel<any> {\n        //@ts-ignore\n        if (node === Aurum.fragment) {\n            return innerNodes as any;\n        }\n\n        let name;\n        let intrinsic = false;\n        if (typeof node === 'string') {\n            intrinsic = true;\n            name = node;\n            const type = node;\n            node = nodeMap[node];\n            if (node === undefined) {\n                throw new Error(`Node ${type} does not exist or is not supported`);\n            }\n        } else {\n            name = node.name;\n        }\n\n        let model = {\n            [aurumElementModelIdentitiy]: true,\n            name,\n            isIntrinsic: intrinsic,\n            factory: node as (props: any, children: Renderable[], api: AurumComponentAPI) => Renderable,\n            props: args,\n            children: innerNodes\n        };\n\n        if (args != undefined && args.decorate != undefined) {\n            if (Array.isArray(args.decorate)) {\n                for (const decorate of args.decorate) {\n                    model = decorate(model);\n                }\n            } else if (typeof args.decorate === 'function') {\n                model = args.decorate(model);\n            } else {\n                throw new Error('Decorate must be a function or an array of functions');\n            }\n        }\n\n        return model;\n    }\n}\n\nexport namespace Aurum {\n    export namespace JSX {\n        export interface IntrinsicAttributes {\n            decorate?: AurumDecorator | AurumDecorator[];\n        }\n        export interface IntrinsicElements {\n            address: HTMLNodeProps<HTMLElement>;\n            wbr: HTMLNodeProps<HTMLElement>;\n            samp: HTMLNodeProps<HTMLElement>;\n            strong: HTMLNodeProps<HTMLElement>;\n            kbd: HTMLNodeProps<HTMLElement>;\n            var: HTMLNodeProps<HTMLElement>;\n            picture: HTMLNodeProps<HTMLElement>;\n            output: OutputProps;\n            object: ObjectProps;\n            optgroup: OptGroupProps;\n            track: TrackProps;\n            param: ParamProps;\n            code: HTMLNodeProps<HTMLElement>;\n            button: ButtonProps;\n            hr: HTMLNodeProps<HTMLHRElement>;\n            div: HTMLNodeProps<HTMLDivElement>;\n            input: InputProps;\n            meta: MetaProps;\n            li: HTMLNodeProps<HTMLLIElement>;\n            span: HTMLNodeProps<HTMLElement>;\n            style: StyleProps;\n            ul: HTMLNodeProps<HTMLUListElement>;\n            p: HTMLNodeProps<HTMLParagraphElement>;\n            img: ImgProps;\n            link: LinkProps;\n            canvas: CanvasProps;\n            a: AProps;\n            article: HTMLNodeProps<HTMLElement>;\n            br: HTMLNodeProps<HTMLBRElement>;\n            form: FormProps;\n            label: LabelProps;\n            ol: HTMLNodeProps<HTMLOListElement>;\n            pre: HTMLNodeProps<HTMLPreElement>;\n            progress: ProgressProps;\n            table: HTMLNodeProps<HTMLTableElement>;\n            td: TableCellProps;\n            tr: HTMLNodeProps<HTMLTableRowElement>;\n            th: TableCellProps;\n            textarea: TextAreaProps;\n            h1: HTMLNodeProps<HTMLElement>;\n            h2: HTMLNodeProps<HTMLElement>;\n            h3: HTMLNodeProps<HTMLElement>;\n            h4: HTMLNodeProps<HTMLElement>;\n            h5: HTMLNodeProps<HTMLElement>;\n            h6: HTMLNodeProps<HTMLElement>;\n            header: HTMLNodeProps<HTMLElement>;\n            footer: HTMLNodeProps<HTMLElement>;\n            nav: HTMLNodeProps<HTMLElement>;\n            b: HTMLNodeProps<HTMLElement>;\n            i: HTMLNodeProps<HTMLElement>;\n            script: ScriptProps;\n            abbr: HTMLNodeProps<HTMLElement>;\n            area: AreaProps;\n            slot: SlotProps;\n            aside: HTMLNodeProps<HTMLElement>;\n            audio: AudioProps;\n            em: HTMLNodeProps<HTMLElement>;\n            heading: HTMLNodeProps<HTMLHeadingElement>;\n            iframe: IFrameProps;\n            noscript: HTMLNodeProps<HTMLElement>;\n            option: OptionProps;\n            q: HTMLNodeProps<HTMLQuoteElement>;\n            select: SelectProps;\n            source: SourceProps;\n            title: HTMLNodeProps<HTMLTitleElement>;\n            video: VideoProps;\n            tbody: HTMLNodeProps<HTMLElement>;\n            tfoot: HTMLNodeProps<HTMLElement>;\n            thead: HTMLNodeProps<HTMLElement>;\n            summary: HTMLNodeProps<HTMLElement>;\n            details: HTMLNodeProps<HTMLDetailsElement>;\n            sub: HTMLNodeProps<HTMLElement>;\n            sup: HTMLNodeProps<HTMLElement>;\n            svg: SvgProps;\n            data: DataProps;\n            time: TimeProps;\n            body: HTMLNodeProps<HTMLBodyElement>;\n            head: HTMLNodeProps<HTMLHeadElement>;\n            html: HtmlProps;\n            template: HTMLNodeProps<HTMLTemplateElement>;\n            col: ColProps;\n            colgroup: ColProps;\n            caption: HTMLNodeProps<HTMLTableCaptionElement>;\n            line: LineProps;\n            rect: RectProps;\n            defs: HTMLNodeProps<SVGDefsElement>;\n            g: HTMLNodeProps<SVGGElement>;\n            text: HTMLNodeProps<SVGTextElement>;\n            tspan: HTMLNodeProps<SVGTSpanElement>;\n            circle: CircleProps;\n            ellipse: EllipseProps;\n            polygon: PolygonProps;\n            polyline: PolylineProps;\n            path: PathProps;\n            image: ImageProps;\n            symbol: SymbolProps;\n            use: UseProps;\n            stop: StopProps;\n            linearGradient: LinearGradientProps;\n            radialGradient: RadialGradientProps;\n            clipPath: ClipPathProps;\n            pattern: PatternProps;\n            mask: MaskProps;\n            foreignObject: ForeignObjectProps;\n            marker: MarkerProps;\n        }\n    }\n}\n", "import { Aurum } from '../utilities/aurum.js';\nimport { AurumComponentAPI, createAPI, createRenderSession, Renderable, RenderSession } from './aurum_element.js';\nimport { DataSource } from '../stream/data_source.js';\nimport { DomNodeCreator } from './renderers/dom_adapter.js';\nimport { Constructor } from '../utilities/common.js';\n\ninterface WebComponentProps<Props> {\n    /**\n     * Name of the webcomponent, must be lower case kebab case and must have at least one hyphen as required by the spec\n     * example: au-mycomponent\n     */\n    name: string;\n    /**\n     * List of attributes of the web component that will be transformed into a data source that reflects the exact state of the attribute in the DOM no matter what changes the attirbute\n     */\n    observedAttributes?: (keyof Props)[];\n    shadowRootMode?: 'open' | 'closed';\n    shadowRootDelegatesFocus?: boolean;\n    /**\n     * Base class of the web component, defaults to HTMLElement\n     */\n    baseClass?: Constructor<HTMLElement>;\n}\n\n/**\n * Wrapper around native web components allows using aurum style component structure to create native components.\n */\nexport function Webcomponent<T>(\n    config: WebComponentProps<T>,\n    logic: (props: T, api: AurumComponentAPI) => Renderable\n): (props: T, children: Renderable[], api: AurumComponentAPI) => Renderable {\n    customElements.define(\n        config.name,\n        class extends (config.baseClass ?? HTMLElement) {\n            private api: AurumComponentAPI;\n            private session: RenderSession;\n            private props: any;\n\n            constructor() {\n                super();\n                if (config.observedAttributes === undefined) {\n                    config.observedAttributes = [];\n                }\n                this.props = {};\n                for (const attr of config.observedAttributes) {\n                    this.props[attr] = new DataSource();\n                }\n            }\n\n            static get observedAttributes() {\n                return config.observedAttributes;\n            }\n\n            public attributeChangedCallback(name, oldValue, newValue): void {\n                if (oldValue !== newValue) {\n                    this.props[name].update(newValue);\n                }\n            }\n\n            public connectedCallback(): void {\n                const template = document.createDocumentFragment();\n                this.session = createRenderSession();\n                this.api = createAPI(this.session);\n                const content = logic(this.props, this.api);\n\n                for (const cb of this.session.attachCalls) {\n                    cb();\n                }\n\n                Aurum.attach(content, template as any);\n\n                this.attachShadow({\n                    mode: config.shadowRootMode ?? 'open',\n                    delegatesFocus: config.shadowRootDelegatesFocus\n                }).appendChild(template);\n            }\n\n            public disconnectedCallback(): void {\n                this.session.sessionToken.cancel();\n            }\n        }\n    );\n\n    return DomNodeCreator(config.name, config.observedAttributes as string[], undefined, (node, props) => {\n        for (const key in props) {\n            //@ts-ignore\n            if (!(key in node.props)) {\n                //@ts-ignore\n                node.props[key] = props[key];\n            }\n        }\n    });\n}\n", "import { AurumElementModel, createAPI, Renderable } from '../aurum_element.js';\nimport { ArrayDataSource, DataSource } from '../../stream/data_source.js';\nimport { DuplexDataSource } from '../../stream/duplex_data_source.js';\nimport { CancellationToken } from '../../utilities/cancellation_token.js';\n\nexport interface AurumStringAdapterConfig {\n    attributeBlacklist?: string[];\n    attributeWhitelist?: string[];\n    tagBlacklist?: string[];\n    tagWhitelist?: string[];\n}\n\nexport async function aurumToString(content: Renderable | Renderable[], config: AurumStringAdapterConfig = {}): Promise<string> {\n    if (content === undefined || content === null) {\n        return '';\n    }\n\n    if (Array.isArray(content)) {\n        const result = [];\n        for (const item of content) {\n            result.push(await aurumToString(item));\n        }\n        return result.join('');\n    }\n\n    if (content instanceof Promise) {\n        return aurumToString(await content);\n    }\n\n    if (['number', 'string', 'bigint', 'boolean'].includes(typeof content)) {\n        return content.toString();\n    } else if (content instanceof DataSource) {\n        return aurumToString(content.value);\n    } else if (content instanceof DuplexDataSource) {\n        return aurumToString(content.value);\n    } else if (content instanceof ArrayDataSource) {\n        return aurumToString(content.getData() as any);\n    } else {\n        const item = content as AurumElementModel<any>;\n        if (!item.isIntrinsic) {\n            return aurumToString(\n                item.factory(\n                    item.props,\n                    item.children,\n                    createAPI({\n                        attachCalls: [],\n                        sessionToken: new CancellationToken(),\n                        tokens: []\n                    })\n                )\n            );\n        }\n\n        if (config.tagBlacklist && config.tagBlacklist.includes(item.name)) {\n            return '';\n        }\n\n        if (config.tagWhitelist && !config.tagWhitelist.includes(item.name)) {\n            return '';\n        }\n\n        let propString: string = ' ';\n        let children: string = '';\n        if (item.children) {\n            children = await aurumToString(item.children);\n        }\n        for (const prop in item.props) {\n            if (config.attributeBlacklist && config.attributeBlacklist.includes(prop)) {\n                continue;\n            }\n\n            if (config.attributeWhitelist && !config.attributeWhitelist.includes(prop)) {\n                continue;\n            }\n\n            if (item.props[prop] != undefined) {\n                propString += `${prop}=\"${item.props[prop].toString()}\" `;\n            }\n        }\n        return `<${item.name}${propString.trimEnd()}>${children}</${item.name}>`;\n    }\n}\n", "import { AurumElementModel, createAPI, Renderable } from '../aurum_element.js';\nimport { ArrayDataSource, DataSource } from '../../stream/data_source.js';\nimport { DuplexDataSource } from '../../stream/duplex_data_source.js';\nimport { CancellationToken } from '../../utilities/cancellation_token.js';\nimport { handleClass, handleStyle } from '../../nodes/rendering_helpers.js';\nimport { EventEmitter } from '../../utilities/event_emitter.js';\n\nexport class VDOM {\n    roots: VDOMNode[];\n    onChange: EventEmitter<{ changedNode: VDOMNode }>;\n    sessionToken: CancellationToken;\n    constructor(args: { vdom: VDOMNode[]; sessionToken: CancellationToken }) {\n        this.roots = args.vdom;\n        this.sessionToken = args.sessionToken;\n        this.onChange = new EventEmitter<{\n            changedNode: VDOMNode;\n        }>();\n    }\n\n    *[Symbol.iterator](): Iterator<{ node: VDOMNode; parent: VDOMNode }> {\n        for (const node of this.roots) {\n            yield* this.iterateVDOM(node, undefined);\n        }\n    }\n\n    private *iterateVDOM(node: VDOMNode, parent: VDOMNode): Generator<{ node: VDOMNode; parent: VDOMNode }> {\n        if (node.type === 'virtual') {\n            for (const child of node.children) {\n                yield* this.iterateVDOM(child, parent);\n            }\n            return;\n        }\n\n        yield { node, parent };\n        if (node.children) {\n            for (const child of node.children) {\n                yield* this.iterateVDOM(child, node);\n            }\n        }\n    }\n}\n\nexport interface VDOMNode {\n    type: 'text' | 'element' | 'virtual';\n    tag?: string;\n    attributes?: { [key: string]: string };\n    parent?: VDOMNode;\n    children?: VDOMNode[];\n    text?: string;\n}\n\nexport function aurumToVDOM(content: Renderable | Renderable[], sessionToken: CancellationToken): VDOM {\n    const root: VDOM = new VDOM({\n        vdom: [],\n        sessionToken\n    });\n    let renderToken = new CancellationToken();\n    sessionToken.addCancellable(() => {\n        if (renderToken) {\n            renderToken.cancel();\n        }\n    });\n    const virtualRoot: VDOMNode = {\n        type: 'virtual',\n        children: []\n    };\n    aurumToVDOMInternal(content, renderToken, root.onChange, virtualRoot);\n    root.roots = virtualRoot.children;\n    return root;\n}\n\nfunction aurumToVDOMInternal(\n    content: Renderable | Renderable[],\n    renderToken: CancellationToken,\n    change: EventEmitter<{ changedNode: VDOMNode }>,\n    parent: VDOMNode\n): {\n    tokens: CancellationToken[];\n} {\n    if (content === undefined || content === null) {\n        return {\n            tokens: []\n        };\n    }\n\n    if (Array.isArray(content)) {\n        const result = {\n            insertAt: -1,\n            insertCount: 0,\n            tokens: []\n        };\n        for (const item of content) {\n            const output = aurumToVDOMInternal(item, renderToken, change, parent);\n            result.tokens.push(...output.tokens);\n        }\n        return result;\n    }\n\n    if (content instanceof Promise) {\n        const virtualNode: VDOMNode = {\n            type: 'virtual',\n            children: []\n        };\n\n        content.then((c) => {\n            aurumToVDOMInternal(c, renderToken, change, virtualNode);\n            change.fire({\n                changedNode: parent\n            });\n        });\n\n        parent.children.push(virtualNode);\n        return {\n            tokens: []\n        };\n    }\n\n    if (['number', 'string', 'bigint', 'boolean'].includes(typeof content)) {\n        parent.children.push({\n            type: 'text',\n            text: content.toString()\n        });\n        return {\n            tokens: []\n        };\n    } else if (content instanceof DataSource || content instanceof DuplexDataSource) {\n        const virtualNode: VDOMNode = {\n            type: 'virtual',\n            children: []\n        };\n\n        content.listen((v) => {\n            virtualNode.children = [];\n            insertStats.tokens.forEach((t) => t.cancel());\n            insertStats = aurumToVDOMInternal(v, renderToken, change, virtualNode);\n            change.fire({\n                changedNode: parent\n            });\n        }, renderToken);\n\n        parent.children.push(virtualNode);\n        let insertStats = aurumToVDOMInternal(content.value, renderToken, change, virtualNode);\n        return insertStats;\n    } else if (content instanceof ArrayDataSource) {\n        const virtualNode: VDOMNode = {\n            type: 'virtual',\n            children: []\n        };\n\n        content.listen(() => {\n            virtualNode.children = [];\n            insertStats.tokens.forEach((t) => t.cancel());\n            insertStats = aurumToVDOMInternal(content.getData() as Renderable[], renderToken, change, virtualNode);\n            change.fire({\n                changedNode: parent\n            });\n        }, renderToken);\n\n        parent.children.push(virtualNode);\n        let insertStats = aurumToVDOMInternal(content.getData() as Renderable[], renderToken, change, virtualNode);\n        return insertStats;\n    } else {\n        const item = content as AurumElementModel<any>;\n        if (!item.isIntrinsic) {\n            const sessionToken = new CancellationToken();\n            const session = {\n                attachCalls: [],\n                sessionToken: sessionToken,\n                tokens: []\n            };\n            const api = createAPI(session);\n\n            renderToken.addCancellable(() => {\n                sessionToken.cancel();\n            });\n\n            sessionToken.addCancellable(() => {\n                for (const token of session.tokens) {\n                    token.cancel();\n                }\n            });\n            const data = aurumToVDOMInternal(item.factory(item.props, item.children, api), sessionToken, change, parent);\n            for (const call of session.attachCalls) {\n                call();\n            }\n\n            return {\n                tokens: [...data.tokens, sessionToken]\n            };\n        }\n\n        const element: VDOMNode = {\n            type: 'element',\n            tag: item.name,\n            children: []\n        };\n        element.attributes = item.props ? observeAttributes(element, item.props, renderToken, change) : undefined;\n\n        parent.children.push(element);\n\n        if (item.props?.onAttach) {\n            item.props.onAttach();\n        }\n\n        if (item.props?.onDetach) {\n            renderToken.addCancellable(() => {\n                item.props.onDetach();\n            });\n        }\n\n        if (item.children) {\n            aurumToVDOMInternal(item.children, renderToken, change, element);\n        }\n\n        return {\n            tokens: []\n        };\n    }\n}\n\nfunction observeAttributes(\n    node: VDOMNode,\n    props: any,\n    renderToken: CancellationToken,\n    change: EventEmitter<{ changedNode: VDOMNode }>\n): { [key: string]: string } {\n    const result: { [key: string]: string } = {};\n    for (const key in props) {\n        let element;\n        if (props.hasOwnProperty(key)) {\n            if (key === 'style') {\n                element = handleStyle(props[key], renderToken);\n            } else if (key === 'class') {\n                element = handleClass(props[key], renderToken);\n            } else {\n                element = props[key];\n            }\n\n            if (element instanceof DataSource) {\n                element.listen(() => {\n                    result[key] = element.value;\n                    change.fire({\n                        changedNode: node\n                    });\n                }, renderToken);\n                result[key] = element.value;\n            } else if (element instanceof DuplexDataSource) {\n                element.listen(() => {\n                    result[key] = element.value;\n                    change.fire({\n                        changedNode: node\n                    });\n                }, renderToken);\n                result[key] = element.value;\n            } else if (element instanceof ArrayDataSource) {\n                element.listen(() => {\n                    result[key] = element.getData().join(';');\n                    change.fire({\n                        changedNode: node\n                    });\n                }, renderToken);\n                result[key] = element.getData().join(';');\n            } else {\n                result[key] = element;\n            }\n        }\n    }\n    return result;\n}\n", "import { DataSource, ArrayDataSource } from './data_source.js';\nimport { Stream } from './stream.js';\nimport { DuplexDataSource } from './duplex_data_source.js';\nimport { CancellationToken, registerAnimationLoop } from '../utilities/cancellation_token.js';\nimport { ObjectDataSource } from './object_data_source.js';\nimport { dsDebounce, dsTap } from './data_source_operators.js';\n\n/**\n * Convenience function to update a stream at fixed intervals\n */\nexport function intervalEmitter<T = void>(\n    target: DataSource<T> | DuplexDataSource<T> | Stream<T, any> | ArrayDataSource<T>,\n    interval: number,\n    value: T,\n    cancellationToken?: CancellationToken\n): void {\n    (cancellationToken ?? new CancellationToken()).setInterval(() => {\n        updateSource<T>(target, value);\n    }, interval);\n}\n\nfunction updateSource<T = void>(target: DataSource<T> | DuplexDataSource<T> | Stream<T, any> | ArrayDataSource<T>, value: T) {\n    if (target instanceof ArrayDataSource) {\n        target.push(value);\n    } else if (target instanceof DuplexDataSource) {\n        target.updateDownstream(value);\n    } else {\n        target.update(value);\n    }\n}\n\nexport function urlHashEmitter(\n    target: DataSource<string> | DuplexDataSource<string> | Stream<string, any> | ArrayDataSource<string>,\n    stripInHashParameters: boolean = false,\n    cancellationToken?: CancellationToken\n): void {\n    updateSource(target, stripInHashParameters ? getUrlHash() : location.hash);\n    (cancellationToken ?? new CancellationToken()).registerDomEvent(window, 'hashchange', () => {\n        updateSource(target, stripInHashParameters ? getUrlHash() : location.hash);\n    });\n}\n\nfunction getUrlHash(): string {\n    const hash = location.hash.substring(1);\n    if (hash.includes('?')) {\n        return hash.substring(0, hash.indexOf('?'));\n    } else if (hash.includes('#')) {\n        return hash.substring(0, hash.indexOf('#'));\n    } else {\n        return hash;\n    }\n}\n\n/**\n * Convenience function to stream the window size to a data source\n */\nexport function windowSizeEmitter(target: ObjectDataSource<{ width: number; height: number }>, debounce: number = 100, cancellationToken?: CancellationToken) {\n    cancellationToken ??= new CancellationToken();\n    const updateStream = new DataSource<void>();\n    cancellationToken.registerDomEvent(window, 'resize', () => {\n        updateStream.update();\n    });\n    target.assign({\n        width: window.innerWidth,\n        height: window.innerHeight\n    });\n\n    updateStream.transform(\n        dsDebounce(debounce),\n        dsTap(() =>\n            target.assign({\n                width: window.innerWidth,\n                height: window.innerHeight\n            })\n        )\n    );\n}\n\n/**\n * Calls the callback every animation frame with a number from 0 to 1 indicating how far along in the animation timeline it is.\n *\n */\nexport function animate(cb: (progress: number) => void, time: number, cancellationToken: CancellationToken): Promise<void> {\n    return new Promise((resolve) => {\n        const animationToken = new CancellationToken();\n        if (cancellationToken) {\n            cancellationToken.chain(animationToken);\n        }\n        animationToken.addCancellable(resolve);\n        let start = Date.now();\n        registerAnimationLoop(() => {\n            const progress = Math.min(1, (Date.now() - start) / time);\n            cb(progress);\n            if (progress === 1) {\n                animationToken.cancel();\n            }\n        }, animationToken);\n    });\n}\n\n/**\n * Convenience function to stream animate to a datasource\n */\nexport function tweenEmitter(\n    target: DataSource<number> | DuplexDataSource<number> | Stream<number, any> | ArrayDataSource<number>,\n    duration: number,\n    startValue: number,\n    endValue: number,\n    interpolation?: (v: number) => number,\n    cancellationToken?: CancellationToken\n): Promise<void> {\n    if (target instanceof DataSource || target instanceof DuplexDataSource || target instanceof Stream) {\n        if (startValue === endValue) {\n            return new Promise((res) => setTimeout(res, duration));\n        }\n    }\n    return animate(\n        (progress) => {\n            if (interpolation) {\n                progress = interpolation(progress);\n            }\n            const value = startValue + (endValue - startValue) * progress;\n            if (target instanceof ArrayDataSource) {\n                target.push(value);\n            } else if (target instanceof DuplexDataSource) {\n                target.updateDownstream(value);\n            } else {\n                target.update(value);\n            }\n        },\n        duration,\n        cancellationToken\n    );\n}\n", "import { Renderable } from '../rendering/aurum_element.js';\nimport { ArrayDataSource, DataSource, ReadOnlyArrayDataSource } from '../stream/data_source.js';\nimport { CancellationToken } from './cancellation_token.js';\n\nexport function resolveChildren<T>(\n    children: Renderable[],\n    cancellationToken: CancellationToken,\n    validation?: (child: Renderable) => void\n): ReadOnlyArrayDataSource<T> {\n    const chunks: Array<ArrayDataSource<T> | T[]> = process<T>(children);\n    const result = ArrayDataSource.fromMultipleSources(chunks, cancellationToken);\n\n    if (validation) {\n        result.listen((c) => {\n            switch (c.operation) {\n                case 'add':\n                case 'replace':\n                case 'merge':\n                    for (const item of c.items) {\n                        validation(item as any);\n                    }\n                    break;\n            }\n        }, cancellationToken);\n    }\n\n    return result;\n}\n\nfunction process<T>(children: Renderable[]): Array<ArrayDataSource<T> | T[]> {\n    const chunks: Array<ArrayDataSource<T> | T[]> = [];\n    let currentChunk = [];\n    for (const child of children) {\n        if (child instanceof ArrayDataSource) {\n            if (currentChunk.length) {\n                chunks.push(currentChunk);\n                currentChunk.length = 0;\n            }\n            chunks.push(child as any as ArrayDataSource<T>);\n        } else if (child instanceof DataSource) {\n            currentChunk.push(child);\n        } else if (child instanceof DataSource) {\n            currentChunk.push(child);\n        } else if (child instanceof DataSource) {\n            currentChunk.push(child);\n        } else if (Array.isArray(child)) {\n            chunks.push(...process<T>(child));\n        } else {\n            currentChunk.push(child);\n        }\n    }\n    if (currentChunk.length) {\n        chunks.push(currentChunk);\n    }\n    return chunks;\n}\n", "import { AurumComponentAPI, AurumElementModel, Renderable } from '../rendering/aurum_element.js';\nimport { DataSource, ReadOnlyArrayDataSource } from '../stream/data_source.js';\nimport { dsDiff, dsMap, dsTap, dsUnique } from '../stream/data_source_operators.js';\nimport { urlHashEmitter } from '../stream/emitters.js';\nimport { resolveChildren } from '../utilities/transclusion.js';\n\nexport function AurumRouter(props: {}, children: Renderable[], api: AurumComponentAPI) {\n    const resolvedChildren = resolveChildren<AurumElementModel<RouteProps>>(children, api.cancellationToken, (c) => {\n        if ((c as AurumElementModel<any>).factory !== Route && (c as AurumElementModel<any>).factory !== DefaultRoute) {\n            throw new Error('Aurum Router only accepts Route and DefaultRoute instances as children');\n        }\n    }).filter(Boolean);\n    resolvedChildren\n        .reduce(\n            (acc, c) => {\n                if ((c as AurumElementModel<any>).factory === DefaultRoute) {\n                    return acc + 1;\n                } else {\n                    return acc;\n                }\n            },\n            0,\n            api.cancellationToken\n        )\n        .listenAndRepeat((count) => {\n            if (count > 1) {\n                throw new Error(`Too many default routes only 0 or 1 allowed. Found ${count}`);\n            }\n        });\n\n    const urlDataSource = new DataSource<string>();\n\n    if (typeof window !== 'undefined') {\n        urlHashEmitter(urlDataSource, true, api.cancellationToken);\n    }\n\n    const activeRoute = new DataSource<AurumElementModel<RouteProps>>();\n\n    activeRoute.transform(\n        dsUnique(),\n        dsDiff(),\n        dsTap(({ newValue, oldValue }) => {\n            if (oldValue) {\n                oldValue.props?.onNavigateFrom?.();\n            }\n            if (newValue) {\n                newValue.props?.onNavigateTo?.();\n            }\n        })\n    );\n\n    return urlDataSource\n        .transform(dsUnique(), api.cancellationToken)\n        .withInitial(urlDataSource.value)\n        .transform(dsMap((p) => selectRoute(p, resolvedChildren, activeRoute)));\n}\n\nfunction selectRoute(\n    url: string,\n    routes: ReadOnlyArrayDataSource<AurumElementModel<RouteProps>>,\n    activeRoute: DataSource<AurumElementModel<RouteProps>>\n): Renderable[] {\n    let selected;\n    if (url === undefined || url === null) {\n        selected = routes.find((r) => r.factory === DefaultRoute);\n    } else {\n        if (routes.find((r) => r.props?.href === url)) {\n            selected = routes.find((r) => r.props?.href === url);\n        } else {\n            const segments = url.split('/');\n            segments.pop();\n            while (segments.length) {\n                const path = segments.join('/');\n                if (routes.find((r) => r.props?.href === path)) {\n                    selected = routes.find((r) => r.props?.href === path);\n                    break;\n                }\n                segments.pop();\n            }\n            if (!selected) {\n                selected = routes.find((r) => r.factory === DefaultRoute);\n            }\n        }\n    }\n\n    if (selected) {\n        activeRoute.update(selected);\n        return selected.children;\n    } else {\n        activeRoute.update(undefined);\n        return undefined;\n    }\n}\n\nexport interface RouteProps {\n    href: string;\n    onNavigateTo?: () => void;\n    onNavigateFrom?: () => void;\n}\n\nexport function Route(props: RouteProps, children): undefined {\n    return undefined;\n}\n\nexport function DefaultRoute(props: Omit<RouteProps, 'href'>, children): undefined {\n    return undefined;\n}\n", "import { AurumComponentAPI, createLifeCycle, Renderable } from '../rendering/aurum_element.js';\nimport { DataSource } from '../stream/data_source.js';\n\nexport type ErrorRenderer = (error: any) => Renderable;\n\nexport interface ErrorBoundaryProps {\n    suspenseFallback?: Renderable;\n    errorFallback?: Renderable | ErrorRenderer;\n}\n\nexport function ErrorBoundary(props: ErrorBoundaryProps, children: Renderable[], api: AurumComponentAPI) {\n    const data = new DataSource<Renderable | Renderable[]>(props?.suspenseFallback);\n    const renderFallbackError: ErrorRenderer = typeof props?.errorFallback === 'function' ? props.errorFallback : (error) => props?.errorFallback as Renderable;\n\n    const lc = createLifeCycle();\n    api.onDetach(() => lc.onDetach());\n\n    function onDone(res: any[]): void {\n        if (!api.cancellationToken.isCancelled) {\n            data.update(res);\n            lc.onAttach();\n        }\n    }\n\n    function onError(error: any): void {\n        console.error(error);\n        if (!api.cancellationToken.isCancelled) {\n            data.update(renderFallbackError(error));\n        }\n    }\n\n    async function handleRenderedChildren(res: any) {\n        if (res instanceof Promise) {\n            res.then(handleRenderedChildren, onError);\n        } else {\n            const nestedRendered = api.prerender(res, lc);\n            if (nestedRendered.some((s) => s instanceof Promise)) {\n                await Promise.all(nestedRendered).then(handleRenderedChildren, onError);\n            } else {\n                onDone(nestedRendered);\n            }\n        }\n    }\n\n    async function renderChildren() {\n        try {\n            const rendered = api.prerender(children, lc);\n            await handleRenderedChildren(rendered);\n        } catch (error) {\n            onError(error);\n        }\n    }\n    renderChildren();\n\n    return data;\n}\n", "import { AurumComponentAPI, Renderable } from '../rendering/aurum_element.js';\nimport { Aurum } from '../utilities/aurum.js';\nimport { ErrorBoundary } from './error_boundary.js';\n\nexport interface SuspenseProps {\n    fallback?: Renderable;\n}\n\nexport function Suspense(props: SuspenseProps, children: Renderable[], api: AurumComponentAPI) {\n    return (\n        <ErrorBoundary\n            suspenseFallback={props?.fallback}\n            errorFallback={(error) => {\n                throw error;\n            }}\n        >\n            {children}\n        </ErrorBoundary>\n    );\n}\n", "import { AurumComponentAPI, AurumElementModel, aurumElementModelIdentitiy, Renderable } from '../rendering/aurum_element.js';\nimport { GenericDataSource, ReadOnlyDataSource } from '../stream/data_source.js';\nimport { dsMap, dsUnique } from '../stream/data_source_operators.js';\nimport { CancellationToken } from '../utilities/cancellation_token.js';\n\nexport interface SwitchProps<T = boolean> {\n    state: ReadOnlyDataSource<T>;\n}\n\nexport function Switch<T = boolean>(props: SwitchProps<T>, children: Renderable[], api: AurumComponentAPI) {\n    children = [].concat.apply(\n        [],\n        children.filter((c) => !!c)\n    );\n    if (\n        children.some(\n            (c) =>\n                !c[aurumElementModelIdentitiy] ||\n                !((c as AurumElementModel<any>).factory === SwitchCase || (c as AurumElementModel<any>).factory === DefaultSwitchCase)\n        )\n    ) {\n        throw new Error('Switch only accepts SwitchCase as children');\n    }\n    if (children.filter((c) => (c as AurumElementModel<any>).factory === DefaultSwitchCase).length > 1) {\n        throw new Error('Too many default switch cases only 0 or 1 allowed');\n    }\n\n    const cleanUp = new CancellationToken();\n    api.onDetach(() => {\n        cleanUp.cancel();\n    });\n\n    const u: GenericDataSource<T> = props.state.transform(dsUnique(), cleanUp) as GenericDataSource<T>;\n    return u.withInitial(props.state.value).transform(dsMap((state) => selectCase(state, children as AurumElementModel<SwitchCaseProps<any>>[])));\n}\n\nfunction selectCase<T>(state: T, children: AurumElementModel<SwitchCaseProps<any>>[]) {\n    return children.find((c) => c.props?.when === state)?.children ?? children.find((p) => p.factory === DefaultSwitchCase)?.children;\n}\n\nexport interface SwitchCaseProps<T> {\n    when: T;\n}\n\nexport function SwitchCase<T>(props: SwitchCaseProps<T>, children): undefined {\n    return undefined;\n}\n\nexport function DefaultSwitchCase(props: {}, children): undefined {\n    return undefined;\n}\n", "import { CancellationToken } from '../utilities/cancellation_token.js';\nimport { Callback } from '../utilities/common.js';\nimport { EventEmitter } from '../utilities/event_emitter.js';\nimport { getValueOf } from '../utilities/sources.js';\nimport { ArrayDataSource, CollectionChange, ReadOnlyArrayDataSource } from './data_source.js';\n\nexport type GenericTree<T, K extends keyof T> = {\n    [P in K]: GenericTree<T, K>[] | ArrayDataSource<any>;\n};\n\nexport interface TreeChange<T> {\n    parentNode: T;\n    changedNode: T;\n    index: number;\n    operation: 'added' | 'deleted';\n}\n\ntype TreeIteration<T> = {\n    parent: T;\n    node: T;\n    level: number;\n    index: number;\n    lastIndex: number;\n};\n\nexport class TreeDataSource<T, K extends keyof T> {\n    private childrenKey: K;\n    private roots: ArrayDataSource<GenericTree<T, K>>;\n    private updateEvent: EventEmitter<TreeChange<T>>;\n    private watchCount: number = 0;\n    private watchToken: CancellationToken;\n\n    constructor(childrenKey: K, roots: Array<GenericTree<T, K>> | ArrayDataSource<GenericTree<T, K>>) {\n        this.childrenKey = childrenKey;\n        this.roots = ArrayDataSource.toArrayDataSource(roots);\n        this.updateEvent = new EventEmitter<TreeChange<T>>();\n    }\n\n    private watch(cancellationToken: CancellationToken): void {\n        this.watchCount++;\n        cancellationToken.addCancellable(() => {\n            this.watchCount--;\n            if (this.watchCount === 0) {\n                this.watchToken.cancel();\n                this.watchToken = undefined;\n            }\n        });\n\n        if (!this.watchToken) {\n            this.watchToken = new CancellationToken();\n\n            const watchMap = new Map<T, CancellationToken>();\n            if (this.roots instanceof ArrayDataSource) {\n                this.roots.listen((change) => {\n                    this.watchHandleChange(change as any, undefined, watchMap);\n                }, this.watchToken);\n            }\n\n            for (const root of this.roots) {\n                for (const { node } of this.iterateLevelWithMetaData(root, this.roots.length.value)) {\n                    if (node[this.childrenKey] instanceof ArrayDataSource) {\n                        watchMap.set(node, new CancellationToken());\n                        this.watchToken.chain(watchMap.get(node));\n                        (node[this.childrenKey] as any as ArrayDataSource<T>).listenAndRepeat((change) => {\n                            this.watchHandleChange(change, node, watchMap);\n                        }, watchMap.get(node));\n                    }\n                }\n            }\n        }\n    }\n\n    private watchHandleChange(change: CollectionChange<T>, parent: T, watchMap: Map<T, CancellationToken>): void {\n        switch (change.operation) {\n            case 'add':\n                let i = 0;\n                for (const item of change.items) {\n                    this.updateEvent.fire({\n                        changedNode: item,\n                        index: change.index + i++,\n                        parentNode: parent,\n                        operation: 'added'\n                    });\n                    if (item[this.childrenKey] instanceof ArrayDataSource) {\n                        watchMap.set(item, new CancellationToken());\n                        this.watchToken.chain(watchMap.get(item));\n                        (item[this.childrenKey] as any as ArrayDataSource<T>).listenAndRepeat((change) => {\n                            this.watchHandleChange(change, item, watchMap);\n                        }, watchMap.get(item));\n                    }\n                }\n                break;\n            case 'remove':\n                let j = 0;\n                for (const item of change.items) {\n                    watchMap.get(item)?.cancel();\n                    this.updateEvent.fire({\n                        changedNode: item,\n                        index: change.index + j++,\n                        parentNode: parent,\n                        operation: 'deleted'\n                    });\n                }\n                break;\n            case 'merge':\n                throw new Error('Not implemented');\n            case 'replace':\n                this.updateEvent.fire({\n                    changedNode: change.target,\n                    index: change.index,\n                    parentNode: parent,\n                    operation: 'deleted'\n                });\n                this.updateEvent.fire({\n                    changedNode: change.items[0],\n                    index: change.index,\n                    parentNode: parent,\n                    operation: 'added'\n                });\n                break;\n        }\n    }\n\n    public listen(callback: Callback<TreeChange<T>>, cancellationToken: CancellationToken): Callback<void> {\n        this.watch(cancellationToken);\n\n        return this.updateEvent.subscribe(callback, cancellationToken).cancel;\n    }\n\n    public listenAndRepeat(callback: Callback<TreeChange<T>>, cancellationToken: CancellationToken): Callback<void> {\n        for (const { parent, node, index } of this.iterateLevelWithMetaData(this.roots as any, 0)) {\n            callback({\n                changedNode: node,\n                index,\n                parentNode: parent,\n                operation: 'added'\n            });\n        }\n\n        return this.listen(callback, cancellationToken);\n    }\n\n    private adaptNodeList(nodes: ArrayDataSource<GenericTree<T, K>>, token: CancellationToken, nodeList = new ArrayDataSource<T>()): ArrayDataSource<T> {\n        const adaptMap = new Map<GenericTree<T, K>, CancellationToken>();\n        nodes.listenAndRepeat((change) => {\n            switch (change.operation) {\n                case 'add':\n                    for (const item of change.items) {\n                        this.addItem(adaptMap, token, item, nodeList);\n                    }\n                    break;\n                case 'remove':\n                    for (const item of change.items) {\n                        this.removeItem(nodeList, adaptMap, item);\n                    }\n                    break;\n                case 'merge':\n                    throw new Error('Not implemented');\n                case 'replace':\n                    this.removeItem(nodeList, adaptMap, change.target);\n                    this.addItem(adaptMap, token, change.items[0], nodeList);\n                    break;\n            }\n        }, token);\n\n        return nodeList;\n    }\n\n    private adaptNodeTree(\n        parent: GenericTree<any, any>,\n        nodes: ArrayDataSource<GenericTree<any, any>>,\n        mapper: (item: any) => any,\n        newKey: string | number | symbol,\n        token: CancellationToken\n    ): ArrayDataSource<GenericTree<any, any>> {\n        nodes = ArrayDataSource.toArrayDataSource(nodes);\n        const newRoots = nodes.map(mapper);\n        if (parent) {\n            parent[newKey as any] = newRoots as any;\n        }\n\n        nodes.listenAndRepeat((change) => {\n            switch (change.operation) {\n                case 'add':\n                    let i = change.index;\n                    for (const item of change.items) {\n                        this.adaptNodeTree(newRoots.get(i++), item[newKey as any] as any, mapper, newKey, token);\n                    }\n                    break;\n                case 'merge':\n                    throw new Error('Not implemented');\n                case 'replace':\n                    this.adaptNodeTree(newRoots[change.index], change.items[0][newKey as any] as any, mapper, newKey, token);\n                    break;\n            }\n        }, token);\n\n        return newRoots as any;\n    }\n\n    public map<U, K2 extends keyof U>(\n        mapper: (item: T) => U,\n        newKey: K2 = this.childrenKey as any,\n        cancellationToken?: CancellationToken\n    ): TreeDataSource<U, K2> {\n        return new TreeDataSource<U, K2>(newKey, this.adaptNodeTree(undefined, this.roots, mapper, newKey, cancellationToken));\n    }\n\n    private addItem(\n        adaptMap: Map<GenericTree<T, K>, CancellationToken>,\n        parentToken: CancellationToken,\n        item: GenericTree<T, K>,\n        nodeList: ArrayDataSource<T>\n    ): void {\n        nodeList.push(item as any);\n        adaptMap.set(item, new CancellationToken());\n        parentToken.chain(adaptMap.get(item));\n        const list = ArrayDataSource.toArrayDataSource(item[this.childrenKey]);\n        this.adaptNodeList(list, adaptMap.get(item), nodeList);\n    }\n\n    private removeItem(nodeList: ArrayDataSource<T>, adaptMap: Map<GenericTree<T, K>, CancellationToken>, item: GenericTree<T, K>): void {\n        adaptMap.get(item).cancel();\n        nodeList.remove(item as any);\n    }\n\n    public createArrayDataSourceOfNodes(cancellationToken: CancellationToken): ReadOnlyArrayDataSource<T> {\n        return this.adaptNodeList(this.roots, cancellationToken);\n    }\n\n    *[Symbol.iterator](): IterableIterator<T> {\n        for (const root of this.roots) {\n            yield* this.iterateLevel(root as any);\n        }\n        return;\n    }\n\n    public *iterateWithMetaData() {\n        let i = 0;\n        for (const root of this.roots) {\n            yield* this.iterateLevelWithMetaData(root, this.roots.length.value, undefined, i);\n        }\n        return;\n    }\n\n    private *iterateLevelWithMetaData(\n        node: GenericTree<T, K>,\n        lastIndex: number,\n        parent?: T,\n        index: number = 0,\n        level: number = 0\n    ): IterableIterator<TreeIteration<T>> {\n        yield { node: node as any, parent, index, level, lastIndex };\n        let i = 0;\n        for (const child of node[this.childrenKey]) {\n            yield* this.iterateLevelWithMetaData(child, getValueOf(node[this.childrenKey].length), node as any, i++, level + 1);\n        }\n    }\n\n    private *iterateLevel(level: GenericTree<T, K>): IterableIterator<T> {\n        yield level as any;\n        for (const child of level[this.childrenKey]) {\n            yield* this.iterateLevel(child);\n        }\n    }\n}\n", "import { MapLike } from './common.js';\n\nexport class UrlStorage implements Storage {\n    private state: MapLike<string>;\n    private originalReplaceState: (data: any, unused: string, url?: string | URL) => void;\n    private updating: boolean = false;\n\n    constructor() {\n        this.state = {};\n        this.observeUrl();\n        window.addEventListener('hashchange', () => this.checkUpdate());\n        this.checkUpdate();\n    }\n\n    private observeUrl(): void {\n        this.originalReplaceState = history.replaceState.bind(history);\n        history.replaceState = (...args: any[]) => {\n            this.originalReplaceState.apply(history, args);\n            this.checkUpdate();\n        };\n    }\n\n    public get length(): number {\n        return Object.keys(this.state).length;\n    }\n\n    public clear(): void {\n        this.state = {};\n        this.applyStateToUrl();\n    }\n    public getItem(key: string): string {\n        return this.state[key];\n    }\n    public key(index: number): string {\n        return Object.keys(this.state)[index];\n    }\n    public removeItem(key: string): void {\n        delete this.state[key];\n        if (!this.updating) {\n            this.applyStateToUrl();\n        }\n    }\n    public setItem(key: string, value: string): void {\n        this.state[key] = value;\n        if (!this.updating) {\n            this.applyStateToUrl();\n        }\n    }\n    private applyStateToUrl() {\n        // Take the state and turn it into a parameter string and set it as the url\n        const url = new URL(location.href);\n        for (const param of url.searchParams.entries()) {\n            url.searchParams.delete(param[0]);\n        }\n        for (const key in this.state) {\n            url.searchParams.set(key, this.state[key]);\n        }\n\n        this.originalReplaceState({}, '', url.href);\n    }\n\n    /**\n     * For url changes that are not observable such as parent window changes\n     */\n    public refresh(): void {\n        this.checkUpdate();\n    }\n\n    private checkUpdate(): void {\n        const result = Object.fromEntries(new URL(location.href).searchParams);\n        this.updating = true;\n        try {\n            for (const key in result) {\n                if (result[key] !== this.state[key]) {\n                    this.setItem(key, result[key]);\n                }\n            }\n\n            for (const key in this.state) {\n                if (result[key] === undefined) {\n                    this.removeItem(key);\n                }\n            }\n        } finally {\n            this.updating = false;\n        }\n    }\n}\n", "import { ArrayDataSource, SetDataSource } from '../stream/data_source.js';\nimport { DuplexDataSource } from '../stream/duplex_data_source.js';\nimport { CancellationToken } from './cancellation_token.js';\nimport { EventEmitter } from './event_emitter.js';\nimport { UrlStorage } from './url_storage.js';\n\nexport class StorageStream {\n    public readonly storageAPI: Storage;\n    private onChange: EventEmitter<{ key: string; value: string }>;\n    private originalSetItem: (key: string, value: string) => void;\n    private originalRemoveItem: (key: string) => void;\n\n    constructor(storageAPI: Storage) {\n        this.onChange = new EventEmitter<{ key: string; value: string }>();\n        this.storageAPI = storageAPI;\n        this.observeStorageAPI(storageAPI);\n    }\n\n    private observeStorageAPI(storageAPI: Storage): void {\n        this.originalSetItem = storageAPI.setItem.bind(storageAPI);\n        storageAPI.setItem = (key: string, value: any) => {\n            this.originalSetItem(key, value);\n            this.onChange.fire({ key, value });\n        };\n\n        this.originalRemoveItem = storageAPI.removeItem.bind(storageAPI);\n        storageAPI.removeItem = (key: string) => {\n            this.originalRemoveItem(key);\n            this.onChange.fire({ key, value: undefined });\n        };\n\n        const originalClear = storageAPI.clear.bind(storageAPI);\n        storageAPI.clear = () => {\n            originalClear();\n            this.onChange.fire({ key: '*', value: undefined });\n        };\n    }\n\n    public listenAsString(key: string, defaultValue: string, cancellationToken?: CancellationToken): DuplexDataSource<string> {\n        const stream = new DuplexDataSource<string>().withInitial(this.storageAPI.getItem(key) ?? defaultValue);\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.updateDownstream(e.value ?? defaultValue);\n            }\n        }, cancellationToken);\n\n        stream.listenUpstream((v) => {\n            if (v === undefined || v === defaultValue) {\n                this.originalRemoveItem(key);\n            } else {\n                this.originalSetItem(key, v);\n            }\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    public listenAsNumber(key: string, defaultValue: number, cancellationToken?: CancellationToken, radix: number = 10): DuplexDataSource<number> {\n        const stream = new DuplexDataSource<number>().withInitial(this.storageAPI.getItem(key) ? parseInt(this.storageAPI.getItem(key), radix) : defaultValue);\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.updateDownstream(e.value != undefined ? parseInt(e.value, radix) : defaultValue);\n            }\n        }, cancellationToken);\n\n        stream.listenUpstream((v) => {\n            if (v === undefined || v === defaultValue) {\n                this.originalRemoveItem(key);\n            } else {\n                this.originalSetItem(key, v.toString());\n            }\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    public listenAsDate(key: string, defaultValue: Date, cancellationToken?: CancellationToken): DuplexDataSource<Date> {\n        const stream = new DuplexDataSource<Date>().withInitial(this.storageAPI.getItem(key) ? new Date(this.storageAPI.getItem(key)) : defaultValue);\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.updateDownstream(e.value != undefined ? new Date(e.value) : defaultValue);\n            }\n        }, cancellationToken);\n\n        stream.listenUpstream((v) => {\n            if (v === undefined || v === defaultValue) {\n                this.originalRemoveItem(key);\n            } else {\n                this.originalSetItem(key, v.toJSON());\n            }\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    public listenAsBoolean(key: string, defaultValue: boolean, cancellationToken?: CancellationToken): DuplexDataSource<boolean> {\n        const stream = new DuplexDataSource<boolean>().withInitial(this.storageAPI.getItem(key) ? this.storageAPI.getItem(key) === 'true' : defaultValue);\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.updateDownstream(e.value != undefined ? e.value === 'true' : defaultValue);\n            }\n        }, cancellationToken);\n\n        stream.listenUpstream((v) => {\n            if (v === undefined || v === defaultValue) {\n                this.originalRemoveItem(key);\n            } else {\n                this.originalSetItem(key, v.toString());\n            }\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    // Since objects can be mutable a provider can be used to regenerate the object on each use of the default value\n    public listenAsObject<T>(key: string, defaultValueOrProvider: T | (() => T), cancellationToken?: CancellationToken): DuplexDataSource<T> {\n        const stream = new DuplexDataSource<T>().withInitial(\n            this.storageAPI.getItem(key)\n                ? JSON.parse(this.storageAPI.getItem(key))\n                : typeof defaultValueOrProvider === 'function'\n                ? (defaultValueOrProvider as () => T)()\n                : defaultValueOrProvider\n        );\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.updateDownstream(\n                    e.value != undefined\n                        ? JSON.parse(e.value)\n                        : typeof defaultValueOrProvider === 'function'\n                        ? (defaultValueOrProvider as () => T)()\n                        : defaultValueOrProvider\n                );\n            }\n        }, cancellationToken);\n\n        stream.listenUpstream((v) => {\n            if (v === undefined) {\n                this.originalRemoveItem(key);\n            } else {\n                this.originalSetItem(key, JSON.stringify(v));\n            }\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    public listenAsEnum<T>(key: string, defaultValue: T, cancellationToken?: CancellationToken): DuplexDataSource<T> {\n        const stream = new DuplexDataSource<T>().withInitial((this.storageAPI.getItem(key) as unknown as T) ?? defaultValue);\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.updateDownstream(e.value != undefined ? (e.value as unknown as T) : defaultValue);\n            }\n        }, cancellationToken);\n\n        stream.listenUpstream((v) => {\n            if (v === undefined || v === defaultValue) {\n                this.originalRemoveItem(key);\n            } else {\n                this.originalSetItem(key, v.toString());\n            }\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    public listenAsArray<T>(key: string, cancellationToken?: CancellationToken): ArrayDataSource<T> {\n        const stream = new ArrayDataSource<T>(JSON.parse(this.storageAPI.getItem(key) ?? '[]'));\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.merge(e.value != undefined ? JSON.parse(e.value) : []);\n            }\n        }, cancellationToken);\n\n        stream.listen((v) => {\n            this.originalSetItem(key, JSON.stringify(v.newState));\n        }, cancellationToken);\n\n        return stream;\n    }\n\n    public listenAsSet<T>(key: string, cancellationToken?: CancellationToken): SetDataSource<T> {\n        const stream = new SetDataSource<T>(JSON.parse(this.storageAPI.getItem(key) ?? '[]'));\n\n        this.onChange.subscribe((e) => {\n            if (e.key === key || e.key === '*') {\n                stream.merge(e.value != undefined ? JSON.parse(e.value) : []);\n            }\n        }, cancellationToken);\n\n        stream.listen((v) => {\n            this.originalSetItem(key, JSON.stringify(stream.toArray()));\n        }, cancellationToken);\n\n        return stream;\n    }\n}\n\nexport let localStorageStream: StorageStream;\nif (typeof localStorage !== 'undefined') {\n    localStorageStream = new StorageStream(localStorage);\n}\nexport let sessionStorageStream: StorageStream;\nif (typeof sessionStorage !== 'undefined') {\n    sessionStorageStream = new StorageStream(sessionStorage);\n}\nexport let urlStorageStream: StorageStream;\nif (typeof location !== 'undefined') {\n    urlStorageStream = new StorageStream(new UrlStorage());\n}\n", "import { AurumComponentAPI, Renderable } from '../rendering/aurum_element.js';\nimport { Aurum, AurumDecorator } from '../utilities/aurum.js';\n\nexport function attachNotifier<T>(onAttach?: () => void, onDetach?: () => void): AurumDecorator {\n    return function (model): Renderable {\n        function Wrapper(props: {}, children: Renderable[], api: AurumComponentAPI) {\n            api.onAttach(() => {\n                onAttach?.();\n            });\n            api.onDetach(() => {\n                onDetach?.();\n            });\n\n            return children;\n        }\n\n        return <Wrapper>{model}</Wrapper>;\n    };\n}\n"],
  "mappings": "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",
  "names": ["RemoteProtocol", "_a", "OperationType", "DataFlow", "DataFlowBoth", "e", "i", "args", "rendered", "index", "Text", "Symbol", "Object", "Object", "Text", "Symbol", "_a", "change"]
}
